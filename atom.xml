<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TizzyT&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/9dde1b9d65b89035e235650923e5811e</icon>
  <subtitle>即使是拖后腿的，拼死努力的话，也是可以超越精英的。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jianghao.wang/"/>
  <updated>2019-05-08T03:16:47.181Z</updated>
  <id>http://jianghao.wang/</id>
  
  <author>
    <name>yeqiaozhu</name>
    <email>yqz_zjut@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swap Nodes In Pairs</title>
    <link href="http://jianghao.wang/2019/Swap%20Nodes%20In%20Pairs/"/>
    <id>http://jianghao.wang/2019/Swap Nodes In Pairs/</id>
    <published>2019-05-08T01:27:49.890Z</published>
    <updated>2019-05-08T03:16:47.181Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述（难度中等）"><a href="#题目描述（难度中等）" class="headerlink" title="题目描述（难度中等）"></a>题目描述（难度中等）</h3><p>Given a linked list, swap every two adjacent nodes and return its head.</p><p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure><h3 id="方法一：遍历一遍链表"><a href="#方法一：遍历一遍链表" class="headerlink" title="方法一：遍历一遍链表"></a>方法一：遍历一遍链表</h3><p>链表改变顺序的题目，通用的方法论是先找出一次需要改变指向的节点数量。交换相邻节点需要改变<strong>current（相邻节点前节点的前节点），first（相邻节点前节点），second（相邻节点后节点）。</strong>current在链表头部自定义一个初始值为0的节点。</p><p><img src="https://arthornye.github.io/images/swapping.jpg" alt="cmd-markdown-logo"></p><p><strong>上图中展示了链表指向的过程，三个节点都需要进行重定向，一次循环后的结果：</strong></p><p><img src="https://arthornye.github.io/images/swappingonce.jpg" alt="cmd-markdown-logo"></p><p><strong>第二次循环继续将current往后平移两个单位，继续执行循环赋值：</strong></p><p><img src="https://arthornye.github.io/images/swappingtwice.jpg" alt="cmd-markdown-logo"></p><p><strong>得到循环赋值结果：</strong></p><p><img src="https://arthornye.github.io/images/swappingtwicefinished.jpg" alt="cmd-markdown-logo"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述（难度中等）&quot;&gt;&lt;a href=&quot;#题目描述（难度中等）&quot; class=&quot;headerlink&quot; title=&quot;题目描述（难度中等）&quot;&gt;&lt;/a&gt;题目描述（难度中等）&lt;/h3&gt;&lt;p&gt;Given a linked list, swap every two ad
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MapStruct使用</title>
    <link href="http://jianghao.wang/2019/MapStruct%E4%BD%BF%E7%94%A8/"/>
    <id>http://jianghao.wang/2019/MapStruct使用/</id>
    <published>2019-04-19T06:37:19.028Z</published>
    <updated>2019-04-19T10:47:43.878Z</updated>
    
    <content type="html"><![CDATA[<p>我们在实际开发过程中会出现很多bean之间的拷贝动作，这样的动作需要不停的去进行set操作。容易造成代码的耦合和维护困难。通过MapStruct我们只需要定义一个接口，这个工具包会帮我们自动生成一个实现类，并且这个类是不可编辑的，代码自动生成帮我们省去了开发维护成本同时做了一定的解耦。</p><h3 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h3><p>使用MapStruct我们需要通过maven导入相关的依赖：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mapstruct-jdk8&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.0.Beta2&lt;/version&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>同时我们需要添加<strong><em>maven-compiler-plugin</em></strong>，其中<strong><em>mapstruct-processor</em></strong>用于构建mapper实现类的生成器。</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.1&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">        &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">        &lt;annotationProcessorPaths&gt;</span><br><span class="line">            &lt;path&gt;</span><br><span class="line">                &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;1.3.0.Beta2&lt;/version&gt;</span><br><span class="line">            &lt;/path&gt;</span><br><span class="line">        &lt;/annotationProcessorPaths&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><h3 id="基本的Mapping用法"><a href="#基本的Mapping用法" class="headerlink" title="基本的Mapping用法"></a>基本的Mapping用法</h3><p>定义一个Java的POJO类和Mapper Interface:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDestination</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SimpleSourceDestinationMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">SimpleDestination <span class="title">sourceToDestination</span><span class="params">(SimpleSource source)</span></span>;</span><br><span class="line">    <span class="function">SimpleSource <span class="title">destinationToSource</span><span class="params">(SimpleDestination destination)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到我们这里并没有去实现这个接口，但是<strong>MapStruct帮我们生成了一个实现类</strong>。我们可以通过调用<strong><em>mvn compile</em></strong>或者通过<strong><em>mvn clean install</em></strong>调用MapStruct，它会帮我们生成一个Mapper的实现类在<strong><em>/target/generated-sources/annotations/</em></strong>目录下。这里贴上一段，<strong>注意这个类是不可编辑的，如果编辑这个类，再重新执行编译之后也会被替换掉</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSourceDestinationMapperImpl</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">SimpleSourceDestinationMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleDestination <span class="title">sourceToDestination</span><span class="params">(SimpleSource source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( source == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SimpleDestination simpleDestination = <span class="keyword">new</span> SimpleDestination();</span><br><span class="line">        simpleDestination.setName( source.getName() );</span><br><span class="line">        simpleDestination.setDescription( source.getDescription() );</span><br><span class="line">        <span class="keyword">return</span> simpleDestination;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleSource <span class="title">destinationToSource</span><span class="params">(SimpleDestination destination)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( destination == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SimpleSource simpleSource = <span class="keyword">new</span> SimpleSource();</span><br><span class="line">        simpleSource.setName( destination.getName() );</span><br><span class="line">        simpleSource.setDescription( destination.getDescription() );</span><br><span class="line">        <span class="keyword">return</span> simpleSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行一个测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSourceDestinationMapperTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SimpleSourceDestinationMapper mapper</span><br><span class="line">      = Mappers.getMapper(SimpleSourceDestinationMapper.class);</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenSourceToDestination_whenMaps_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleSource simpleSource = <span class="keyword">new</span> SimpleSource();</span><br><span class="line">        simpleSource.setName(<span class="string">"SourceName"</span>);</span><br><span class="line">        simpleSource.setDescription(<span class="string">"SourceDescription"</span>);</span><br><span class="line">        SimpleDestination destination = mapper.sourceToDestination(simpleSource);</span><br><span class="line">  </span><br><span class="line">        assertEquals(simpleSource.getName(), destination.getName());</span><br><span class="line">        assertEquals(simpleSource.getDescription(), </span><br><span class="line">          destination.getDescription());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenDestinationToSource_whenMaps_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleDestination destination = <span class="keyword">new</span> SimpleDestination();</span><br><span class="line">        destination.setName(<span class="string">"DestinationName"</span>);</span><br><span class="line">        destination.setDescription(<span class="string">"DestinationDescription"</span>);</span><br><span class="line">        SimpleSource source = mapper.destinationToSource(destination);</span><br><span class="line">        assertEquals(destination.getName(), source.getName());</span><br><span class="line">        assertEquals(destination.getDescription(),</span><br><span class="line">          source.getDescription());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过依赖注入的方式获取Mapper服务"><a href="#通过依赖注入的方式获取Mapper服务" class="headerlink" title="通过依赖注入的方式获取Mapper服务"></a>通过依赖注入的方式获取Mapper服务</h3><p>我们一般情况下可以通过<strong><em>Mappers.getMapper(YourClass.class)</em></strong>的方式获取到一个Mapper实例，然后调用到具体的mapper方法，我们也可以注入的方式获取到我们的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span>(componentModel = <span class="string">"spring"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SimpleSourceDestinationMapper</span></span></span><br></pre></td></tr></table></figure><p>在interface上加了这个属性之后，我们可以通过<strong><em>@Autowire</em></strong>的方式在任何地方引用这个实例。</p><h3 id="映射不同的字段名"><a href="#映射不同的字段名" class="headerlink" title="映射不同的字段名"></a>映射不同的字段名</h3><p>针对下面的POJOs我们可以定义另一个Mapper:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDTO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> employeeId;</span><br><span class="line">    <span class="keyword">private</span> String employeeName;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Mappings</span>(&#123;</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"employeeId"</span>, source=<span class="string">"entity.id"</span>),</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"employeeName"</span>, source=<span class="string">"entity.name"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">EmployeeDTO <span class="title">employeeToEmployeeDTO</span><span class="params">(Employee entity)</span></span>;</span><br><span class="line">    <span class="meta">@Mappings</span>(&#123;</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"id"</span>, source=<span class="string">"dto.employeeId"</span>),</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"name"</span>, source=<span class="string">"dto.employeeName"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">Employee <span class="title">employeeDTOtoEmployee</span><span class="params">(EmployeeDTO dto)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="映射对象字段"><a href="#映射对象字段" class="headerlink" title="映射对象字段"></a>映射对象字段</h3><p>如果这边两个类之间的映射中还有嵌套的对象，我们在同一个Mapper的接口中定义这两个嵌套对象的转换规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDTO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> employeeId;</span><br><span class="line">    <span class="keyword">private</span> String employeeName;</span><br><span class="line">    <span class="keyword">private</span> DivisionDTO division;</span><br><span class="line">    <span class="comment">// getters and setters omitted</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Division division;</span><br><span class="line">    <span class="comment">// getters and setters omitted</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Division</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// default constructor, getters and setters omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改之后的Mapper接口为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DivisionDTO <span class="title">divisionToDivisionDTO</span><span class="params">(Division entity)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">Division <span class="title">divisionDTOtoDivision</span><span class="params">(DivisionDTO dto)</span></span>;</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenEmpDTONestedMappingToEmp_whenMaps_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EmployeeDTO dto = <span class="keyword">new</span> EmployeeDTO();</span><br><span class="line">    dto.setDivision(<span class="keyword">new</span> DivisionDTO(<span class="number">1</span>, <span class="string">"Division1"</span>));</span><br><span class="line">    Employee entity = mapper.employeeDTOtoEmployee(dto);</span><br><span class="line">    assertEquals(dto.getDivision().getId(), </span><br><span class="line">      entity.getDivision().getId());</span><br><span class="line">    assertEquals(dto.getDivision().getName(), </span><br><span class="line">      entity.getDivision().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字段类型转换"><a href="#字段类型转换" class="headerlink" title="字段类型转换"></a>字段类型转换</h3><p>如果我们需要将一个String类型映射为Date类型的字段，定义一个dateFormat，同时还提供了expression等属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mappings</span>(&#123;</span><br><span class="line">  <span class="meta">@Mapping</span>(target=<span class="string">"employeeId"</span>, source = <span class="string">"entity.id"</span>),</span><br><span class="line">  <span class="meta">@Mapping</span>(target=<span class="string">"employeeName"</span>, source = <span class="string">"entity.name"</span>),</span><br><span class="line">  <span class="meta">@Mapping</span>(target=<span class="string">"employeeStartDt"</span>, source = <span class="string">"entity.startDt"</span>,</span><br><span class="line">           dateFormat = <span class="string">"dd-MM-yyyy HH:mm:ss"</span>)&#125;)</span><br><span class="line"><span class="function">EmployeeDTO <span class="title">employeeToEmployeeDTO</span><span class="params">(Employee entity)</span></span>;</span><br><span class="line"><span class="meta">@Mappings</span>(&#123;</span><br><span class="line">  <span class="meta">@Mapping</span>(target=<span class="string">"id"</span>, source=<span class="string">"dto.employeeId"</span>),</span><br><span class="line">  <span class="meta">@Mapping</span>(target=<span class="string">"name"</span>, source=<span class="string">"dto.employeeName"</span>),</span><br><span class="line">  <span class="meta">@Mapping</span>(target=<span class="string">"startDt"</span>, source=<span class="string">"dto.employeeStartDt"</span>,</span><br><span class="line">           dateFormat=<span class="string">"dd-MM-yyyy HH:mm:ss"</span>)&#125;)</span><br><span class="line"><span class="function">Employee <span class="title">employeeDTOtoEmployee</span><span class="params">(EmployeeDTO dto)</span></span>;</span><br></pre></td></tr></table></figure><p><strong><em>@Mappping的注解我们还可以定义一些属性</em></strong>，defaultExpression和expression可以定义一些简单的表达式，直接传递给实现方法，<strong>但是不可能引用一些工具类，只要import的方法都没办法自动导入，这个比较鸡肋</strong>。这里贴一些简单的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个会将java.util.UUID.randomUUID().toString()这个方法直接引用在目标字段上。</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonMapper</span> </span>&#123;</span><br><span class="line">    PersonMapper INSTANCE = Mappers.getMapper(PersonMapper.class);</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Mapping</span>(target = <span class="string">"id"</span>, source = <span class="string">"person.id"</span>, </span><br><span class="line">      defaultExpression = <span class="string">"java(java.util.UUID.randomUUID().toString())"</span>)</span><br><span class="line">    <span class="function">PersonDTO <span class="title">personToPersonDTO</span><span class="params">(Person person)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时我们可能也可以这样用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span>(componentModel = <span class="string">"spring"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeMapper</span> </span>&#123;</span><br><span class="line">    EmployeeMapper INSTANCE= Mappers.getMapper(EmployeeMapper.class);</span><br><span class="line">    <span class="meta">@Mappings</span>(&#123;</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"employeeId"</span>, source=<span class="string">"entity.id"</span>),</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"employeeName"</span>, source=<span class="string">"entity.name"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(target = <span class="string">"testString"</span>,expression = <span class="string">"java((priceFen/100) + \"元\")"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">EmployeeDTO <span class="title">employeeToEmployeeDTO</span><span class="params">(Employee entity,Long priceFen)</span></span>;</span><br><span class="line">    <span class="meta">@Mappings</span>(&#123;</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"id"</span>, source=<span class="string">"dto.employeeId"</span>),</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"name"</span>, source=<span class="string">"dto.employeeName"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">Employee <span class="title">employeeDTOtoEmployee</span><span class="params">(EmployeeDTO dto)</span></span>;</span><br><span class="line">    <span class="meta">@Mappings</span>(&#123;</span><br><span class="line">            <span class="meta">@Mapping</span>(target = <span class="string">"idDTO"</span>,source = <span class="string">"division.id"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(target = <span class="string">"nameDTO"</span>,source = <span class="string">"division.name"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">DivisionDTO <span class="title">divisionToDivisionDTO</span><span class="params">(Division division)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个感觉还是比较鸡肋的，如果可以支持比较复杂的一些转换实际场景可能更受用。</p><h3 id="进行复杂转换"><a href="#进行复杂转换" class="headerlink" title="进行复杂转换"></a>进行复杂转换</h3><p>主要在实际的应用场景中，需要输入转换的参数可能是多个，同时我们还需要一些自定义的部分，通过加<strong><em>@BeforeMapping等注解</em></strong>可以将自定义的部分嵌入到实现类中，这里也可以支持lambok，有些版本可能会报错，maven的版本需要在3.6.0以上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个POJOs</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionDTO</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String uuid;</span><br><span class="line">    <span class="keyword">private</span> Long totalInCents;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// standard getters and setters</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String uuid = UUID.randomUUID().toString();</span><br><span class="line">    <span class="keyword">private</span> BigDecimal total;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//standard getters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要定义为抽象类，这里的寓意是限制性第一个方法，在执行第二个方法，第一个方法中可以加一些复杂的参数转换，第二个方法做一些通用的处理，同时需要使用<strong><em>@MappingTarget</em></strong>注解保证输出对象的唯一引用，不加默认会帮你重新new一个出来并且return：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span>(componentModel = <span class="string">"spring"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@BeforeMapping</span>()</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toTransactionDTO</span><span class="params">(Transaction transaction,@MappingTarget TransactionDTO transactionDTO)</span> </span>&#123;</span><br><span class="line">        transactionDTO.setTotalInCents(transaction.getTotal()</span><br><span class="line">          .multiply(<span class="keyword">new</span> BigDecimal(<span class="string">"100"</span>)).longValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Mapping</span>(source = <span class="string">"transaction.uuid"</span>,target = <span class="string">"uuid"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">transactionToTransactionDTO</span><span class="params">(Transaction transaction , @MappingTarget TransactionDTO transactionDTO)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里为什么要介绍MapStruct这个工具包，实际上在我们的项目中确实有太多的拷贝动作，导致了方法都是在set，get方法过长，较难进行维护，非常不清晰。之后可以尝试通过MapStruct改造一些有类似问题的接口，通过定义一个抽象类的Mapper，将复杂操作维护一个自定义方法，简单的映射直接通过@Mapping，开发者只需要关心对应的抽象接口定义。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在实际开发过程中会出现很多bean之间的拷贝动作，这样的动作需要不停的去进行set操作。容易造成代码的耦合和维护困难。通过MapStruct我们只需要定义一个接口，这个工具包会帮我们自动生成一个实现类，并且这个类是不可编辑的，代码自动生成帮我们省去了开发维护成本同时做了
      
    
    </summary>
    
    
      <category term="大搜车的点滴记录" scheme="http://jianghao.wang/tags/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%9A%84%E7%82%B9%E6%BB%B4%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal介绍</title>
    <link href="http://jianghao.wang/2019/ThreadLocal%E4%BB%8B%E7%BB%8D/"/>
    <id>http://jianghao.wang/2019/ThreadLocal介绍/</id>
    <published>2019-04-12T03:11:54.515Z</published>
    <updated>2019-05-06T01:39:27.012Z</updated>
    
    <content type="html"><![CDATA[<p>ThreadLocal变量可以理解为线程内部私有的共享变量。在Java的内存模型中每个线程拥有自己的工作线程，这个变量是一个map结构的专门用于线程私有变量的存储，方便于解耦+防止并发。StackOverFlow上有段解释较为通俗。<strong><em>When and how can we use ThreadLocal variable?</em></strong>：</p><ul><li><strong>When an object is not thread-safe, instead of synchronization</strong> which hampers the scalability, give one object to every thread and keep it thread scope, which is ThreadLocal. One of most often used but not thread-safe objects are database Connection and JMSConnection.</li><li>One example is <strong>Spring framework uses ThreadLocal heavily for managing transactions behind the scenes by keeping these connection objects in ThreadLocal variables</strong>. At high level, when a transaction is started it gets the connection ( and disables the auto commit ) and keeps it in ThreadLocal. on further db calls it uses same connection to communicate with db. At the end, it takes the connection from ThreadLocal and commits ( or rollback ) the transaction and releases the connection.I think <strong>log4j also uses ThreadLocal for maintaining MDC</strong>.</li></ul><p>通常线程池这种并发的资源模型会面临多线程竞争，可以将线程的每个连接初始化到每个线程中避免竞争。这时候会将这个连接放置到ThreadLocal变量中。</p><h3 id="ThreadLocal-API"><a href="#ThreadLocal-API" class="headerlink" title="ThreadLocal API"></a>ThreadLocal API</h3><p>ThreadLocal变量实际上是以当前线程为key，可以指定一个value的map对象，只能容放一个kv键值对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.study.TreadLocal;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.ThreadLocal变量一般定义为private static。</span></span><br><span class="line"><span class="comment"> * 2.可以通过无参构造函数初始化or函数式初始化。</span></span><br><span class="line"><span class="comment"> * 3.ThreadLocal以当前线程为key，value可以指定类型，只能存储一个值。</span></span><br><span class="line"><span class="comment"> * 4.ThreadLocal初始化之后的值不能被remove掉。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//类加载的时候直接初始化，并且初始值不会被remove</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal=ThreadLocal.withInitial(()-&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//类加载的时候未被初始化，只提供无参构造函数，只有默认值null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal1=<span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"get有初始化ThreadLocal："</span>+threadLocal.get());</span><br><span class="line">        threadLocal.remove();</span><br><span class="line">        System.out.println(<span class="string">"remove初始化的ThreadLocal："</span>+threadLocal.get());</span><br><span class="line"></span><br><span class="line">        threadLocal.set(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"get重新赋值的ThreadLocal："</span>+threadLocal.get());</span><br><span class="line"></span><br><span class="line">        threadLocal.remove();</span><br><span class="line">        System.out.println(<span class="string">"remove重新赋值的ThreadLocal："</span>+threadLocal.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//threadLocal1</span></span><br><span class="line">        System.out.println(<span class="string">"get无初始化ThreadLocal1："</span>+threadLocal1.get());</span><br><span class="line">        threadLocal1.set(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"get重新赋值的ThreadLocal1："</span>+threadLocal1.get());</span><br><span class="line"></span><br><span class="line">        threadLocal1.remove();</span><br><span class="line">        System.out.println(<span class="string">"remove重新赋值的ThreadLocal1："</span>+threadLocal1.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">get初始化ThreadLocal：<span class="number">1</span></span><br><span class="line">remove初始化的ThreadLocal：<span class="number">1</span></span><br><span class="line">get重新赋值的ThreadLocal：<span class="number">2</span></span><br><span class="line">remove重新赋值的ThreadLocal：<span class="number">1</span></span><br><span class="line">get初始化ThreadLocal1：<span class="keyword">null</span></span><br><span class="line">get重新赋值的ThreadLocal1：<span class="number">2</span></span><br><span class="line">remove重新赋值的ThreadLocal1：<span class="keyword">null</span></span><br></pre></td></tr></table></figure><h3 id="Storing-User-Data-in-a-Map"><a href="#Storing-User-Data-in-a-Map" class="headerlink" title="Storing User Data in a Map"></a>Storing User Data in a Map</h3><p>我们假定每个线程都需要存储它的登录信息，这里给定一个用户信息类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们要实现每个userId对应一个context就需要将这个userId作为key存储在map中，同时需要时concurrentHashMap满足多线程并发的线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedMapWithUserContext</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Integer, Context&gt; userContextPerUserId</span><br><span class="line">      = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository = <span class="keyword">new</span> UserRepository();</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String userName = userRepository.getUserNameForUserId(userId);</span><br><span class="line">        userContextPerUserId.put(userId, <span class="keyword">new</span> Context(userName));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// standard constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们通过测试类去测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SharedMapWithUserContext firstUser = <span class="keyword">new</span> SharedMapWithUserContext(<span class="number">1</span>);</span><br><span class="line">SharedMapWithUserContext secondUser = <span class="keyword">new</span> SharedMapWithUserContext(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(firstUser).start();</span><br><span class="line"><span class="keyword">new</span> Thread(secondUser).start();</span><br><span class="line"> </span><br><span class="line">assertEquals(SharedMapWithUserContext.userContextPerUserId.size(), <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>这种方式也是可以的，相对来说需要去做一个线程安全的东西成本比较大。</p><h3 id="Storing-User-Data-in-ThreadLocal"><a href="#Storing-User-Data-in-ThreadLocal" class="headerlink" title="Storing User Data in ThreadLocal"></a>Storing User Data in ThreadLocal</h3><p>向上面这种情况我们可以将这个context存在每个线程自有的ThreadLocal变量中，不用考虑线程安全的问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalWithUserContext</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Context&gt; userContext </span><br><span class="line">      = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository = <span class="keyword">new</span> UserRepository();</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String userName = userRepository.getUserNameForUserId(userId);</span><br><span class="line">        userContext.set(<span class="keyword">new</span> Context(userName));</span><br><span class="line">        System.out.println(<span class="string">"thread context for given userId: "</span></span><br><span class="line">          + userId + <span class="string">" is: "</span> + userContext.get());</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// standard constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，我们可以进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalWithUserContext firstUser </span><br><span class="line">  = <span class="keyword">new</span> ThreadLocalWithUserContext(<span class="number">1</span>);</span><br><span class="line">ThreadLocalWithUserContext secondUser </span><br><span class="line">  = <span class="keyword">new</span> ThreadLocalWithUserContext(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(firstUser).start();</span><br><span class="line"><span class="keyword">new</span> Thread(secondUser).start();</span><br></pre></td></tr></table></figure><p>可以得到一个结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread context <span class="keyword">for</span> given userId: <span class="number">1</span> is: Context&#123;userNameSecret=<span class="string">'18a78f8e-24d2-4abf-91d6-79eaa198123f'</span>&#125;</span><br><span class="line">thread context <span class="keyword">for</span> given userId: <span class="number">2</span> is: Context&#123;userNameSecret=<span class="string">'e19f6a0a-253e-423e-8b2b-bca1f471ae5c'</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal如何实现"><a href="#ThreadLocal如何实现" class="headerlink" title="ThreadLocal如何实现"></a>ThreadLocal如何实现</h3><p>很多blog都介绍了ThreadLocal主要作用是解耦+防止并发。实际上我自己将其理解为一个<strong><em>全局map变量，全局变量的存在减少了不必要的参数传递，也就是解耦</em></strong>，这个全局变量我们一般通过定义变量为private static实现，需要通过类直接访问可以定义为public static。通过<strong><em>维护当前线程id作为map的key，保证了只有当前key的value对当前线程可见，其他线程无法访问到这个value的资源</em></strong>，那么这个value便可以理解为线程的私有资源，实际上这些对象都还是放在堆中，只不过用key标示了每个资源的归属 ，也就是每个工作线程都有自己的私有空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the current thread's copy of this thread-local variable</span></span><br><span class="line"><span class="comment">     * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment">     * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment">     * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</span></span><br><span class="line"><span class="comment">     *        this thread-local.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一般我们的框架在处理了登录之后，例如单点登录，一个请求进入到tomcat，分配线程资源，进入到后台，通过拦截器分发的对应的sso服务。服务返回登录信息，这个时候会<strong><em>写一个ThreadLocal变量（AuthNHolder）以当前线程id为key，保存用户信息到value里面</em></strong>，之后线程在任何地方想获取这个用户信息可以直接从ThreadLocal中拿到，<strong><em>线程请求完成之后回到拦截器会将这个value清空</em></strong>。这里应该可以体会到解耦+防止并发。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实我们在使用这个变量的时候，通常也要防止在线程池的情况下，可能会导致某一个线程同时消费很多任务，如果在一个任务结束之后没有将线程的工作空间进行清除，那么这个工作空间会存储两个任务的信息，这可能会产生问题。我们可以通过登录保存用户信息这个案例更好的了解ThreadLocal的应用。<strong><em>详细可以参考optimus中AuthHolder的实现</em></strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ThreadLocal变量可以理解为线程内部私有的共享变量。在Java的内存模型中每个线程拥有自己的工作线程，这个变量是一个map结构的专门用于线程私有变量的存储，方便于解耦+防止并发。StackOverFlow上有段解释较为通俗。&lt;strong&gt;&lt;em&gt;When and 
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>杭城四少面试题</title>
    <link href="http://jianghao.wang/2019/%E6%9D%AD%E5%9F%8E%E5%9B%9B%E5%B0%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://jianghao.wang/2019/杭城四少面试题/</id>
    <published>2019-04-08T14:30:53.864Z</published>
    <updated>2019-04-08T14:42:43.405Z</updated>
    
    <content type="html"><![CDATA[<h3 id="江董"><a href="#江董" class="headerlink" title="江董"></a>江董</h3><p>江董上海面试题，30分钟写不出，现场代码至少一个小时(实际情况肯定要结合测试用例)，这里实现一个O(N)的版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有两个字符串，开始字符串：startStr，结束字符串：endStr。</span></span><br><span class="line"><span class="comment"> * startStr=LRXRLLXR</span></span><br><span class="line"><span class="comment"> * endStr=XRRLXXLR</span></span><br><span class="line"><span class="comment"> * LR可转换成RL</span></span><br><span class="line"><span class="comment"> * RX可转换成XR</span></span><br><span class="line"><span class="comment"> * 实现一个方法，判断startStr是否可转换成endStr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*ThreadPoolExecutor executor =</span></span><br><span class="line"><span class="comment">                (ThreadPoolExecutor) Executors.newFixedThreadPool(5);</span></span><br><span class="line"><span class="comment">        ExecutorService executorService =</span></span><br><span class="line"><span class="comment">                MoreExecutors.getExitingExecutorService(executor,</span></span><br><span class="line"><span class="comment">                        10000, TimeUnit.MILLISECONDS);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        executorService.submit(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">            while (true) &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(1);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//start from here</span></span><br><span class="line">        StringEqual stringEqualA = <span class="keyword">new</span> StringEqual(<span class="string">"LRRXX"</span>);</span><br><span class="line">        StringEqual stringEqualB = <span class="keyword">new</span> StringEqual(<span class="string">"RRLXR"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(stringEqualA.equals(stringEqualB));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringEqual</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringEqual</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.string = string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        StringEqual stringEqualB = (StringEqual) obj;</span><br><span class="line">        <span class="keyword">char</span>[] charsA = string.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] charsB = stringEqualB.string.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charsB.length; i++) &#123;</span><br><span class="line">            <span class="comment">//如果不想等&amp;&amp;未到末尾字符，尝试走转换器</span></span><br><span class="line">            <span class="keyword">if</span> ((charsA[i] != charsB[i]) &amp;&amp; (i &lt; (charsB.length - <span class="number">1</span>))) &#123;</span><br><span class="line">                String a = <span class="keyword">new</span> Character(charsA[i]).toString() +</span><br><span class="line">                    <span class="keyword">new</span> Character(charsA[i + <span class="number">1</span>]).toString();</span><br><span class="line">                String b = <span class="keyword">new</span> Character(charsB[i]).toString() +</span><br><span class="line">                    <span class="keyword">new</span> Character(charsB[i + <span class="number">1</span>]).toString();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (defineEquals(a, b, charsA, charsB, i)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//print一下pop的结果 转换器无法进行转换</span></span><br><span class="line">                    System.out.println(charsA);</span><br><span class="line">                    System.out.println(charsB);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == (charsB.length - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//print一下最终的结果，最后一个字符特殊处理不用往后走转换器</span></span><br><span class="line">                System.out.println(charsA);</span><br><span class="line">                System.out.println(charsB);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> charsB[i] == charsA[i];</span><br><span class="line">            &#125; <span class="comment">//相等继续往下走</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//print一下最终的转换结果</span></span><br><span class="line">        System.out.println(charsA);</span><br><span class="line">        System.out.println(charsB);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义规则（自定义一个转换器）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">defineEquals</span><span class="params">(String a, String b, <span class="keyword">char</span>[] charsA,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">char</span>[] charsB, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//两字符串在TR组合中</span></span><br><span class="line">        <span class="keyword">if</span> (a.equals(<span class="string">"LR"</span>) &amp;&amp; b.startsWith(<span class="string">"R"</span>)) &#123;</span><br><span class="line">            charsA[index] = <span class="string">'R'</span>;</span><br><span class="line">            charsA[index + <span class="number">1</span>] = <span class="string">'L'</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.startsWith(<span class="string">"R"</span>) &amp;&amp; b.equals(<span class="string">"LR"</span>)) &#123;</span><br><span class="line">            charsB[index] = <span class="string">'R'</span>;</span><br><span class="line">            charsB[index + <span class="number">1</span>] = <span class="string">'L'</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="comment">//两字符串在RX组合中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a.equals(<span class="string">"RX"</span>) &amp;&amp; b.startsWith(<span class="string">"X"</span>)) &#123;</span><br><span class="line">            charsA[index] = <span class="string">'X'</span>;</span><br><span class="line">            charsA[index + <span class="number">1</span>] = <span class="string">'R'</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.startsWith(<span class="string">"X"</span>) &amp;&amp; b.equals(<span class="string">"RX"</span>)) &#123;</span><br><span class="line">            charsB[index] = <span class="string">'X'</span>;</span><br><span class="line">            charsB[index + <span class="number">1</span>] = <span class="string">'R'</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="坤宝"><a href="#坤宝" class="headerlink" title="坤宝"></a>坤宝</h3><p><strong>题目：一个字符串含有空格，求非空格最长子串长度，要求时间和空间最优。例如：”aa aa aaaa aaa a a a aa aa a”；</strong></p><p>想不出更好的，直接放弃。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;江董&quot;&gt;&lt;a href=&quot;#江董&quot; class=&quot;headerlink&quot; title=&quot;江董&quot;&gt;&lt;/a&gt;江董&lt;/h3&gt;&lt;p&gt;江董上海面试题，30分钟写不出，现场代码至少一个小时(实际情况肯定要结合测试用例)，这里实现一个O(N)的版本。&lt;/p&gt;
&lt;figure c
      
    
    </summary>
    
    
      <category term="面试记录" scheme="http://jianghao.wang/tags/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池介绍</title>
    <link href="http://jianghao.wang/2019/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%8B%E7%BB%8D/"/>
    <id>http://jianghao.wang/2019/Java线程池介绍/</id>
    <published>2019-04-02T03:12:54.652Z</published>
    <updated>2019-04-30T12:08:14.333Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池主要用于管理线程资源，在Java中，线程资源映射到操作系统层面，占用的是操作提供层面的资源。如果不进行良好的管理，可能会快速耗尽系统的线程资源。你可以编写多线程并行的代码，将任务提交给线程池的实例执行。线程池会管理线程的生命周期，以及会将任务维护在一个内部的队列中，完成任务的调度。</p><p><img src="https://arthornye.github.io/images/threadpool.png" alt="cmd-markdown-logo"></p><h3 id="Java中的线程池"><a href="#Java中的线程池" class="headerlink" title="Java中的线程池"></a>Java中的线程池</h3><h4 id="Executor-Executors-ExecutorService"><a href="#Executor-Executors-ExecutorService" class="headerlink" title="Executor+Executors+ExecutorService"></a>Executor+Executors+ExecutorService</h4><p>我们通常会用到这几个类，其中<strong><em>Executors</em></strong>这个类可以获取到很多初始化的线程池实例，这些实例拥有不同的预配置。如果你不需要自定义一个线程池，这个类的使用会非常方便。</p><p><strong><em>Executor和ExecutorService</em></strong>提供了一些接口方法可以让开发者自定义去实现，通过这种方式将提交任务也就是上图中的左边部分和线程池的具体实现分离开来。这里我们通过一段代码查看如果通过<strong><em>Executors</em></strong>这个线程池工具类获取一个<strong><em>Executor</em></strong>实例，然后通过这个实力去提交一个task：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Executor executor = Executors.newSingleThreadExecutor();</span><br><span class="line">executor.execute(() -&gt; System.out.println(<span class="string">"Hello World"</span>));</span><br></pre></td></tr></table></figure><p><strong><em>Executor</em></strong>提供的方法较为简单，我们可以利用<strong><em>ExecutorService</em></strong>的一些更为丰富的api去开发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">Future&lt;String&gt; future = executorService.submit(() -&gt; <span class="string">"Hello World"</span>);</span><br><span class="line"><span class="comment">// some operations</span></span><br><span class="line">String result = future.get();</span><br></pre></td></tr></table></figure><p>我们可以通过返回的Feature来等待这个异步线程任务完成。这里延伸出Java8中CompletableFeature,这个类提供的异步操作api更为丰富之后可以对比介绍，同时可以深入了解<strong><em>ExecutorService</em></strong>。</p><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p><strong><em>ThreadPoolExecutor</em></strong>是一种可扩展的提供很多参数调整的线程池，这里主要介绍几个参数，<strong><em>corePoolSize(核心线程数)，maximumPoolSize(最大线程数)，keepAliveTime(超出线程生命周期)</em></strong>。队列类型留到下次进行补充。</p><p><strong><em>corePoolSize</em></strong>是线程池的核心线程数，会从队列中不断拉取任务进行执行，如果队列中有任务到来会new一个核心线程进行执行，同时如果执行队列执行完了，对应的核心线程也不会进行回收。当我们通过submit提交任务时，会首先往任务队列里面追加，直到超出队列的大小之后，会创建新的线程进行执行。<strong><em>maximumPoolSize</em></strong>指定了当任务队列存满时，可以独立创建的最大线程数，下面的例子任务队列长度为3，最大线程数为10，所以当线程数量超过5时，会生成新的线程。另外当额外需要的线程超过<strong><em>maximumPoolSize-corePoolSize</em></strong>时，那么会队列会抛出<strong><em>RejectedExecutionHandler</em></strong>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor executor=<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">10</span>, <span class="number">0</span>,</span><br><span class="line">                TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">13</span>;i++)&#123;</span><br><span class="line">            executor.submit(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"当前线程池核心线程数:"</span>+executor.getCorePoolSize());</span><br><span class="line">        System.out.println(<span class="string">"当前线程池最大线程数"</span> + executor.getMaximumPoolSize());</span><br><span class="line">        System.out.println(<span class="string">"当前线程池工作线程数："</span>+executor.getPoolSize());</span><br><span class="line">        System.out.println(<span class="string">"当前线程池队列中等待的任务数："</span>+executor.getQueue().size());</span><br><span class="line"><span class="comment">//再添加一个任务，抛出异常</span></span><br><span class="line">        executor.submit(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我定义了14个任务，并且每个任务都休眠10s，首先会被<strong>核心线程参数拿走2个任务</strong>，然后往<strong>LinkedBlockingDeque追加3个任务</strong>，然后<strong>最大线程参数独立生成8个线程</strong>，总共消化了13个线程，最后一个线程被队列拒绝，抛出异常，这段代码的执行结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">当前线程池核心线程数:2</span><br><span class="line">当前线程池最大线程数10</span><br><span class="line">当前线程池工作线程数：10</span><br><span class="line">当前线程池队列中等待的任务数：3</span><br><span class="line"></span><br><span class="line">Exception in thread "main" java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@3d494fbf rejected from java.util.concurrent.ThreadPoolExecutor@1ddc4ec2[Running, pool size = 10, active threads = 10, queued tasks = 3, completed tasks = 0]</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor<span class="formula">$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047)</span></span><br><span class="line"><span class="formula">at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823)</span></span><br><span class="line"><span class="formula">at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369)</span></span><br><span class="line"><span class="formula">at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:112)</span></span><br><span class="line"><span class="formula">at com.souche.TreadPoolExecutorTest.main(TreadPoolExecutorTest.java:26)</span></span><br></pre></td></tr></table></figure><p>其中Executors类提供了两种默认可以获取ThreadExecutorPool实例的方法，可以看下一些默认的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**只传入一个参数线程数</span></span><br><span class="line"><span class="comment"> * corePoolSize === maximumPoolSize</span></span><br><span class="line"><span class="comment"> * keepAliveTime === 0</span></span><br><span class="line"><span class="comment"> * LinkedBlockingDeque === 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**不传入参数</span></span><br><span class="line"><span class="comment"> * corePoolSize === 0</span></span><br><span class="line"><span class="comment"> * maxmumPoolSize === Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment"> * keepAliveTime === 60s</span></span><br><span class="line"><span class="comment"> * SynchronousQueue === 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ExecutorService executorService1 = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**不传参数</span></span><br><span class="line"><span class="comment"> * 不能被转换为ThreadExecutorPool类型</span></span><br><span class="line"><span class="comment"> * corePoolSize === maximumPoolSize === 1</span></span><br><span class="line"><span class="comment"> * keepAliveTime === 0s</span></span><br><span class="line"><span class="comment"> * LinkedBlockingDeque === 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ExecutorService executorService2=Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure><p>缓存的线程池也就是第二种，其实就是为了<strong>支持线程无限量的增长，以适应无限数量任务的添加</strong>。当时他们会被回收当空闲的时间超过了60s，这种线程池的一种很明显的应用场景就是<strong>有很多短期的任务</strong>。第三种<strong>单线程池实际上更加适合做事件的循环</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger counter = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"> </span><br><span class="line">ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    counter.set(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    counter.compareAndSet(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里补充一下<strong><em>队列类型queueWork</em></strong>吧，看了下源码中的注释，搬运一下：</p><ul><li><strong>SynchronousQueue直传队列</strong>。中间不允许任何task缓存，所有的任务直接提交给核心线程，核心线程不够直接交给最大线程新起线程。通常直传队列需要无限的最大线程大小。因为每个任务过来都需要直接被线程消费。<strong><em>可能导致新线程不断增长超出系统负荷</em></strong>。</li><li><strong>LinkedBlockingQueue无界队列</strong>。这个队列如果不指定队列大小，将会容纳无限制的task任务，那么实际上最大线程数的参数便没有效果了，keepAlive时间也没有必要，因为不会有新的线程被开辟。这种情况可能适用于请求某一瞬间爆发，相当于消息队列缓存，但是也有可能太多完全处理不过来。<strong><em>可能导致队列无限增长超出内存负荷</em></strong>。</li><li><strong>ArrayBlockingQueue有界队列</strong>。这个队列可以指定大小，<strong><em>防止资源耗尽的情况</em></strong>，队列大小和最大池大小之间应该有一种平衡。使用大队列小池可以最小化cpu使用，os资源以及上下文切换，使用小队列大池可能导致cpu过于繁忙。</li></ul><p>通过Executors.newCachedThreadPool()获取的线程池就是通过SynchronousQueue直传队列，零队列无限池，通常适用于很多的短期任务。通过Executors.newFixedThreadPool()获取的线程池是LinkedBlockingQueue无界队列，也就是零最大池无限队列，只能指定核心线程数，也可以通过Executors.newSingleThreadPool()获取到无界队列，但是只有一个消费者线程，而且不能被强制转换为ThreadPoolExecutor类型。</p><h4 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h4><p><strong><em>Executors.newScheduledThreadPool</em></strong>可以获取到一个<strong><em>ScheduledThreadPoolExecutor</em></strong>继承了<strong><em>ThreadPoolExecutor</em></strong>实现了<strong><em>ScheduledExecutorService</em></strong>接口，提供了一些控制调用时间的方法：</p><ul><li><em>schedule</em> 方法允许在指定的延迟后执行一次任务。</li><li>scheduleAtFixedRate方法允许在指定的初始延迟后执行任务，然后在一定时间内重复执行。period参数是在<strong>开始时间之后的每个任务的间隔时间</strong>。所以执行速率是固定的。</li><li>scheduleWithFixedDelay方法类似于scheduleAtFixedRate，因为它重复执行给定的任务。但是<strong>执行速率可能会有所不同</strong>，具体取决于执行任何给定任务所需的时间。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">executor.schedule(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">&#125;, <span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><p>上面初始化了一个核心线程为5，最大线程为5，并且超出线程生命周期为0s的线程池，等待500ms之后执行任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch lock = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">ScheduledFuture&lt;?&gt; future = executor.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    lock.countDown();</span><br><span class="line">&#125;, <span class="number">500</span>, <span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"> </span><br><span class="line">lock.await(<span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">future.cancel(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>上面等待500ms后开始执行任务，并且没100ms执行一次任务，知道所有的任务都执行完成，再执行主线程。</p><p><strong><em>注意点：维护了等待队列会出现线程复用的情况，如果是直传队列也会出现线程复用的情况。</em></strong></p><h4 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h4><p>主要用于在递归算法（分治）中，多个子任务可能产生过多的线程，造成系统资源耗尽，fork / join框架的好处是它不会为每个任务或子任务创建一个新线程。这里贴一个简单的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Set&lt;TreeNode&gt; children;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> value, TreeNode... children) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.children = Sets.newHashSet(children);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeNode node;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountingTask</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.node = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.value + node.children.stream()</span><br><span class="line">          .map(childNode -&gt; <span class="keyword">new</span> CountingTask(childNode).fork())</span><br><span class="line">          .collect(Collectors.summingInt(ForkJoinTask::join));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeNode tree = <span class="keyword">new</span> TreeNode(<span class="number">5</span>,</span><br><span class="line">  <span class="keyword">new</span> TreeNode(<span class="number">3</span>), <span class="keyword">new</span> TreeNode(<span class="number">2</span>,</span><br><span class="line">    <span class="keyword">new</span> TreeNode(<span class="number">2</span>), <span class="keyword">new</span> TreeNode(<span class="number">8</span>)));</span><br><span class="line"> </span><br><span class="line">ForkJoinPool forkJoinPool = ForkJoinPool.commonPool();</span><br><span class="line"><span class="keyword">int</span> sum = forkJoinPool.invoke(<span class="keyword">new</span> CountingTask(tree));</span><br></pre></td></tr></table></figure><h3 id="Guava中的线程池实现"><a href="#Guava中的线程池实现" class="headerlink" title="Guava中的线程池实现"></a>Guava中的线程池实现</h3><p>Guava是一个受欢迎的Google公用类库。它有许多有用的并发类，包括几个方便的ExecutorService实现。它提供了一个<strong><em>MoreExecutors</em></strong>这个工具类去获取它实现的一些线程池实例。我们可以添加Guava的maven依赖：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;19.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="Direct-Executor-and-Direct-Executor-Service"><a href="#Direct-Executor-and-Direct-Executor-Service" class="headerlink" title="Direct Executor and Direct Executor Service"></a>Direct Executor and Direct Executor Service</h4><p>通常我们有些情况需要当前的线程去等待另一线程执行完之后再继续执行。我们可以通过countLatchDown的方式去控制，但是还是需要自己去写代码，Guava为我们提供了线程的工具：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche;</span><br><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.MoreExecutors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> junit.framework.TestCase.assertTrue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Executor executor = MoreExecutors.directExecutor();</span><br><span class="line">        AtomicBoolean executed = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            executed.set(<span class="keyword">true</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(executed.get());</span><br><span class="line">        assertTrue(executed.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，当前的主线程会等待线程池中的线程完成之后再继续执行主线程。</p><h3 id="Runnable和Callable的区别"><a href="#Runnable和Callable的区别" class="headerlink" title="Runnable和Callable的区别"></a>Runnable和Callable的区别</h3><p>从api上看一个Runnable没有返回值，Callable定义了返回值，主要区别一个能在Future的get方法中捕获到异常和获取结果信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A task that returns a result and may throw an exception.</span></span><br><span class="line"><span class="comment"> * Implementors define a single method with no arguments called</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> call&#125;.</span></span><br><span class="line"><span class="comment"> * Callable接口跟Runnable接口非常相似，都是可以被实现并且启动一个线程。但是Runnable</span></span><br><span class="line"><span class="comment"> * 不能获得线程的执行结果也不能捕获线程的异常。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The &#123;<span class="doctag">@code</span> Callable&#125; interface is similar to &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * java.lang.Runnable&#125;, in that both are designed for classes whose</span></span><br><span class="line"><span class="comment"> * instances are potentially executed by another thread.  A</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Runnable&#125;, however, does not return a result and cannot</span></span><br><span class="line"><span class="comment"> * throw a checked exception.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The &#123;<span class="doctag">@link</span> Executors&#125; class contains utility methods to</span></span><br><span class="line"><span class="comment"> * convert from other common forms to &#123;<span class="doctag">@code</span> Callable&#125; classes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Executor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; the result type of method &#123;<span class="doctag">@code</span> call&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><div contenteditable="plaintext-only"><table></table></div></p><tr><br>    <th>方法名</th><br>    <th>Runnable</th><br>    <th>Callable</th><br></tr><br><tr><br>    <th>ExecutorService的执行方法 </th><br>    <th>execute和submit</th><br>    <th>只能是submit</th><br></tr><br><tr><br>    <th>ExecutorService.submit()返回值</th><br>    <th>Future</th><br>    <th>Future</th><br></tr><br><tr><br>    <th>返回的Future调用get()方法</th><br>    <th>null</th><br>    <th>Future定义的泛型，可捕获异常</th><br></tr><br><tr><br>    <th>取消执行</th><br>    <th>不能</th><br>    <th>Future.cancel可以取消执行</th><br></tr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本文中，我们讨论了线程池模式及其在标准Java库和Google的Guava库中的实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h3&gt;&lt;p&gt;线程池主要用于管理线程资源，在Java中，线程资源映射到操作系统层面，占用的是操作提供层面的资源。如果不进行良好的管理，可能会快速耗
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Spring事件监听机制和状态机</title>
    <link href="http://jianghao.wang/2019/Spring%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6%E5%92%8C%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    <id>http://jianghao.wang/2019/Spring事件监听机制和状态机/</id>
    <published>2019-04-01T06:17:24.630Z</published>
    <updated>2019-04-09T04:59:21.897Z</updated>
    
    <content type="html"><![CDATA[<p>Spring事件监听机制和Spring StateMachine都是基于观察者模式实现的，帮助业务代码进行解耦合。</p><h4 id="Spring事件监听实现"><a href="#Spring事件监听实现" class="headerlink" title="Spring事件监听实现"></a>Spring事件监听实现</h4><p>Spring可以帮助开发者自己实现事件监听，开发者通过实现<strong><em>ApplicationListener（观察者Observer）</em></strong>接口定义一个监听器，同时通过实现<strong><em>ApplicationEvent（主题Subject）</em></strong>接口定义一个事件。实现<strong><em>ApplicationContextAware（发布器）</em></strong>通过发布器发布时间到ApplicationContext中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.observer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationEvent;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个事件（主题 subject）</span></span><br><span class="line"><span class="comment"> * define an event</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTestEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getSource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建另一个事件监听器</span></span><br><span class="line"><span class="comment"> * 对于继承了 ApplicationEvent的事件所有入参对应的监听器都会监听到，执行onApplicationEvent方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"myTestApplictionListener"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MyTestEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyTestEvent applicationEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(applicationEvent.getClass());</span><br><span class="line">        <span class="keyword">if</span>(applicationEvent <span class="keyword">instanceof</span> MyTestEvent)&#123;</span><br><span class="line">            System.out.println(<span class="string">"get to MyTestApplicationListener..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个事件监听器（观察者 observer）</span></span><br><span class="line"><span class="comment"> * listener defination</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"myApplicationListener"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MyTestEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyTestEvent applicationEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(applicationEvent.getClass());</span><br><span class="line">        <span class="keyword">if</span>(applicationEvent <span class="keyword">instanceof</span>  MyTestEvent)&#123;</span><br><span class="line">            System.out.println(<span class="string">"get to MyApplicationListener"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationEvent;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个事件发布器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"myPublisher"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPubisher</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext=applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"into My Publisher's method to add event"</span>);</span><br><span class="line">        applicationContext.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ConfigurableApplicationContext configurableApplicationContext=SpringApplication.run(ObserverApplication.class, args);</span><br><span class="line">MyPubisher myPubisher=(MyPubisher) configurableApplicationContext.getBean(<span class="string">"myPublisher"</span>);</span><br><span class="line">myPubisher.publishEvent(<span class="keyword">new</span> MyTestEvent(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">into My Publisher<span class="string">'s method to add event</span></span><br><span class="line"><span class="string">class com.souche.observer.MyTestEvent</span></span><br><span class="line"><span class="string">get to MyApplicationListener</span></span><br><span class="line"><span class="string">class com.souche.observer.MyTestEvent</span></span><br><span class="line"><span class="string">get to MyTestApplicationListener...</span></span><br></pre></td></tr></table></figure><p><strong>可以通过@Order注解指定监听者的执行顺序。</strong>改善代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建另一个事件监听器</span></span><br><span class="line"><span class="comment"> * 对于继承了 ApplicationEvent的事件所有入参对应的监听器都会监听到，执行onApplicationEvent方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"myTestApplictionListener"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MyTestEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyTestEvent applicationEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(applicationEvent.getClass());</span><br><span class="line">        <span class="keyword">if</span>(applicationEvent <span class="keyword">instanceof</span> MyTestEvent)&#123;</span><br><span class="line">            System.out.println(<span class="string">"get to MyTestApplicationListener..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个事件监听器（观察者 observer）</span></span><br><span class="line"><span class="comment"> * listener defination</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">2</span>)</span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"myApplicationListener"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MyTestEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyTestEvent applicationEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(applicationEvent.getClass());</span><br><span class="line">        <span class="keyword">if</span>(applicationEvent <span class="keyword">instanceof</span>  MyTestEvent)&#123;</span><br><span class="line">            System.out.println(<span class="string">"get to MyApplicationListener"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">into My Publisher<span class="string">'s method to add event</span></span><br><span class="line"><span class="string">class com.souche.observer.MyTestEvent</span></span><br><span class="line"><span class="string">get to MyTestApplicationListener...</span></span><br><span class="line"><span class="string">class com.souche.observer.MyTestEvent</span></span><br><span class="line"><span class="string">get to MyApplicationListener</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring事件监听机制和Spring StateMachine都是基于观察者模式实现的，帮助业务代码进行解耦合。&lt;/p&gt;
&lt;h4 id=&quot;Spring事件监听实现&quot;&gt;&lt;a href=&quot;#Spring事件监听实现&quot; class=&quot;headerlink&quot; title=&quot;Spr
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://jianghao.wang/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>dubbo简单介绍</title>
    <link href="http://jianghao.wang/2019/%E4%BA%86%E8%A7%A3dubbo%E6%A8%A1%E5%9D%97/"/>
    <id>http://jianghao.wang/2019/了解dubbo模块/</id>
    <published>2019-03-25T05:54:57.696Z</published>
    <updated>2019-03-25T06:24:58.612Z</updated>
    
    <content type="html"><![CDATA[<h4 id="dubbo基本概念"><a href="#dubbo基本概念" class="headerlink" title="dubbo基本概念"></a>dubbo基本概念</h4><p>现代的分布式架构基本都是基于Remote Method Invocation（远程调用），通过interface暴露服务接口，客户端调用代理类实现远程通信，dubbo的分布式架构中主要有几个角色：</p><ul><li>1.服务提供者-服务启动时在指定的端口上暴露服务，并同步调用注册中心将服务的地址和端口注册到注册中心。</li><li>2.服务消费者-服务启动时从注册中心pull提供者暴露的服务，缓存到本地，并保持长连接监听注册中心的服务推送。</li><li>3.注册中心-提供者将服务暴露到zookeeper注册中心，负责保存服务提供方上报的地址信息，并向服务消费方推送。</li><li>4.监控中心-服务提供者和消费者异步更新调用信息到监控中心，监控中心监控服务的调用次数，延迟等参数。</li><li>5.运行容器-管理提供者暴露服务对象的加载，初始化以及生命周期。</li></ul><p><img src="http://arthornye.github.io/images/dubbo.png" alt="cmd-markdown-logo"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;dubbo基本概念&quot;&gt;&lt;a href=&quot;#dubbo基本概念&quot; class=&quot;headerlink&quot; title=&quot;dubbo基本概念&quot;&gt;&lt;/a&gt;dubbo基本概念&lt;/h4&gt;&lt;p&gt;现代的分布式架构基本都是基于Remote Method Invocation（远程调
      
    
    </summary>
    
    
      <category term="dubbo" scheme="http://jianghao.wang/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Redis缓存</title>
    <link href="http://jianghao.wang/2019/Redis%E7%BC%93%E5%AD%98/"/>
    <id>http://jianghao.wang/2019/Redis缓存/</id>
    <published>2019-03-05T03:28:29.309Z</published>
    <updated>2019-03-21T10:22:58.749Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Redis和Memcache的主要区别"><a href="#Redis和Memcache的主要区别" class="headerlink" title="Redis和Memcache的主要区别"></a>Redis和Memcache的主要区别</h4><ul><li>1.数据结构方面，Redis的key-value存储，value支持string，list，set，sorted set，hash等多种数据结构。Memcache只支持简单的数据类型value为string类型。</li><li>2.数据安全方面，Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而Memecache把数据全部存在内存之中。</li><li>3.Redis是非阻塞单线程IO复用模型，Memcache是非阻塞多线程IO复用模型。</li></ul><h4 id="Redis数据结构主要的使用场景"><a href="#Redis数据结构主要的使用场景" class="headerlink" title="Redis数据结构主要的使用场景"></a>Redis数据结构主要的使用场景</h4><ul><li>list，存储一个先入先出的value列表，一个<strong>Map&lt;String,List<object>&gt;</object></strong>结构，list先进先出，可以做类似队列这种结构，另外还可以提供无序的简单分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。</li><li>map,存储一个value kv列表，双层map结构<strong>Map&lt;String,Map&lt;String,List<object>&gt;&gt;</object></strong>结构，存储的结构较为丰富。</li><li>set，一个无序的去重value列表，不允许重复 ，<strong>Map&lt;String,Set<object>&gt;</object></strong>结构，可以在分布式系统下做交集，并集，差集等操作，比如可以看两个微博博主的共同粉丝，可以放在redis里面做。</li><li>sorted set，一个有序的去重value了列表，<strong>Map&lt;String,SortedSet<object>&gt;</object></strong>结构，根据object某个字段排序，也可以做有序的分页操作。</li></ul><h4 id="Redis的过期策略和内存淘汰机制"><a href="#Redis的过期策略和内存淘汰机制" class="headerlink" title="Redis的过期策略和内存淘汰机制"></a>Redis的过期策略和内存淘汰机制</h4><p><strong>Redis过期策略：</strong>定期删除+惰性删除</p><p>实际应用场景中，如果redis缓存中存在大量的数据，超过了过期时间之后，如果遍历每个key去判断过期时间删除，会造成cpu负载过大。redis采用<strong>定期删除+惰性删除</strong>过期策略，定期删除只是随机的扫描一些过期的k-v进行删除，惰性删除是指在redis中进行get某个key的时候，判断是否过期，如果过期了，直接删除，并且不返回给客户端返回任何内容。</p><ul><li>获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。</li></ul><p><strong>Redis内存淘汰机制：</strong></p><p>基于redis的定期删除和惰性删除的过期策略，删除的速度可能并没有redis缓存增加速度快，这个时候redis需要进行内存淘汰，基本基于LRU（最近最少使用原则），最近最少使用的数据被删除：</p><ul><li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在<strong>键空间</strong>中，移除最近最少使用的 key（这个是<strong>最常用</strong>的）。</li></ul><ul><li><strong>volatile-random：当内存不足以容纳新写入数据时，在</strong>设置了过期时间的键空间<strong>中，</strong>随机移除某个 key。</li></ul><p>可以基于LinkedHashMap实现一个最近最少使用原则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传递进来最多能缓存多少数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cacheSize 缓存大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> cacheSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// true 表示让 linkedHashMap 按照访问顺序来进行排序，最近访问的放在头部，最老访问的放在尾部。</span></span><br><span class="line">        <span class="keyword">super</span>((<span class="keyword">int</span>) Math.ceil(cacheSize / <span class="number">0.75</span>) + <span class="number">1</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        CACHE_SIZE = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当 map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据。</span></span><br><span class="line">        <span class="keyword">return</span> size() &gt; CACHE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>场景：对于某个系统，高峰时间有5000个请求，原本都可以打到缓存上，但是缓存意外宕机，这时所有的缓存查询打到数据库上，导致数据库雪崩。通常我们称之为<strong>缓存雪崩。</strong>缓存雪崩如何应对：</p><ul><li>事前：redis高可用，主从+哨兵，防止全盘崩溃。</li><li>事中：mysql限流+降级。</li><li>事后：redis数据持久化，宕机之后立即重启恢复数据。</li></ul><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>黑客恶意攻击，查询缓存key永远不命中，将大量请求打到数据库，通过每次缓存查询不到时，对当前查询的key增加一个空的值。</p><h4 id="缓存和数据库双写不一致"><a href="#缓存和数据库双写不一致" class="headerlink" title="缓存和数据库双写不一致"></a>缓存和数据库双写不一致</h4><p>缓存和数据库需要保持一致，否则引起脏读。数据库更新和缓存更新的先后顺序。</p><h4 id="为什么是删除缓存而不是更新缓存"><a href="#为什么是删除缓存而不是更新缓存" class="headerlink" title="为什么是删除缓存而不是更新缓存"></a>为什么是删除缓存而不是更新缓存</h4><p>更新缓存的动作可能非常频繁，但是缓存还是要以命中率为指标。可能更新动作频繁的数据实际上是一个读的冷数据，这样导致更新操作频繁浪费资源，可以用<strong>懒写的这种方式。</strong>也就是当你要更新缓存的时候，不更新，直接删除。读缓存命中失败之后从数据库磁盘读，顺便写进缓存。执行顺序：</p><ul><li>先删除缓存后更新数据库，默认第一步失败抛出异常，第一步必成功，第二步更新数据库即使失败，不影响一致性。</li><li>先更新数据库后删除缓存，第二步失败，会影响一致性。</li></ul><p><strong>极端情况下，即使是先删除缓存后更新数据库，这两个操作始终不是一个事务。可能新的值还没有写到数据库，但是旧值已经加载到缓存，导致了缓存不一致。</strong></p><h4 id="高并发下通过内存队列保持一致性"><a href="#高并发下通过内存队列保持一致性" class="headerlink" title="高并发下通过内存队列保持一致性"></a>高并发下通过内存队列保持一致性</h4><p>高并发下需要保证缓存不命中的时候读操作等待更新操作完成，这里保证缓存和数据库双写的一致性，可以通过维护一个更新操作的内存队列。这个内存队列保证分布式集群部署条件，可以考虑用redis：</p><ul><li>1.更新操作到达redis，先删除对应缓存。</li><li>2.根据更新数据的唯一标示，删除缓存通识增加一个更新队列到redis中。key为数据唯一标示。</li><li>3.读操作到达redis，查询缓存未命中，查询内存队列，有更新操作需要等待，超时时间内等待。</li><li>4.更新队列更新数据库操作完成，清空内存队列。</li><li>5.读操作循环检测内存队列，直到内存队列为空，开启查询，读操作设置超时时间，超时从数据库读取旧值。</li></ul><p><strong>实际上在高并发的场景下，我们保证了一致性就必定是不能保证高可用的。如果更新操作频繁，将会导致读操作超时阻塞等待时间比较久。实际场景也需要做大量的测试。</strong></p><h4 id="分布式寻址算法"><a href="#分布式寻址算法" class="headerlink" title="分布式寻址算法"></a>分布式寻址算法</h4><p>先介绍下分布式寻址一般采用的几种方式：</p><blockquote><p>分布式寻址算法主要针对将数据分成多片，适合<strong>海量数据+高并发+高可用</strong>这种场景。无法对key进行范围查找，单片对范围查找支持比较友好。</p></blockquote><p>针对这种场景可以采用hash算法，一致性hash算法或者hash slot算法。目前redis cluster采用的是hash slot算法。这里假设场景是，多个master，每个master上存储了部分元数据，同时每个master都有自己的slave集群，结合sentinel哨兵机制去做高可用。</p><h5 id="hash算法（导致缓存穿透）"><a href="#hash算法（导致缓存穿透）" class="headerlink" title="hash算法（导致缓存穿透）"></a>hash算法（导致缓存穿透）</h5><ul><li>1.根据数据的key值进行hash，得到唯一的hash值，再通过取模，得到具体要去哪个master寻数据。</li><li>2.如果出现宕机，取模的数量会减少一，导致大量的数据都是寻址到不对应的master上，缓存命中失败，缓存穿透。</li></ul><h5 id="一致性hash算法（虚拟节点负载均衡）"><a href="#一致性hash算法（虚拟节点负载均衡）" class="headerlink" title="一致性hash算法（虚拟节点负载均衡）"></a>一致性hash算法（虚拟节点负载均衡）</h5><p>一致性hash算法，针对上面的hash算法进行了处理：</p><ul><li>1.先定制一个hash环，hash值可能从0～2^32-1，所有的master节点都会被映射环的任意位置。</li><li>2.假设我们当前有八个master节点，每个节点开始在环上寻找自己的位置，根据主机ip+端口得到的hash值占据环上某个位置。</li><li>3.当查询或者更新的key进来时，同样根据key去做hash得到hash值落在环上某个点，顺时针找到第一个master节点。</li><li>4.节点数量很少的情况下可能导致节点过于分散，出现单个master节点负载过高，采用虚拟节点进行负载均衡，在step2对节点进行hash的时候，单个master进行多次hash产生多个虚拟节点，尽量均匀分散。</li></ul><h5 id="redis-cluster的hash-slot算法"><a href="#redis-cluster的hash-slot算法" class="headerlink" title="redis cluster的hash slot算法"></a>redis cluster的hash slot算法</h5><p>redis cluster提出了哈希槽的概念，没有采用一致性hash算法。一致性hash算法具备很好的数据容错性和扩展性，当某一个节点宕机时，只有宕机的节点历史数据会受到影响，新数据会容错到其他的节点上，而且如果需要增加和删除节点，也是非常方便的。</p><p>redis cluster采用的了<strong>2^14（16834）个</strong>hash slot，这些slot会根据节点自动分片，当删除节点和增加节点的时候会将节点的hash slot进行重新分配，动态增加和减少节点不影响整个集群的可用性。</p><p>redis高可用和主备切换，可以类比哨兵机制replication+sentinel，主要的步骤：</p><ul><li>1.判断master节点宕机，直接ping不过，主观宕机，多数节点ping master不过，客观宕机，认定master宕机。</li><li>2.slave节点过滤，通过slave的连接master时间失联的长短过滤掉失联过长的slave节点。</li><li>3.slave节点选举，选举出数据最多的某个slave作为新的master节点，进行故障转移。</li></ul><p>整个过程跟哨兵机制是高度一致的。</p><h4 id="redis分布式锁和zookeeper分布式锁"><a href="#redis分布式锁和zookeeper分布式锁" class="headerlink" title="redis分布式锁和zookeeper分布式锁"></a>redis分布式锁和zookeeper分布式锁</h4><p>redis分布式锁加锁在当前redis cluster的部署机制下，需要对某个master的节点遍历加锁才算加锁成功，并且其他的线程需要等待，底层是线上较zookeeper更为复杂。通常我们采用zookeeper做分布式锁实现较为简单。</p><ul><li>redis 分布式锁，其实<strong>需要自己不断去尝试获取锁</strong>，比较消耗性能。获取到锁的客户端挂了其他客户端需要等待锁释放。</li><li>zk 分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小。获取到锁的客户端挂了不需要等待，直接释放。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Redis和Memcache的主要区别&quot;&gt;&lt;a href=&quot;#Redis和Memcache的主要区别&quot; class=&quot;headerlink&quot; title=&quot;Redis和Memcache的主要区别&quot;&gt;&lt;/a&gt;Redis和Memcache的主要区别&lt;/h4&gt;&lt;ul&gt;

      
    
    </summary>
    
    
      <category term="缓存学习" scheme="http://jianghao.wang/tags/%E7%BC%93%E5%AD%98%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>分库分表</title>
    <link href="http://jianghao.wang/2019/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <id>http://jianghao.wang/2019/分库分表/</id>
    <published>2019-03-01T09:42:52.745Z</published>
    <updated>2019-03-05T02:37:57.899Z</updated>
    
    <content type="html"><![CDATA[<p>当mysql单表的数据量达到200万条以上时，建立索引和单表查询的代价较大，查询性能也会到达瓶颈，需要进行分库分表。</p><h4 id="垂直拆分-水平拆分"><a href="#垂直拆分-水平拆分" class="headerlink" title="垂直拆分+水平拆分"></a>垂直拆分+水平拆分</h4><p><strong>垂直拆分（单表字段过多）</strong>：将单表的数据量分别分散到多个库表，拆分的主要标准是热点数据vs非热点数据，热点数据mysql有buffer_pool缓存热点数据页。分别将热点字段拆分到热点表，非热点数据拆分到非热点表。</p><p><strong>水平拆分（单表数据记录过多）</strong>：将单表大量的数据分散到多个库表，表结构一直，利用数据库中间件分发到对应的库。业务上当单表的数据过多时，采用读写分离无法改善单库的性能瓶颈。分散到多个库表直接提高性能。</p><p>水平拆分一般采用下面的两种方式：</p><ul><li><strong>按照范围range拆分，例如根据创建时间将1000w条记录分散到五个表，优点是简单，当新数据来的时候不需要改表结构，只需要不断进行拆分就行。确定是一般最近的数据都是热点数据，导致查询都落在一个库表，导致分库分表并不是很彻底。</strong></li><li><strong>按照hash的方式来拆分，每一条记录的主键都对应一个hash值，映射到不同的库表，优点是数据分散较为均匀，查询压力分散，并发承载力更好。缺点是如果需要再次扩展库表，需要对所有的数据重新进行hash分配库表，代价较大。</strong></li></ul><h4 id="数据库（分库分表）中间件"><a href="#数据库（分库分表）中间件" class="headerlink" title="数据库（分库分表）中间件"></a>数据库（分库分表）中间件</h4><p>这里主要罗列两种目前用的比较多比较主流的中间件，一种是基于客户端的<strong>sharding-jdbc</strong>，一种是基于proxy代理的<strong>mycat</strong>。</p><ul><li><h4 id="mycat优点是proxy有单独的团队维护升级，业务团队客户端不需要关心，适用于大规模公司（阿里面试问了好几次分库分表）。"><a href="#mycat优点是proxy有单独的团队维护升级，业务团队客户端不需要关心，适用于大规模公司（阿里面试问了好几次分库分表）。" class="headerlink" title="mycat优点是proxy有单独的团队维护升级，业务团队客户端不需要关心，适用于大规模公司（阿里面试问了好几次分库分表）。"></a>mycat优点是proxy有单独的团队维护升级，业务团队客户端不需要关心，适用于大规模公司（阿里面试问了好几次分库分表）。</h4></li><li><h4 id="sharding-jdbc是基于客户端的模式，缺点是需要客户端主动进行版本的升级，优点是不需要团队专门维护，适用于中小规模公司。"><a href="#sharding-jdbc是基于客户端的模式，缺点是需要客户端主动进行版本的升级，优点是不需要团队专门维护，适用于中小规模公司。" class="headerlink" title="sharding-jdbc是基于客户端的模式，缺点是需要客户端主动进行版本的升级，优点是不需要团队专门维护，适用于中小规模公司。"></a>sharding-jdbc是基于客户端的模式，缺点是需要客户端主动进行版本的升级，优点是不需要团队专门维护，适用于中小规模公司。</h4></li></ul><h4 id="分库分表数据迁移"><a href="#分库分表数据迁移" class="headerlink" title="分库分表数据迁移"></a>分库分表数据迁移</h4><p>实际场景中，未分库分表状态需要支持动态切换到分库分表状态，但是后台在升级或者优化的过程中需要尽量考虑到是否对业务产生影响，如果通过停机升级的方式大部分场景下是不可以接受的，这里介绍一种<strong>双写迁移方案</strong>。</p><ul><li>1.业务团队改写配置，对于增删改操作，同时落到<strong>老数据库+分库分表数据库中间件</strong>。查询操作依旧走老数据库。</li><li>2.开始从<strong>老数据库导入数据到数据库中间件</strong>，覆盖原则为<strong>新数据覆盖老数据</strong>根据最新更新时间<strong>date_update</strong>来判断。</li><li>3.确保数据全部导入完成，业务方配置全部切换到<strong>分库分表数据库中间件</strong>。</li></ul><p><img src="https://arthornye.github.io/images/doublewrite.jpg" alt="cmd-markdown-logo"></p><h4 id="动态扩容缩容分库分表方案"><a href="#动态扩容缩容分库分表方案" class="headerlink" title="动态扩容缩容分库分表方案"></a>动态扩容缩容分库分表方案</h4><p>真实场景下对数据库做分库分表之后可能还会面临扩容的情况，需要最大程度上支持可扩展，先生成一个32*32足够使用的逻辑表，当需要扩容的时候进行动态扩容。动态扩容缩容分库分表方案步骤：</p><ol><li>设定好几台数据库服务器，每台服务器上几个库，每个库多少个表，推荐是 32库 * 32表，对于大部分公司来说，可能几年都够了。</li><li>路由的规则，orderId 模 32 = 库，orderId / 32 模 32 = 表</li><li>扩容的时候，申请增加更多的数据库服务器，装好 mysql，呈倍数扩容，4 台服务器，扩到 8 台服务器，再到 16 台服务器。</li><li>由 dba 负责将原先数据库服务器的库，迁移到新的数据库服务器上去，库迁移是有一些便捷的工具的。</li><li>我们这边就是修改一下配置，调整迁移的库所在数据库服务器的地址。</li><li>重新发布系统，上线，原先的路由规则变都不用变，直接可以基于 n 倍的数据库服务器的资源，继续进行线上系统的提供服务。</li></ol><h4 id="主键id如何设计"><a href="#主键id如何设计" class="headerlink" title="主键id如何设计"></a>主键id如何设计</h4><p>分库分表有一个问题就是自增id如何生成，唯一主键id再分布式的情况下如何生成，介绍几种方法的利弊：</p><table><br><tr><br>    <th>走单库生成主键id</th><br>    <th>比较简单</th><br>    <th>单库生成无用数据，并发承载量为单库承载量，违背分库分表的初衷</th><br></tr><br><tr><br>    <th>数据库sequence字段分段自增 </th><br>    <th>简单，分为32个模块32个表，每个表自增分别从id+1024累加</th><br>    <th>缺点是没办法进行扩展</th><br></tr><br><tr><br>    <th>UUID生成唯一主键</th><br>    <th>优点是业务方自动生成，方便</th><br>    <th>确定是这样生成比较占用空间，字符串太长</th><br></tr><br><tr><br>    <th>snowflake 算法</th><br>    <th>推荐</th><br>    <th>推荐</th><br></tr><br></table><h5 id="snowflake-算法"><a href="#snowflake-算法" class="headerlink" title="snowflake 算法"></a>snowflake 算法</h5><p>snowflake 算法是 twitter 开源的分布式 id 生成算法，采用 Scala 语言实现，是把一个 64 位的 long 型的 id，1 个 bit 是不用的，用其中的 41 bit 作为毫秒数，用 10 bit 作为工作机器 id，12 bit 作为序列号。</p><ul><li>1 bit：不用，为啥呢？因为二进制里第一个 bit 为如果是 1，那么都是负数，但是我们生成的 id 都是正数，所以第一个 bit 统一都是 0。</li><li>41 bit：表示的是时间戳，单位是毫秒。41 bit 可以表示的数字多达 <code>2^41 - 1</code>，也就是可以标识 <code>2^41 - 1</code> 个毫秒值，换算成年就是表示69年的时间。</li><li>10 bit：记录工作机器 id，代表的是这个服务最多可以部署在 2^10台机器上哪，也就是1024台机器。但是 10 bit 里 5 个 bit 代表机房 id，5 个 bit 代表机器 id。意思就是最多代表 <code>2^5</code>个机房（32个机房），每个机房里可以代表 <code>2^5</code> 个机器（32台机器）。</li><li>12 bit：这个是用来记录同一个毫秒内产生的不同 id，12 bit 可以代表的最大正整数是 <code>2^12 - 1 = 4096</code>，也就是说可以用这个 12 bit 代表的数字来区分<strong>同一个毫秒内</strong>的 4096 个不同的 id。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 | 0001100 10100010 10111110 10001001 01011100 00 | 10001 | 1 1001 | 0000 00000000</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>中间件是如何进行分库分表适配的？不管是基于proxy还是基于客户端，对客户端的查询来说，都不需要关心最终查询落到了哪个库表上，中间件会帮你全部封装好。我的理解是垂直拆分和两种水平拆分的方式，中间件会帮你维护一个映射表，某个对应的key具体映射到哪个库哪个表，然后进行统一的提交。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当mysql单表的数据量达到200万条以上时，建立索引和单表查询的代价较大，查询性能也会到达瓶颈，需要进行分库分表。&lt;/p&gt;
&lt;h4 id=&quot;垂直拆分-水平拆分&quot;&gt;&lt;a href=&quot;#垂直拆分-水平拆分&quot; class=&quot;headerlink&quot; title=&quot;垂直拆分+水平拆
      
    
    </summary>
    
    
      <category term="mysql学习" scheme="http://jianghao.wang/tags/mysql%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>mysql中的join操作算法介绍</title>
    <link href="http://jianghao.wang/2019/mysql%E4%B8%AD%E7%9A%84join%E6%93%8D%E4%BD%9C/"/>
    <id>http://jianghao.wang/2019/mysql中的join操作/</id>
    <published>2019-02-21T08:53:21.589Z</published>
    <updated>2019-02-27T07:50:29.158Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要介绍mysql在join操作上采用的一些算法，以及如何做优化。主要分为Index Nested-Loop Join（NLJ）算法和Block Nested-Loop Join（BLJ）算法，基于Multi-Range Read优化的Batched Access Key（BKA）算法。</p><h4 id="Block-Nested-Loop-Join-BNL"><a href="#Block-Nested-Loop-Join-BNL" class="headerlink" title="Block Nested-Loop Join (BNL)"></a>Block Nested-Loop Join (BNL)</h4><p>通常在explain执行的extra中会有<strong>join_buffer(Block Nested-Loop Join)</strong>表示这次join操作使用了BNL算法。算法主要步骤是：</p><ul><li>1.从驱动表批量查出数据，放到<strong>join_buffer</strong>中。</li><li>2.根据<strong>关联字段</strong>从被驱动表全表<strong>扫描数据</strong>，进行关联。</li><li>3.被关联表查到数据之后进行<strong>回表</strong>。</li><li>4.join_buffer中封装最终数据。</li></ul><p>存在的性能问题：</p><ul><li>1.buffer_pool被占用，降低了缓存命中率。buffer_pool使用<strong>LRU(最近最少使用原则)</strong>理论上M*N不断的进行全表扫描，被驱动表数据会大量缓存在buffer_pool中。</li><li>2.查询操作频繁，耗费大量cpu资源。同时会有大量的磁盘io。</li></ul><p><strong>实际运用过程中，如果出现了使用Block Nested-Loop Join(BNL)建议进行优化。对性能影响较大。</strong></p><h4 id="Index-Nested-Loop-Join-NLJ"><a href="#Index-Nested-Loop-Join-NLJ" class="headerlink" title="Index Nested-Loop Join (NLJ)"></a>Index Nested-Loop Join (NLJ)</h4><p>在上面的基础之上，采用了对被驱动表加索引的方式，极大的提升了效率，如果explain的结果extra中没有出现<strong>join_buffer(Block Nested-Loop Join)</strong>就表示这次join操作默认使用了NLJ算法。该算法有相对的优点：</p><ul><li>1.采用索引的方式定位磁盘块，减少了io次数和cpu资源的消耗。</li><li>2.不会出现BNL算法可能淘汰热点页的问题。只会缓存不同的磁盘块数据。</li></ul><h4 id="Multi-Range-Read-MRR"><a href="#Multi-Range-Read-MRR" class="headerlink" title="Multi-Range Read (MRR)"></a>Multi-Range Read (MRR)</h4><p>该优化主要针对索引回表，<strong>MRR将随机回表读通过join_buffer根据主键id排序改变为顺序回表，一定程度上提升了回表效率，减少了回表次数加快了io读。</strong>mysql中可以通过设置参数开启该算法，默认是关闭的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 通过设置参数开启mrr算法优化。mrr_cost_based=off</span><br><span class="line">set optimizer_switch=&apos;mrr=on,mrr_cost_based=off,batched_key_access=on&apos;;</span><br></pre></td></tr></table></figure><h4 id="Batched-Access-Key-BKA"><a href="#Batched-Access-Key-BKA" class="headerlink" title="Batched Access Key (BKA)"></a>Batched Access Key (BKA)</h4><p>基于Multi-Range Read优化的Batched Access Key（BKA）算法，实际上也是对<strong>NLJ算法的优化。</strong>执行流程如下：</p><ul><li>1.从驱动表中加载数据到join_buffer中得到数据块x，这里如果超出了容量，通过分段的方式加载。（可以通过调整join_buffer的大小改善）。</li><li>2.通过索引查到join_buffer中所有的被驱动表上的数据块y，放到join_buffer中。</li><li>3.通过join_buffer对数据块y进行主键id排序，得到主键id数据块z。</li><li>4.根据排序好的主键id去回表执行顺序读，得到关联查询的数据结果集。</li><li>5.在join_buffer中整合数据数据块x和z，返回结果集给客户端。</li></ul><p><strong>一般我们如果需要将BNL算法转成BKA算法，只需要在被驱动表上建立一个索引就行了。</strong></p><h4 id="特殊情况处理（无法建立索引）"><a href="#特殊情况处理（无法建立索引）" class="headerlink" title="特殊情况处理（无法建立索引）"></a>特殊情况处理（无法建立索引）</h4><p>当在被驱动表上建立索引的成本可能比较高的时候，不建议建立索引。<strong>例如，当关联的结果集实际上可以精简到一个小结果的时候，我们可以建立一个临时表，在临时表上建立索引。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 模拟一下，b字段所在的表数据量很大，但是我们只需要两千条，通过create temporary table建立临时表同时建立索引</span><br><span class="line">create temporary table temp_t(id int primary key, a int, b int, index(b))engine=innodb;</span><br><span class="line">insert into temp_t select * from t2 where b&gt;=1 and b&lt;=2000;</span><br><span class="line">select * from t1 join temp_t on (t1.b=temp_t.b);</span><br></pre></td></tr></table></figure><p>当然最好的操作方式还是数据引擎如果<strong>支持hash join</strong>就完美了，但是mysql是不支持的。如果支持hash join可以快速定位到记录，数据结构参考HashMap数据结构。如果数据引擎不支持，可以考虑在程序内存中将被驱动表的数据放在<strong>Set或者HashMap</strong>这样的数据结构中，进行关联。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇主要介绍mysql在join操作上采用的一些算法，以及如何做优化。主要分为Index Nested-Loop Join（NLJ）算法和Block Nested-Loop Join（BLJ）算法，基于Multi-Range Read优化的Batched Access Ke
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql内部临时表和分组优化</title>
    <link href="http://jianghao.wang/2019/mysql%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%92%8C%E5%88%86%E7%BB%84%E4%BC%98%E5%8C%96/"/>
    <id>http://jianghao.wang/2019/mysql内部临时表和分组优化/</id>
    <published>2019-02-16T12:54:41.867Z</published>
    <updated>2019-02-18T06:18:41.174Z</updated>
    
    <content type="html"><![CDATA[<p>mysql什么时候使用到内部临时表，通过explain可以看到extra信息里面会显示using temporary。我们知道针对mysql的order by操作，维护了一个内存空间sort_buffer，超出这个内存之后会采用磁盘辅助排序，extra信息中会有using filesort。那么mysql什么时候会有using temporary并且如何进行优化。</p><p>内部临时表，存储过程类似sort_buffer的进化过程，先存内存，后退化到磁盘辅助。可以查看到mysql为内部临时表分配的内存大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查看配置temp_table_size大小</span><br><span class="line">show variables like &quot;tmp_table%&quot;</span><br><span class="line">-- result 1KB 超过1KB之后用磁盘存储</span><br><span class="line">tmp_table_size1024</span><br><span class="line">-- 可以设定temp_table_size内存的大小,global去除只对当前session生效</span><br><span class="line">set global tmp_table_size=1024</span><br></pre></td></tr></table></figure><h4 id="union操作using-temporary"><a href="#union操作using-temporary" class="headerlink" title="union操作using temporary"></a>union操作using temporary</h4><p>union操作的语义，将两个结果集整合到一个结果集，union操作会有using temporary，用到内部临时表。主要由于union操作需要去重，如果是union all操作会直接将结果返回给客户端，不在内部临时表做去重操作。</p><h4 id="group-by操作using-temporary"><a href="#group-by操作using-temporary" class="headerlink" title="group by操作using temporary"></a>group by操作using temporary</h4><p>group by操作的过程：</p><ul><li>1.根据结果集的字段建立内部临时表，分组id，count两个字段。</li><li>2.全表扫描需要分组的表，如果内部临时表没有对应的分组id，新增一条记录。</li><li>3.如果内部临时表有对应的分组id，直接count++累加。</li><li>4.根据id进行排序order by将结果存在内存或者持久化到临时磁盘表。</li></ul><h4 id="group-by操作索引优化"><a href="#group-by操作索引优化" class="headerlink" title="group by操作索引优化"></a>group by操作索引优化</h4><p>group by操作explain如果extra信息中有using temporary和using filesort，在数据量比较大的情况下会造成慢查询。mysql 5.7以上版本提供关联列更新操作，<strong>generated column关联某列数据的更新。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 增加一列，列的值为id % 100（分组字段） ，然后为该列建立索引（建立索引避免了排序）。generated column操作会关联列，继续新增一条记录即使没有制定值也会通过关联的列的值计算。</span><br><span class="line">alter table t1 add column z int generated always as (id % 100),add index z_index(z);</span><br></pre></td></tr></table></figure><p>通过加索引，避免了使用临时表，同时避免了使用排序（取出来即为有序），也就是extra中不会出现using temporary和using filesort。那么这个过程为什么避免了？</p><ul><li>没有索引的情况下，需要临时表来记录，因为过程无序，并且最终需要排序。</li><li>有索引的情况下本身有序，不需要记录累加的结果，结果在扫描过过程中得到并且是有序的。</li></ul><h4 id="group-by操作存储优化"><a href="#group-by操作存储优化" class="headerlink" title="group by操作存储优化"></a>group by操作存储优化</h4><p>内存临时表容量，也就是tmp_table_size不够大的时候，会退化为磁盘存储，在数据量大的时候直接指定使用磁盘存储。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 通过SQL_BIG_RESULT这种方式指定不走内存内存临时表，直接用磁盘临时表。</span><br><span class="line">select SQL_BIG_RESULT id%100 as m, count(*) as c from t1 group by m;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>sort_buffer是有序数组，tmp_table_size临时表是二维表结构，具备表的语义，join_buffer是无序数组，均可查看配置大小。</p></li><li><p>执行过程中需要使用二维表结构语义的，优先使用临时表。union操作需要检验唯一约束，需要使用临时表存储。group by需要在过程中用另一个字段计算累加结果。</p></li><li><p>扫描过程中可以直接得到结果的，不需要使用临时表，需要计算的要使用临时表。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mysql什么时候使用到内部临时表，通过explain可以看到extra信息里面会显示using temporary。我们知道针对mysql的order by操作，维护了一个内存空间sort_buffer，超出这个内存之后会采用磁盘辅助排序，extra信息中会有using 
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java 8中异步处理</title>
    <link href="http://jianghao.wang/2019/Java-8%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/"/>
    <id>http://jianghao.wang/2019/Java-8异步处理/</id>
    <published>2019-01-29T06:11:08.722Z</published>
    <updated>2019-01-31T09:22:18.241Z</updated>
    
    <content type="html"><![CDATA[<p>Java8中提供了CompletableFeature工具，提供了一系列基于函数式的api。本篇主要介绍这些api的使用以及源码实现。</p><h4 id="CompletableFeature-supplyAsyc"><a href="#CompletableFeature-supplyAsyc" class="headerlink" title="CompletableFeature.supplyAsyc()"></a>CompletableFeature.supplyAsyc()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.输入一个supplier函数，输出一个CompletableFeature&lt;U&gt;引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(asyncPool, supplier);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.传入一个线程池，一个supplier函数，输出一个CompletableFeature&lt;U&gt;引用</span></span><br><span class="line"><span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">asyncSupplyStage</span><span class="params">(Executor e,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 Supplier&lt;U&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    CompletableFuture&lt;U&gt; d = <span class="keyword">new</span> CompletableFuture&lt;U&gt;();</span><br><span class="line">    <span class="comment">//异步调用之后执行return d</span></span><br><span class="line">    e.execute(<span class="keyword">new</span> AsyncSupply&lt;U&gt;(d, f));</span><br><span class="line">    <span class="comment">//主线程直接返回创建的对象</span></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.线程池中线程异步执行supplier函数</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncSupply</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">Void</span>&gt;</span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">AsynchronousCompletionTask</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;T&gt; dep; Supplier&lt;T&gt; fn;</span><br><span class="line">        <span class="comment">//初始化时用主线程CompletableFeature对象引用</span></span><br><span class="line">        AsyncSupply(CompletableFuture&lt;T&gt; dep, Supplier&lt;T&gt; fn) &#123;</span><br><span class="line">            <span class="keyword">this</span>.dep = dep; <span class="keyword">this</span>.fn = fn;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Void <span class="title">getRawResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRawResult</span><span class="params">(Void v)</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123; run(); <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里的 d引用==线程初始化对象引用dep==主线程对象引用</span></span><br><span class="line">            CompletableFuture&lt;T&gt; d; Supplier&lt;T&gt; f;</span><br><span class="line">            <span class="keyword">if</span> ((d = dep) != <span class="keyword">null</span> &amp;&amp; (f = fn) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                dep = <span class="keyword">null</span>; fn = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (d.result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//异步线程内部同步执行supplier函数，f.get返回类型和泛型类型保持一致</span></span><br><span class="line">                        d.completeValue(f.get());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="comment">//发生异常将异常作为结果对象</span></span><br><span class="line">                        d.completeThrowable(ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                d.postComplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//4.d.completeValue通过unsafe cas替换，到这里异步线程执行完成并将执行结果记录在volatile object result对象中</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">completeValue</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//入参this（object1），result（volatile object类型），null（拷贝旧值），t（返回新值）</span></span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, RESULT, <span class="keyword">null</span>,(t == <span class="keyword">null</span>) ? NIL : t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5.这里的RESULT</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"><span class="comment">// 为什么是long类型，暂时理解为内存地址吧。。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RESULT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> STACK;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> NEXT;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> sun.misc.Unsafe u;</span><br><span class="line">        UNSAFE = u = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k = CompletableFuture.class;</span><br><span class="line">        <span class="comment">//获取声明字段的内存地址</span></span><br><span class="line">        RESULT = u.objectFieldOffset(k.getDeclaredField(<span class="string">"result"</span>));</span><br><span class="line">        STACK = u.objectFieldOffset(k.getDeclaredField(<span class="string">"stack"</span>));</span><br><span class="line">        NEXT = u.objectFieldOffset</span><br><span class="line">            (Completion.class.getDeclaredField(<span class="string">"next"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception x) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程循环等待 volatile object result返回<strong>CompletableFeature.get()。</strong>同时可以设置超时时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">waitingGet</span><span class="params">(<span class="keyword">boolean</span> interruptible)</span> </span>&#123;</span><br><span class="line">        Signaller q = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> spins = -<span class="number">1</span>;</span><br><span class="line">        Object r;</span><br><span class="line">    <span class="comment">//就这一句判断，反正就是不给我我就循环，占着cpu，你说难受不难受，如果不设置超时时间异步线程不返回，就死循环卡着了，是不是很伤。内部应该处理了一些什么东西，避免死循环占用cpu，可以换成阻塞式，让出cpu。</span></span><br><span class="line">        <span class="keyword">while</span> ((r = result) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)</span><br><span class="line">                spins = (Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span>) ?</span><br><span class="line">                    <span class="number">1</span> &lt;&lt; <span class="number">8</span> : <span class="number">0</span>; <span class="comment">// Use brief spin-wait on multiprocessors</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ThreadLocalRandom.nextSecondarySeed() &gt;= <span class="number">0</span>)</span><br><span class="line">                    --spins;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里之前死循环，spins == 1&lt;&lt;8 === 256 次，进行256次死循环。检查result，如果这段时间没有返回。执行到下面的代码。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">                q = <span class="keyword">new</span> Signaller(interruptible, <span class="number">0L</span>, <span class="number">0L</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">                <span class="comment">//这里会进入然后一直阻塞，让出cpu，知道result返回之后才返回继续执行一次循环，然后退出循环。</span></span><br><span class="line">                queued = tryPushStack(q);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (interruptible &amp;&amp; q.interruptControl &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                q.thread = <span class="keyword">null</span>;</span><br><span class="line">                cleanStack();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q.thread != <span class="keyword">null</span> &amp;&amp; result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ForkJoinPool.managedBlock(q);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    q.interruptControl = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span>) &#123;</span><br><span class="line">            q.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (q.interruptControl &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (interruptible)</span><br><span class="line">                    r = <span class="keyword">null</span>; <span class="comment">// report interruption</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        postComplete();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>附上流程图吧：</p><p><img src="http://arthornye.github.io/images/completeFeature.jpg" alt="cmd-markdown-logo"></p><p>推荐设置超时时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 11/20/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompleteFeatureTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; stringCompletableFuture=CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//定义的body，默认覆盖,定义一个supplier函数异步调用，模拟网络调用</span></span><br><span class="line">                Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"同步异常"</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//return 的类型为定义的模板类型</span></span><br><span class="line">                <span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String string= <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                string = stringCompletableFuture.get(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"getResultString:"</span>+string);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CompletableFeature-runAsync"><a href="#CompletableFeature-runAsync" class="headerlink" title="CompletableFeature.runAsync()"></a>CompletableFeature.runAsync()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.runAsync(() -&gt;</span><br><span class="line">                           System.out.println(<span class="string">"CompleteFeature runAsync..."</span>)</span><br><span class="line">                          );</span><br></pre></td></tr></table></figure><p>异步调用线程，不关心返回结果，这里入参是一个lamada表达式。Java8之前的写法是匿名内部类的方式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.runAsync(</span><br><span class="line">    <span class="comment">//java8 之后不推荐这么写，采用lamada表达式</span></span><br><span class="line">    <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"CompleteFeature runAsync..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这个函数调用不关心返回结果。</p><h4 id="CompletableFeature-runAsync-whenComplete-whenCompleteAsync"><a href="#CompletableFeature-runAsync-whenComplete-whenCompleteAsync" class="headerlink" title="CompletableFeature.runAsync().whenComplete()/.whenCompleteAsync"></a>CompletableFeature.runAsync().whenComplete()/.whenCompleteAsync</h4><ul><li><strong>1.CompletableFeature.runAsync()开辟一个异步线程a,主线程直接返回CompletableFeature<void>类型的一个引用，不关心a的执行结果。</void></strong></li><li><strong>2.主线程用CompletableFeature<void>的引用调用.whenComplete()直接返回CompletableFeature<t>的引用，a线程执行完成之后，执行whenComplete()中的BiConsumer方法，完全异步，不干扰主线程。</t></void></strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 11/20/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompleteFeatureTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CompletableFuture&lt;?&gt; completableFuture=CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getId() + <span class="string">"   CompleteFeature runAsync..."</span>);</span><br><span class="line">        &#125;).whenComplete((t, e) -&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getId() + <span class="string">"   CompleteFeature runAsync...complete"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;?&gt; completableFuture1 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getId() + <span class="string">"   CompleteFeature runAsync...1"</span>);                                                                  &#125;).whenCompleteAsync((t, u) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getId() + <span class="string">"   CompleteFeature runAsync...complete...1"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      CompletableFuture&lt;?&gt; all=CompletableFuture.allOf(completableFuture,completableFuture1);</span><br><span class="line">      all.whenComplete(</span><br><span class="line">          (v,e)-&gt;</span><br><span class="line">          System.out.println(<span class="string">"all completed"</span>)</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          all.get();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>   CompleteFeature runAsync...</span><br><span class="line"><span class="number">11</span>   CompleteFeature runAsync...<span class="number">1</span></span><br><span class="line"><span class="number">10</span>   CompleteFeature runAsync...complete</span><br><span class="line"><span class="number">11</span>   CompleteFeature runAsync...complete...<span class="number">1</span></span><br><span class="line">all completed</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java8中提供了CompletableFeature工具，提供了一系列基于函数式的api。本篇主要介绍这些api的使用以及源码实现。&lt;/p&gt;
&lt;h4 id=&quot;CompletableFeature-supplyAsyc&quot;&gt;&lt;a href=&quot;#CompletableFeatu
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>mysql大查询内存策略</title>
    <link href="http://jianghao.wang/2019/mysql%E5%A4%A7%E6%9F%A5%E8%AF%A2%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5/"/>
    <id>http://jianghao.wang/2019/mysql大查询内存策略/</id>
    <published>2019-01-28T02:15:11.571Z</published>
    <updated>2019-01-28T05:50:13.068Z</updated>
    
    <content type="html"><![CDATA[<p>mysql在处理大查询的时候需要有自己的内存策略，保证不会出现OOM（Out Of Memory）内存泄漏。我们从server层面和引擎层面剖析一下内存策略。</p><h4 id="server层处理大查询"><a href="#server层处理大查询" class="headerlink" title="server层处理大查询"></a>server层处理大查询</h4><p>server层对大查询的处理，这里针对的大查询是返回的数据量巨大。针对这种查询server层会采用<strong>边读边发</strong>策略。也就是数据由客户端分阶段整合，服务端并不需要保证一个完整的结果集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查看net_buffer_length参数，服务端会先将数据存到这个内存区域，存满之后向客户端发送，不断重复。</span><br><span class="line">show variables like &quot;net_buffer_%&quot;</span><br><span class="line">-- 结果,默认16k大小</span><br><span class="line">net_buffer_length16384</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- show processlist,在大查询执行的过程中，语句会处于sending client data的状态</span><br><span class="line">show processlist;</span><br><span class="line">-- status ，语句的对应状态，如果发现有语句处于这种状态，需要业务方确认是否需要返回如此多的信息。尽量进行优化。</span><br><span class="line">sending client data`</span><br></pre></td></tr></table></figure><p>边读边发：</p><ul><li>1.服务端从磁盘中读取数据加入net_buffer_length内存中。默认16k。</li><li>2.net_buffer_length满，触发发送到客户端操作。</li><li>3.收到Socket Send Buffer结果为发送成功，清空net_buffer_length，重新读取。</li><li>4.如果Socket Send Buffer返回EAGAIN 或 WSAEWOULDBLOCK，表示Socket Send Buffer已满，进入等待直到重新可写。</li></ul><p><img src="http://arthornye.github.io/images/bigquery.jpg" alt="cmd-markdown-logo"></p><h4 id="Innodb处理大查询"><a href="#Innodb处理大查询" class="headerlink" title="Innodb处理大查询"></a>Innodb处理大查询</h4><p>大家都知道Innodb在执行查询的之后都会将sql和对应的数据页，放置在内存中，也就是<strong>Innodb buffer pool size</strong>，这个内存区域我们之前有介绍可以通过redo log减少随机写操作，以及change buffer来减少随机读操作。但是在大查询的情况下会面对哪些问题，先看这个区域采用的<strong>LRU算法（最近最少使用算法）</strong>。</p><ul><li>1.最近最少使用算法采用链表，以一个数据页为单位P1，P2…</li><li>2.从磁盘中读出一个页Pn会放置在链表的头部。</li><li>3.访问到某个数据页Px，先返回客户端结果，然后将该页放置到链表的头部。</li><li>4.当Innodb buffer pool size已经满了，取一个最旧的页，删除数据，存入新数据并将其放置到头部。</li></ul><p><img src="http://arthornye.github.io/images/pagelink.jpg" alt="cmd-markdown-logo"></p><p>针对大查询的场景，如果不断查询出新的数据，单纯采用<strong>LRU算法（最近最少使用）</strong>查询出来的新页会直接替换老页，导致正常的业务内存缓存会被替换掉，增加了磁盘IO，而这些新增的缓存页在第一次使用之后又不会再进行使用。这种场景Innodb<strong>针对LRU做了分代优化，将这个buffer区域按照5:3划分为young和old区。这个概念其实在垃圾回收机制的分代收集的场景类似。针对不同的生命周期定制不同的淘汰方案。</strong></p><p><img src="http://arthornye.github.io/images/youngold.jpg" alt="cmd-markdown-logo"></p><p>需要注意的是，<strong>分代的主要目的还是基于提高内存命中率。</strong></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>mysql针对大查询通过server层进行边读边写的操作防止内存泄漏，如果出现sending client data并且时间特别长的情况下，可以尝试调整net_buffer_length参数。但是还是需要通过业务这边减少查询的数据量来进行优化改善。</p><p>Innodb通过Innodb_buffer_pool_size内存来进行数据页的缓存，大查询可能导致不经常使用的数据页占领这个buffer区域导致其他的查询性能下降。<strong>LRU算法（最近最少使用）基础上的分代算法的改进可以保证正常业务和大查询业务的平衡</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mysql在处理大查询的时候需要有自己的内存策略，保证不会出现OOM（Out Of Memory）内存泄漏。我们从server层面和引擎层面剖析一下内存策略。&lt;/p&gt;
&lt;h4 id=&quot;server层处理大查询&quot;&gt;&lt;a href=&quot;#server层处理大查询&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>消息队列基本介绍</title>
    <link href="http://jianghao.wang/2019/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    <id>http://jianghao.wang/2019/消息队列基本介绍/</id>
    <published>2019-01-25T01:51:12.709Z</published>
    <updated>2019-01-25T02:09:58.672Z</updated>
    
    <content type="html"><![CDATA[<h4 id="主流的消息队列中间件"><a href="#主流的消息队列中间件" class="headerlink" title="主流的消息队列中间件"></a>主流的消息队列中间件</h4><table><br><tr><br>    <th>消息队列\特点</th><br>    <th>优点</th><br>    <th>缺点</th><br></tr><br><tr><br>    <th>ActiveMQ</th><br>    <th>老牌的消息中间件，功能强大。</th><br>    <th>没法确认ActiveMQ可以支撑互联网公司的高并发、高负载以及高吞吐的复杂场景，在国内互联网公司落地较少，多用于异步调用和系统解耦。</th><br></tr><br><tr><br>    <th>RabbitMQ</th><br>    <th>高并发，高吞吐，性能很高，后台管理系统很便捷，开源社区非常活跃。</th><br>    <th>基于erlang开发，较难进行二次开发。</th><br></tr><br><tr><br>    <th>RocketMQ</th><br>    <th>阿里开源，基于java，高并发，高吞吐，支持分布式。</th><br>    <th>未知。</th><br></tr><br></table><h4 id="消息中间件的主要作用"><a href="#消息中间件的主要作用" class="headerlink" title="消息中间件的主要作用"></a>消息中间件的主要作用</h4><h5 id="系统解耦"><a href="#系统解耦" class="headerlink" title="系统解耦"></a>系统解耦</h5><p>将消息存放到消息中间件，避免大量的系统直接调用，可以由被调用方自行进行消费。调用方不用关心结果，代码解耦合。</p><h5 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h5><p>调用链路比较长的情况下，通过消息异步调用减少接口调用时长，防止超时或者等待时间过长。</p><h5 id="流量削减"><a href="#流量削减" class="headerlink" title="流量削减"></a>流量削减</h5><p>在短时间大流量的情况下，需要进行限流，作为后端集群的负载，生产者可以不断生成消息，但是后端集群只会定量消费。保护了后台系统的稳定性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;主流的消息队列中间件&quot;&gt;&lt;a href=&quot;#主流的消息队列中间件&quot; class=&quot;headerlink&quot; title=&quot;主流的消息队列中间件&quot;&gt;&lt;/a&gt;主流的消息队列中间件&lt;/h4&gt;&lt;table&gt;&lt;br&gt;&lt;tr&gt;&lt;br&gt;    &lt;th&gt;消息队列\特点&lt;/th&gt;&lt;b
      
    
    </summary>
    
    
      <category term="消息队列" scheme="http://jianghao.wang/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>sql操作记录</title>
    <link href="http://jianghao.wang/2019/sql%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
    <id>http://jianghao.wang/2019/sql操作记录/</id>
    <published>2019-01-24T07:21:00.479Z</published>
    <updated>2019-03-26T09:47:45.834Z</updated>
    
    <content type="html"><![CDATA[<p>主要记录一些sql的订正的操作。</p><h4 id="insert操作无需指定自增id"><a href="#insert操作无需指定自增id" class="headerlink" title="insert操作无需指定自增id"></a>insert操作无需指定自增id</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- insert的时候指定一个列表</span><br><span class="line">insert into error_level_conf (biz_type,error_type,error_level,handle_num_limit) value(&quot;general_b2C&quot;,&quot;CREATE_COUPON_PAYMENT&quot;,1,10);</span><br></pre></td></tr></table></figure><h4 id="从一个表拷贝数据到另一个表并订正"><a href="#从一个表拷贝数据到另一个表并订正" class="headerlink" title="从一个表拷贝数据到另一个表并订正"></a>从一个表拷贝数据到另一个表并订正</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- retail_coupon.eticket_status 已经落表的数据直接已登账的状态，定金支付完成的订单状态为已分账，这里关联订单表状态150的为已登账，大于150为已分账</span><br><span class="line">-- retail_marketing_order.entry_status 和retail_marketing_order.split_account_status中台不使用，订正到已登账和已分账状态</span><br><span class="line"></span><br><span class="line">INSERT INTO retail_coupon (retail_order_code, eticket_status, tmall_order_id, coupon_type, step_no</span><br><span class="line">, disburse_fee, discount_price, delete_mark, tmall_sku_id, date_create</span><br><span class="line">, date_update, business_type, discount_stage, entry_status, split_account_status)</span><br><span class="line">SELECT t1.retail_order_code</span><br><span class="line">, (</span><br><span class="line">SELECT CASE t2.order_status</span><br><span class="line">WHEN 150 THEN 3</span><br><span class="line">ELSE 4</span><br><span class="line">END</span><br><span class="line">), t1.tmail_order_id, 1, t1.step_count, t1.disburse_fee</span><br><span class="line">, t1.voucher_price, t1.deleted, t1.sku_id, t1.date_create, t1.date_update</span><br><span class="line">, &apos;distributor&apos;, &apos;retainge&apos;, 50, 50</span><br><span class="line">FROM retail_marketing_order t1</span><br><span class="line">LEFT JOIN retail_order t2 ON convert(t1.retail_order_code USING utf8) = t2.order_code;</span><br></pre></td></tr></table></figure><h4 id="从一个表匹配数据并更新到另一个表"><a href="#从一个表匹配数据并更新到另一个表" class="headerlink" title="从一个表匹配数据并更新到另一个表"></a>从一个表匹配数据并更新到另一个表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">UPDATE retail_invoice_info t1</span><br><span class="line">LEFT JOIN retail_order t2 ON t1.purchase_order_id = t2.purchase_order_id</span><br><span class="line">SET t1.make_type = &apos;B2c&apos;, t1.invoice_type = (</span><br><span class="line">SELECT CASE t2.plate_user_type</span><br><span class="line">WHEN &apos;individual&apos; THEN &apos;personal&apos;</span><br><span class="line">ELSE &apos;enterprise&apos;</span><br><span class="line">END</span><br><span class="line">)</span><br><span class="line">WHERE (t1.order_code LIKE &apos;90%&apos;</span><br><span class="line">AND t1.invoice_type = &apos;&apos;</span><br><span class="line">AND t2.plate_user_type IS NOT NULL);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要记录一些sql的订正的操作。&lt;/p&gt;
&lt;h4 id=&quot;insert操作无需指定自增id&quot;&gt;&lt;a href=&quot;#insert操作无需指定自增id&quot; class=&quot;headerlink&quot; title=&quot;insert操作无需指定自增id&quot;&gt;&lt;/a&gt;insert操作无需指定自增
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>如何处理读写分离</title>
    <link href="http://jianghao.wang/2019/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    <id>http://jianghao.wang/2019/如何处理读写分离/</id>
    <published>2019-01-16T03:09:54.910Z</published>
    <updated>2019-01-19T09:28:21.685Z</updated>
    
    <content type="html"><![CDATA[<p>mysql在读写分离的场景下，可能是一主一从，一主都从。但是在实际应用场景中需要解决一个重要的问题就是<strong>“过期读”</strong>。本篇主要介读写分离可能的架构方式以及如何解决该问题。</p><h4 id="强制从主库读取"><a href="#强制从主库读取" class="headerlink" title="强制从主库读取"></a>强制从主库读取</h4><h5 id="及时查询vs非及时查询"><a href="#及时查询vs非及时查询" class="headerlink" title="及时查询vs非及时查询"></a>及时查询vs非及时查询</h5><p>针对某些必须保证正确读的场景，我们可以设置这个请求只能走主库，例如一个场景，商家在发布了商品之后需要立即看到商品的信息，那么这个我们可以直接从主库去读。同样的场景，买家在前端去看新发布的商品时可能并不需要这么及时，可以容忍有一定时间的延迟，那么这个查询比较适合走从库。这里我们将查询分为两类：<strong>及时查询和非及时查询。</strong></p><ul><li>优点：逻辑上比较简单，易于实现和区分</li><li>缺点：可能会面临所有的查询都是及时查询的情况，例如一些金融系统对及时性要求很高。</li></ul><h5 id="及时查询优化"><a href="#及时查询优化" class="headerlink" title="及时查询优化"></a>及时查询优化</h5><p>即使是刚才讲到的可能面对的及时查询的情况，查询的时效性很高。为了减少主库的查询压力，我们可以让前端直接去跳转，看起来做了查询但是实际上没有查询。上架了商品之后直接将上架的商品信息展示在商品栏，减少了一次查询主库的压力。</p><p>实际上我们在应用中经常会采取强制从主库读取这种方式，但是很可能面对尴尬的场景。整个系统对时效性要求都比较高的时候，而又必须通过读写分离改善的场景下，可以如何解决<strong>过期读</strong>的问题？</p><h4 id="判断主备延迟"><a href="#判断主备延迟" class="headerlink" title="判断主备延迟"></a>判断主备延迟</h4><p>每次在备库执行查询请求之前，先判断下主备是否有延迟。可以通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status;</span><br></pre></td></tr></table></figure><h5 id="seconds-behind-master"><a href="#seconds-behind-master" class="headerlink" title="seconds_behind_master"></a>seconds_behind_master</h5><p>判断seconds_behind_master，通过show slave status可以在从库上查看到这个参数，如果seconds_behind_master</p><p>为零，可以走从库进行查询。缺点是精度比较难保证。</p><h5 id="对比位点和GTID集合"><a href="#对比位点和GTID集合" class="headerlink" title="对比位点和GTID集合"></a>对比位点和GTID集合</h5><p>在备库执行show slave status可以看到备库的位点和GTID集合的状态：</p><p><img src="http://arthornye.github.io/images/poslog.jpg" alt="cmd-markdown-logo"></p><ul><li><strong>Master_Log_File == Relay_Master_Log_File  &amp;&amp; Read_    Master_Log_Pos == Exec_Master_log_File  为true，表明备库已经完成接收到的主库的binlog同步。此为对比位点。</strong></li><li><strong>Retrieved_Gtid_Set(接收到的集合) == Executed_Gtid_Set(已经执行了的集合) 为true表明备库已经完成接受到的主binlog的同步。此为对比GTID。Auto_Position=1 ，表示这对主备关系使用了 GTID协议。</strong></li></ul><p>虽然这种方式都可以保证备库已经执行完了主库存传过来的binlog，但是因为binlog的传送这个过程相对客户端是异步的，那么客户端在收到更新成功的一条语句之后，这个语句可能还没有传送到备库。</p><p><img src="http://arthornye.github.io/images/asynclog.jpg" alt="cmd-markdown-logo"></p><p>这里需要引入<strong>半同步复制semi-sync</strong>:</p><ul><li>1.主库的事务提交之后，向备库发一个binlog，注意这里先不返回客户端更新成功。</li><li>2.备库收到binlog之后，向主库发一个ack，表示收到了这个binlog。</li><li>3.主库收到备库的ack之后，向客户端返回更新成功。</li></ul><p>semi-sync缺陷：<strong>目前只能支持一主一从，如果是一主多从，并不能等待所有备库都接收到binlog，而是收到一个ack就返回给客户端。这样就不能完全保证不会出现过期读。</strong></p><h4 id="业务代码如何写避免过期读？"><a href="#业务代码如何写避免过期读？" class="headerlink" title="业务代码如何写避免过期读？"></a>业务代码如何写避免过期读？</h4><p>针对上节的介绍，我们可以通过判断位点和GTID集合，结合semi-sync半同步复制，判断一主多从不会出现过期读，那么在代码中如何操作实现？</p><h5 id="等主库位点"><a href="#等主库位点" class="headerlink" title="等主库位点"></a>等主库位点</h5><p>这里需要介绍一条数据库sql指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 这里file是master主库上的log文件名，pos是执行到的文件位点，timeout是超时时间</span><br><span class="line">-- 这个的返回表示，备库执行到主库的位点经历了多少个binlog，也就是执行了多少事务，如果返回为正整数，表示同步完成，返回-1表示失败，null表示发生了异常。</span><br><span class="line">select master_pos_wait(file, pos[, timeout]);</span><br></pre></td></tr></table></figure><p>1.更新代码完成之后，查询请求进来，先到master执行show master status，查到file 和pos。</p><p>2.任意选择一个备库，执行select master_pos_wait(file, pos[, timeout])。</p><p>3.如果返回正整数表示该备库已经同步完成，将查询在该备库中进行否则到强制到主库中执行。</p><h5 id="等主库GTID集合"><a href="#等主库GTID集合" class="headerlink" title="等主库GTID集合"></a>等主库GTID集合</h5><p>如果数据库开启了GTID模式，这里同样介绍一个指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--  gtid_set理解为一个字符串，不同于位点方式的是，更新操作完成之后这种方式会返回给客户端这个gtid，客户端在继续进行查询的时候只需要把这个gtid到备库进行判断。</span><br><span class="line">-- 该命令执行逻辑，1.等待，直到该备库中记录了执行该事务的id，返回0  2.超时返回-1，由业务决定走主库还是放弃。</span><br><span class="line">select wait_for_executed_gtid_set(gtid_set, 1);</span><br></pre></td></tr></table></figure><p>1.客户端执行在主库执行更新请求，更新事务提交成功，返回给客户端gtid。</p><p>2.客户端到备库通过拿到的gtid执行select wait_for_executed_gtid_set(gtid_set, 1)。</p><p>3.返回0，表示备库中已经有执行了这个更新事务，可以进行查询。</p><h5 id="等主库位点vs等主库GTID"><a href="#等主库位点vs等主库GTID" class="headerlink" title="等主库位点vs等主库GTID"></a>等主库位点vs等主库GTID</h5><p>相对等主库位点来说，等主库GTID方式减少了一次show master status的主库查询，对主库比较友好。但是GTID方案，如何让客户端的返回中包含事务执行的gtid？</p><ul><li><strong>需要将参数 session_track_gtids 设置为OWN_GTID，然后通过 API 接口mysql_session_track_get_first从返回包解析出 GTID 的值即可。</strong></li></ul><p><img src="http://arthornye.github.io/images/gtid.jpg" alt="cmd-markdown-logo"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本篇文章主要是介绍如何在数据库一主多从类似的读写分离的架构下要如何避免过期读。虽然我们发现GTID这种方式好像能够完全避免过期读，表现比较优秀，但是实际场景下我们还是多种方式混合使用。总之我们还是需要客户端去判断，当前的请求是否可以接受过期读，如果可以接受，那完全没有必要采用等待位点或者等待GTID的方案，否则无需采用。这些都需要在实际的业务场景中去检验和选择。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mysql在读写分离的场景下，可能是一主一从，一主都从。但是在实际应用场景中需要解决一个重要的问题就是&lt;strong&gt;“过期读”&lt;/strong&gt;。本篇主要介读写分离可能的架构方式以及如何解决该问题。&lt;/p&gt;
&lt;h4 id=&quot;强制从主库读取&quot;&gt;&lt;a href=&quot;#强制从主库
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql排序工作原理</title>
    <link href="http://jianghao.wang/2019/mysql%E6%8E%92%E5%BA%8F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://jianghao.wang/2019/mysql排序工作原理/</id>
    <published>2019-01-12T08:44:08.453Z</published>
    <updated>2019-01-12T14:46:45.470Z</updated>
    
    <content type="html"><![CDATA[<p>mysql排序主要针对order by指令，本篇主要介绍mysql是如何进行排序以及性能优化的。我们从全字段排序和rowid排序两种排序方式介绍，当然这两种排序都基于基本的排序算法，归并排序。归并排序主要应用于大文件排序，内存有限的情况下，先将文件分为多个有序的小文件，然后将小文件进行排序，时间复杂度nlogn，当然文件的存储形式还有io的时间消耗，这也是数据库性能优化的主要目标，尽量减少磁盘io。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `words` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `word` varchar(64) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=2800001 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><h4 id="全字段排序-vs-rowId排序"><a href="#全字段排序-vs-rowId排序" class="headerlink" title="全字段排序 vs rowId排序"></a>全字段排序 vs rowId排序</h4><p>顾名思义，全字段排序的意思是将记录的所有行都放到内存中进行排序，排序成功之后取固定的字段或者数量返回给客户端。mysql将所有的排序记录都优先考虑放在内存中，我们通过查询指令可以查到配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- sql query</span><br><span class="line">use souche_study;</span><br><span class="line">show variables like &quot;%sort%&quot;</span><br><span class="line"></span><br><span class="line">-- result</span><br><span class="line">innodb_disable_sort_file_cacheOFF</span><br><span class="line">innodb_ft_sort_pll_degree2</span><br><span class="line">innodb_sort_buffer_size1048576//innodb默认的排序大小</span><br><span class="line">max_length_for_sort_data1024</span><br><span class="line">max_sort_length1024</span><br><span class="line">myisam_max_sort_file_size9223372036853727232</span><br><span class="line">myisam_sort_buffer_size8388608</span><br><span class="line">sort_buffer_size262144 //默认的排序内存大小</span><br></pre></td></tr></table></figure><p>排序的过程如下：</p><p><img src="https://arthornye.github.io/images/orderby.jpg" alt="cmd-markdown-logo"></p><h4 id="analyze-table-命令"><a href="#analyze-table-命令" class="headerlink" title="analyze table 命令"></a>analyze table 命令</h4><p>检测和重组表的关键字分布情况。用来分析和存储表的关键字的分布，使得系统获得准确的统计信息。在执行查询计划的时候可能会错误估计要扫描的条数，导致应用不到索引，通过analyze table命令可以使估计值更加准确。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyze table table_name;//analyze+表名</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mysql排序主要针对order by指令，本篇主要介绍mysql是如何进行排序以及性能优化的。我们从全字段排序和rowid排序两种排序方式介绍，当然这两种排序都基于基本的排序算法，归并排序。归并排序主要应用于大文件排序，内存有限的情况下，先将文件分为多个有序的小文件，然后
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql加锁分析实践</title>
    <link href="http://jianghao.wang/2019/mysql%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90%E5%AE%9E%E8%B7%B5/"/>
    <id>http://jianghao.wang/2019/mysql加锁分析实践/</id>
    <published>2019-01-02T01:58:10.893Z</published>
    <updated>2019-01-22T01:53:39.684Z</updated>
    
    <content type="html"><![CDATA[<p>实践基于以下表结构，分析各个情况下加锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tablet` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  `d` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into t values(0,0,0),(5,5,5),</span><br><span class="line">(10,10,10),(15,15,15),(20,20,20),(25,25,25);</span><br></pre></td></tr></table></figure><h4 id="唯一主键加锁"><a href="#唯一主键加锁" class="headerlink" title="唯一主键加锁"></a>唯一主键加锁</h4><p>先执行session1，query ok :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line"> /*主键等值查询gap锁 */</span><br><span class="line">begin;</span><br><span class="line">select * from tablet where id=10 lock in share mode;</span><br></pre></td></tr></table></figure><p>再执行session2，query ok:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">/*可以正常插入判定没有gap锁，针对唯一索引优化*/</span><br><span class="line">insert into tablet values(9,8,8);</span><br></pre></td></tr></table></figure><p>再执行session3，query blocked：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">update tablet set c=11 where id =10;</span><br></pre></td></tr></table></figure><blockquote><p><strong>唯一主键等值查询不加gap间隙锁，只加对应值的行锁。</strong></p></blockquote><p>这里将session1换成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line"> /*主键范围查询gap锁 */</span><br><span class="line">begin;</span><br><span class="line">select * from tablet where id&gt;=10 and id&lt;15 lock in share mode;</span><br></pre></td></tr></table></figure><p>session2，query ok：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">insert into tablet values(16,8,8);</span><br></pre></td></tr></table></figure><p>session3，query blocked：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">/*gap锁*/</span><br><span class="line">insert into tablet values(12,8,8);</span><br></pre></td></tr></table></figure><p>session4，query blocked：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">/*这里范围查询会多加一个行锁，实际上会感觉比较多余,因为并没有筛选到这个值,但是从逻辑上理解在索引上扫描一个范围并不知道什么时候结束，所以会有多出来的一个行锁，可能为了不违背两阶段锁的协议*/</span><br><span class="line">update tablet set c =0 where id=15;</span><br></pre></td></tr></table></figure><p>这里如果我们将session1中id&lt;15加上一个等号条件也就是id&lt;=15，mysql后在id=20这行也加上锁，同时多了一个gap锁也就是多了一整个<strong>next key lock (15,20]</strong>，这是相当奇怪的 ，因为扫描到15的时候可以确定不再往后进行扫描。这种貌似可以优化的场景但是并没有进行优化。</p><p><strong>最终上面的test发现会加id为10记录的行锁+(10,15]的next key lock。总结下，mysql在唯一主键索引查询的条件为范围索引的条件下会默认向后多加一个next key lock，等值查询直加行锁。</strong></p><blockquote><p><strong>lock in share mode 这种方式只会在索引上加锁，在不回表的情况下不会锁主键索引记录。for update 的方式不管是否回表都会锁主键记录。</strong></p></blockquote><h4 id="唯一普通索引加范围锁"><a href="#唯一普通索引加范围锁" class="headerlink" title="唯一普通索引加范围锁"></a>唯一普通索引加范围锁</h4><p>唯一普通索引有独立的树结构，在加锁上跟主键的索引是有区别的，防止根据主键更新造成不一致读会加行锁。</p><p>将c修改为唯一索引，执行下面的session1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line"></span><br><span class="line">alter table tablet drop index c;</span><br><span class="line">alter table tablet add unique index c(c);</span><br><span class="line">show index from tablet;</span><br><span class="line"></span><br><span class="line">begin;</span><br><span class="line">/* 普通唯一索引加范围锁 */</span><br><span class="line">select * from tablet where c &gt;10 and c &lt;=15 lock in share mode;</span><br><span class="line">/* == select d from tablet where c &gt;10 and c&lt;=15 for update; */</span><br></pre></td></tr></table></figure><p>然后执行session2，query blocked :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">-- 唯一普通索引c加锁范围(10,15],(15,20]，跟上面保持一致，需要多扫描一行数据并加锁（虽然感觉完全没有必要），主键索引加id=15行锁。</span><br><span class="line">-- query ok c=21</span><br><span class="line">insert into tablet values(16,21,8);</span><br><span class="line">-- query blocked c=16 gap间隙锁 </span><br><span class="line">insert into tablet values(19,16,8);</span><br><span class="line">-- blocked c=15 行锁</span><br><span class="line">update tablet set d=111 where c=15;</span><br><span class="line">-- query ok，没有加锁，回表的时候做了优化</span><br><span class="line">update tablet set d=111 where id=20;</span><br><span class="line">-- blocked 加了行锁</span><br><span class="line">update tablet set d=111 where id=15;</span><br></pre></td></tr></table></figure><blockquote><p><strong>唯一索引范围锁搜索到不符合预期范围的第一个值，以该值为最终值进行加锁，上面的语句如果改成c&lt;15那么锁范围变成(10,15]。</strong></p></blockquote><h4 id="非唯一普通索引加范围锁"><a href="#非唯一普通索引加范围锁" class="headerlink" title="非唯一普通索引加范围锁"></a>非唯一普通索引加范围锁</h4><p>类比上面的情况多了一个next key lock，执行session1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">begin;</span><br><span class="line">-- select * from  tablet where d&gt;10 and d&lt;=15 for update;</span><br><span class="line">/* 非唯一索引加范围锁 */</span><br><span class="line">select * from tablet where d &gt;10 and d &lt;=15 lock in share mode;</span><br></pre></td></tr></table></figure><p>执行session2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">-- 同样的情况变成了非唯一索引，加锁情况一致(10,15]，(15,20]（这里并没有多加个间隙锁，作了优化），主键索引加id=15行锁</span><br><span class="line">-- query ok d=8</span><br><span class="line">insert into tablet values(11,8,8)</span><br><span class="line">-- query ok d=23</span><br><span class="line">insert  into tablet values(13,7,23);</span><br><span class="line">-- blocked  d=20行锁</span><br><span class="line">update tablet set c=22 where d=20;</span><br><span class="line">-- query blocked  d=16间隙锁</span><br><span class="line">insert into tablet values(14,16,16);</span><br><span class="line">-- query ok </span><br><span class="line">update tablet set c =24 where id =20;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><blockquote><p><strong>非唯一索引范围锁搜索到不符合预期范围的第一个值，以该值为最终值进行加锁，上面的语句如果改成c&lt;15那么锁范围变成(10,15]。这里并不会在右边多加间隙锁。</strong></p></blockquote><p>#### </p><h4 id="非唯一普通索引加范围锁倒序"><a href="#非唯一普通索引加范围锁倒序" class="headerlink" title="非唯一普通索引加范围锁倒序"></a>非唯一普通索引加范围锁倒序</h4><p>倒序排序默认会从后往前扫描索引，mysql默认多加一个间隙锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- session1</span><br><span class="line">use souche_study;</span><br><span class="line">begin;</span><br><span class="line">-- 锁了(5,10],(10,15],(15,20],(20,25)</span><br><span class="line">select * from tablet where d&gt;=15 and d&lt;=20 order by d desc lock in share mode;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- session2</span><br><span class="line">use souche_study;</span><br><span class="line">-- query ok</span><br><span class="line">update tablet set c=14 where d =25;</span><br><span class="line">-- blocked</span><br><span class="line">insert into tablet values(17,17,6);</span><br><span class="line">-- query ok</span><br><span class="line">update tablet set c = 18 where d=5;</span><br><span class="line">-- blocked 唯一索引不存在(20,25)间隙锁</span><br><span class="line">insert into tablet values(16,16,21);</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总结一下，分析加锁情况主要需要区分出唯一索引和非唯一索引。唯一索引是左半区或者右半区可能插入，非唯一索引是左右半区都可能插入。并且有几个原则和几个优化，原则：</p><blockquote><p>1.加锁的基本单位是next key lock，前开后闭区间。</p><p>2.mysql扫描到的对象才会进行加锁。</p></blockquote><p>优化：</p><blockquote><p>1.索引的唯一等值查询，next key lock退化为行锁。（非唯一等值查询不退化）</p><p>2.等值查询或者范围查询向右遍历到最后一个不符合期望的值，即使是非唯一索引也不会在该值的右侧加一个间隙锁。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实践基于以下表结构，分析各个情况下加锁：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql查询性能优化</title>
    <link href="http://jianghao.wang/2018/mysql%E6%9F%A5%E8%AF%A2%E6%A3%80%E7%B4%A2%E6%80%A7%E8%83%BD%E8%AF%AD%E5%8F%A5%E8%AE%B0%E5%BD%95/"/>
    <id>http://jianghao.wang/2018/mysql查询检索性能语句记录/</id>
    <published>2018-12-28T09:30:02.605Z</published>
    <updated>2019-01-10T01:53:54.447Z</updated>
    
    <content type="html"><![CDATA[<h4 id="查询长时间不返回"><a href="#查询长时间不返回" class="headerlink" title="查询长时间不返回"></a>查询长时间不返回</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.processlist;//这条语句跟下面的语句相同</span><br><span class="line">show processlist;//展示出当前的进程信息</span><br></pre></td></tr></table></figure><p>特殊的，在模拟一种MDL写锁阻塞的情况可以通过该命令查到阻塞的查询，这种情况一般第一时间执行该语句：</p><p>通过kill指令杀掉线程，恢复执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill 4;//kill pid,通过上面的命令查询到可以查询到对应线程的pid</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.innodb_locks;//可以查看死锁，注意锁等待信息不会在这里显示出来，除非发生死锁。包括gap锁和x锁可能导致的死锁等待，数据库开启了死锁等待机制可以检测死锁。</span><br></pre></td></tr></table></figure><h4 id="开启慢查询"><a href="#开启慢查询" class="headerlink" title="开启慢查询"></a>开启慢查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &quot;%query%&quot;</span><br></pre></td></tr></table></figure><p>result:</p><p><img src="https://arthornye.github.io/images/querylog.jpg" alt="cmd-markdown-logo"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 会在当前session立即生效</span><br><span class="line">set global slow_query_log=&apos;ON&apos;;</span><br><span class="line">-- 不会在当前的session生效，很坑，需要开启另一个session才会查询到设置效果</span><br><span class="line">set global long_query_time=0;</span><br></pre></td></tr></table></figure><p>截取一个slow log的记录结果：</p><p><img src="https://arthornye.github.io/images/slowlog.jpg" alt="cmd-markdown-logo"></p><h4 id="慢查询优化步骤"><a href="#慢查询优化步骤" class="headerlink" title="慢查询优化步骤"></a>慢查询优化步骤</h4><p>业务上有个审核表的表结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `audit_order` (</span><br><span class="line">  `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &apos;id&apos;,</span><br><span class="line">  `order_id` int(11) unsigned NOT NULL COMMENT &apos;销售订单号&apos;,</span><br><span class="line">  `order_code` varchar(32) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;订单中心订单号&apos;,</span><br><span class="line">  `user_id` varchar(32) DEFAULT NULL COMMENT &apos;申请人id&apos;,</span><br><span class="line">  `auditor_id` varchar(32) DEFAULT NULL COMMENT &apos;审核人id&apos;,</span><br><span class="line">  `status` tinyint(4) NOT NULL DEFAULT &apos;10&apos; COMMENT &apos;状态 10：待审核 20：审核通过 30：审核驳回 40：审核未通过&apos;,</span><br><span class="line">  `reject_reason` varchar(128) DEFAULT NULL COMMENT &apos;不通过原因&apos;,</span><br><span class="line">  `updater_id` varchar(32) DEFAULT &apos;&apos; COMMENT &apos;更新人&apos;,</span><br><span class="line">  `date_create` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &apos;创建时间&apos;,</span><br><span class="line">  `date_update` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &apos;更新时间&apos;,</span><br><span class="line">  `business_type` varchar(32) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `idx_order_id` (`order_id`),</span><br><span class="line">  KEY `idx_order_code` (`order_code`),</span><br><span class="line">  KEY `date_update` (`date_update`),</span><br><span class="line">  KEY `idx_date_create` (`date_create`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=50571 DEFAULT CHARSET=utf8 COMMENT=&apos;订单审核表&apos;;</span><br></pre></td></tr></table></figure><p>分析下面语句实际扫描的行数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, order_code, status, date_create, date_update</span><br><span class="line">, reject_reason</span><br><span class="line">FROM audit_order</span><br><span class="line">WHERE (business_type = &apos;CUSTOMIZED_CAR&apos;</span><br><span class="line">AND status IN (20)</span><br><span class="line">AND date_update &gt; &apos;2018-01-01&apos;)</span><br><span class="line">ORDER BY date_update</span><br><span class="line">LIMIT 100</span><br></pre></td></tr></table></figure><p>我们explain一下：</p><p><img src="https://arthornye.github.io/images/noindex.jpg" alt="cmd-markdown-logo"></p><p>这里分析显示的扫描行数rows是24786行，但是实际上我们通过慢查询日志发现，实际的扫描行数是接近五万行，接近两倍。using index condition表示通过date_update索引查询过滤到记录之后回表，执行时间在全表数据较少的情况下用了100ms，符合我们的预期：</p><p><img src="https://arthornye.github.io/images/noindexlog.jpg" alt="cmd-markdown-logo"></p><p>加一个索引，重新执行explain，并观察慢查询日志真实扫描行数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE audit_order</span><br><span class="line">ADD INDEX idx_type_status_date (status, business_type, date_update);</span><br></pre></td></tr></table></figure><p><img src="https://arthornye.github.io/images/useindex.jpg" alt="cmd-markdown-logo"></p><p><img src="https://arthornye.github.io/images/useindexlog.jpg" alt="cmd-markdown-logo"></p><p><strong>通常我们观察range级别是索引可用级别，但是实际的扫描行数还是需要参考explain的rows和日志中的rows_examinzed，其中explain是估计值，真正准确的还是rows_examinzed。</strong></p><h4 id="count-性能"><a href="#count-性能" class="headerlink" title="count(*)性能"></a>count(*)性能</h4><p>innnodb在统计行数的时候没有像myisam一样保存了行数，需要重新扫描一遍表。我们比较一下集中查询方式的性能。插入一个两百多万行的数据表word。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER ;;</span><br><span class="line">CREATE DEFINER=`root`@`localhost` PROCEDURE `inputdata`()</span><br><span class="line">begin</span><br><span class="line">  declare i int;</span><br><span class="line">  set i=1;</span><br><span class="line">  while(i&lt;=2800000)do</span><br><span class="line">    insert into words values(i,i);</span><br><span class="line">    set i=i+1;</span><br><span class="line">  end while;</span><br><span class="line">end;;</span><br><span class="line">DELIMITER ;</span><br><span class="line">call inputdata;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-- count(id)</span><br><span class="line"># Time: 2019-01-09T14:10:05.038579Z</span><br><span class="line"># User@Host: root[root] @ localhost []  Id:    14</span><br><span class="line"># Query_time: 0.349229  Lock_time: 0.000062 Rows_sent: 1  Rows_examined: 0</span><br><span class="line">SET timestamp=1547043005;</span><br><span class="line">select count(id) from words;</span><br><span class="line"></span><br><span class="line">-- count(1)</span><br><span class="line"># Time: 2019-01-09T14:10:02.488929Z</span><br><span class="line"># User@Host: root[root] @ localhost []  Id:    14</span><br><span class="line"># Query_time: 0.305565  Lock_time: 0.000060 Rows_sent: 1  Rows_examined: 0</span><br><span class="line">SET timestamp=1547043002;</span><br><span class="line">select count(1) from words;</span><br><span class="line"></span><br><span class="line">-- count(字段)</span><br><span class="line"># Time: 2019-01-09T14:09:56.943701Z</span><br><span class="line"># User@Host: root[root] @ localhost []  Id:    14</span><br><span class="line"># Query_time: 0.544218  Lock_time: 0.000066 Rows_sent: 1  Rows_examined: 2709998</span><br><span class="line">SET timestamp=1547042996;</span><br><span class="line">select count(word) from words;</span><br><span class="line"></span><br><span class="line">-- count(*)</span><br><span class="line"># Time: 2019-01-09T14:09:59.196291Z</span><br><span class="line"># User@Host: root[root] @ localhost []  Id:    14</span><br><span class="line"># Query_time: 0.301123  Lock_time: 0.000057 Rows_sent: 1  Rows_examined: 0</span><br><span class="line">SET timestamp=1547042999;</span><br><span class="line">select count(*) from words;</span><br></pre></td></tr></table></figure><p>结论：<strong>count(*)约等于count(1)&gt;count(id)&gt;count(字段)，推荐使用前三个</strong>，count字段有磁盘io，会把字段的值取出来，进行判断是否为null值。通常我们通过innodb的事务性特征，将总记录条数在一个事务中去取，mysql即使在异常情况下也不会导致数据不一致。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;查询长时间不返回&quot;&gt;&lt;a href=&quot;#查询长时间不返回&quot; class=&quot;headerlink&quot; title=&quot;查询长时间不返回&quot;&gt;&lt;/a&gt;查询长时间不返回&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>react学习</title>
    <link href="http://jianghao.wang/2018/React%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianghao.wang/2018/React学习/</id>
    <published>2018-12-17T11:01:38.088Z</published>
    <updated>2019-01-09T13:28:16.746Z</updated>
    
    <content type="html"><![CDATA[<h4 id="setState异步执行"><a href="#setState异步执行" class="headerlink" title="setState异步执行"></a>setState异步执行</h4><p>在实践的过程中发现一个奇怪的现象，我们如果先进行setState在进行网络请求，那么网络请求很可能提前进行，也就是setState是异步的，正确的同步写法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">onPageChange = (page) =&gt; &#123;</span><br><span class="line">       if(this.state.isSaleOrder)&#123;</span><br><span class="line">           this.setState(&#123;</span><br><span class="line">               sale_page:page,</span><br><span class="line">           &#125;,() =&gt;&#123;//这要采用回调的方式，更新完state再继续进行网络请求，不然会造成异常情况</span><br><span class="line">               this.getOrderManageList();</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           this.setState(&#123;</span><br><span class="line">               purchase_page:page,</span><br><span class="line">           &#125;,() =&gt;&#123;</span><br><span class="line">               this.getOrderManageList();</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="div设置不可见"><a href="#div设置不可见" class="headerlink" title="div设置不可见"></a>div设置不可见</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;display</span> <span class="attr">:</span> <span class="attr">this.state.reject</span>&#125;&#125;&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Form</span> <span class="attr">layout</span>=<span class="string">"inline"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FormItem</span> <span class="attr">label</span>=<span class="string">"审核打回时间段筛选"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">RangePicker</span> <span class="attr">placeholder</span>=<span class="string">&#123;[</span> "开始时间", "结束时间"]&#125; <span class="attr">onChange</span>=<span class="string">&#123;(data)</span>=&gt;</span>&#123; this.state.rejectStartTime = data[0]; this.state.rejectEndTime = data[1] &#125;&#125; /&gt;<span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FormItem</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">type</span>=<span class="string">"primary"</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>this.getAuditList()&#125;&gt; 筛选<span class="tag">&lt;/<span class="name">Button</span>&gt;</span><span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以通过设置<strong>display:’none’</strong>不显示当前div，通过设置<strong>display:’block’</strong>显示当前div。</p><h4 id="通过Form设置组件布局"><a href="#通过Form设置组件布局" class="headerlink" title="通过Form设置组件布局"></a>通过Form设置组件布局</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginTop:</span> <span class="attr">24</span> &#125;&#125;&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Form</span> <span class="attr">layout</span>=<span class="string">"inline"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FormItem</span> <span class="attr">label</span>=<span class="string">"请选择业务类型:"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Select</span> <span class="attr">defaultValue</span>=<span class="string">"全部"</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width:</span> <span class="attr">120</span> &#125;&#125; <span class="attr">onChange</span>=<span class="string">&#123;this.onChangeBusinessType&#125;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Option</span> <span class="attr">value</span>=<span class="string">"ALL"</span>&gt;</span>全部<span class="tag">&lt;/<span class="name">Option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Option</span> <span class="attr">value</span>=<span class="string">"COMMON_NEW_RETAIL"</span>&gt;</span>普通订单<span class="tag">&lt;/<span class="name">Option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Option</span> <span class="attr">value</span>=<span class="string">"CUSTOMIZED_CAR"</span>&gt;</span>定制车订单<span class="tag">&lt;/<span class="name">Option</span>&gt;</span><span class="tag">&lt;/<span class="name">Select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过<strong>label:””</strong>设置左边的显示tab。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;setState异步执行&quot;&gt;&lt;a href=&quot;#setState异步执行&quot; class=&quot;headerlink&quot; title=&quot;setState异步执行&quot;&gt;&lt;/a&gt;setState异步执行&lt;/h4&gt;&lt;p&gt;在实践的过程中发现一个奇怪的现象，我们如果先进行setSta
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
</feed>
