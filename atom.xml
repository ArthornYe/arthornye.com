<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TizzyT&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/9dde1b9d65b89035e235650923e5811e</icon>
  <subtitle>即使是拖后腿的，拼死努力的话，也是可以超越精英的。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jianghao.wang/"/>
  <updated>2019-01-29T09:25:36.421Z</updated>
  <id>http://jianghao.wang/</id>
  
  <author>
    <name>yeqiaozhu</name>
    <email>yqz_zjut@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 8中异步处理</title>
    <link href="http://jianghao.wang/2019/Java-8%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/"/>
    <id>http://jianghao.wang/2019/Java-8异步处理/</id>
    <published>2019-01-29T06:11:08.722Z</published>
    <updated>2019-01-29T09:25:36.421Z</updated>
    
    <content type="html"><![CDATA[<p>Java8中提供了CompletableFeature工具，提供了一系列基于函数式的api。本篇主要介绍这些api的使用以及源码实现。</p><h4 id="CompletableFeature-supplyAsyc"><a href="#CompletableFeature-supplyAsyc" class="headerlink" title="CompletableFeature.supplyAsyc()"></a>CompletableFeature.supplyAsyc()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.输入一个supplier函数，输出一个CompletableFeature&lt;U&gt;引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(asyncPool, supplier);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.传入一个线程池，一个supplier函数，输出一个CompletableFeature&lt;U&gt;引用</span></span><br><span class="line"><span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">asyncSupplyStage</span><span class="params">(Executor e,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 Supplier&lt;U&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    CompletableFuture&lt;U&gt; d = <span class="keyword">new</span> CompletableFuture&lt;U&gt;();</span><br><span class="line">    <span class="comment">//异步调用之后执行return d</span></span><br><span class="line">    e.execute(<span class="keyword">new</span> AsyncSupply&lt;U&gt;(d, f));</span><br><span class="line">    <span class="comment">//主线程直接返回创建的对象</span></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.线程池中线程异步执行supplier函数</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncSupply</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">Void</span>&gt;</span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">AsynchronousCompletionTask</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;T&gt; dep; Supplier&lt;T&gt; fn;</span><br><span class="line">        <span class="comment">//初始化时用主线程CompletableFeature对象引用</span></span><br><span class="line">        AsyncSupply(CompletableFuture&lt;T&gt; dep, Supplier&lt;T&gt; fn) &#123;</span><br><span class="line">            <span class="keyword">this</span>.dep = dep; <span class="keyword">this</span>.fn = fn;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Void <span class="title">getRawResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRawResult</span><span class="params">(Void v)</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123; run(); <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里的 d引用==线程初始化对象引用dep==主线程对象引用</span></span><br><span class="line">            CompletableFuture&lt;T&gt; d; Supplier&lt;T&gt; f;</span><br><span class="line">            <span class="keyword">if</span> ((d = dep) != <span class="keyword">null</span> &amp;&amp; (f = fn) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                dep = <span class="keyword">null</span>; fn = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (d.result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//异步线程内部同步执行supplier函数，f.get返回类型和泛型类型保持一致</span></span><br><span class="line">                        d.completeValue(f.get());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="comment">//发生异常将异常作为结果对象</span></span><br><span class="line">                        d.completeThrowable(ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                d.postComplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//4.d.completeValue通过unsafe cas替换，到这里异步线程执行完成并将执行结果记录在volatile object result对象中</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">completeValue</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//入参this（object1），result（volatile object类型），null（拷贝旧值），t（返回新值）</span></span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, RESULT, <span class="keyword">null</span>,(t == <span class="keyword">null</span>) ? NIL : t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5.这里的RESULT</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"><span class="comment">// 为什么是long类型，暂时理解为内存地址吧。。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RESULT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> STACK;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> NEXT;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> sun.misc.Unsafe u;</span><br><span class="line">        UNSAFE = u = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k = CompletableFuture.class;</span><br><span class="line">        <span class="comment">//获取声明字段的内存地址</span></span><br><span class="line">        RESULT = u.objectFieldOffset(k.getDeclaredField(<span class="string">"result"</span>));</span><br><span class="line">        STACK = u.objectFieldOffset(k.getDeclaredField(<span class="string">"stack"</span>));</span><br><span class="line">        NEXT = u.objectFieldOffset</span><br><span class="line">            (Completion.class.getDeclaredField(<span class="string">"next"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception x) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程循环等待 volatile object result返回<strong>CompletableFeature.get()。</strong>同时可以设置超时时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">waitingGet</span><span class="params">(<span class="keyword">boolean</span> interruptible)</span> </span>&#123;</span><br><span class="line">        Signaller q = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> spins = -<span class="number">1</span>;</span><br><span class="line">        Object r;</span><br><span class="line">    <span class="comment">//就这一句判断，反正就是不给我我就循环，占着cpu，你说难受不难受，如果不设置超时时间异步线程不返回，就死循环卡着了，是不是很伤。内部应该处理了一些什么东西，避免死循环占用cpu，可以换成阻塞式，让出cpu。</span></span><br><span class="line">        <span class="keyword">while</span> ((r = result) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)</span><br><span class="line">                spins = (Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span>) ?</span><br><span class="line">                    <span class="number">1</span> &lt;&lt; <span class="number">8</span> : <span class="number">0</span>; <span class="comment">// Use brief spin-wait on multiprocessors</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ThreadLocalRandom.nextSecondarySeed() &gt;= <span class="number">0</span>)</span><br><span class="line">                    --spins;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里之前死循环，spins == 1&lt;&lt;8 === 256 次，进行256次死循环。检查result，如果这段时间没有返回。执行到下面的代码。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">                q = <span class="keyword">new</span> Signaller(interruptible, <span class="number">0L</span>, <span class="number">0L</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">                <span class="comment">//这里会进入然后一直阻塞，让出cpu，知道result返回之后才返回继续执行一次循环，然后退出循环。</span></span><br><span class="line">                queued = tryPushStack(q);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (interruptible &amp;&amp; q.interruptControl &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                q.thread = <span class="keyword">null</span>;</span><br><span class="line">                cleanStack();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q.thread != <span class="keyword">null</span> &amp;&amp; result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ForkJoinPool.managedBlock(q);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    q.interruptControl = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span>) &#123;</span><br><span class="line">            q.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (q.interruptControl &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (interruptible)</span><br><span class="line">                    r = <span class="keyword">null</span>; <span class="comment">// report interruption</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        postComplete();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>附上流程图吧：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java8中提供了CompletableFeature工具，提供了一系列基于函数式的api。本篇主要介绍这些api的使用以及源码实现。&lt;/p&gt;
&lt;h4 id=&quot;CompletableFeature-supplyAsyc&quot;&gt;&lt;a href=&quot;#CompletableFeatu
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>mysql大查询内存策略</title>
    <link href="http://jianghao.wang/2019/mysql%E5%A4%A7%E6%9F%A5%E8%AF%A2%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5/"/>
    <id>http://jianghao.wang/2019/mysql大查询内存策略/</id>
    <published>2019-01-28T02:15:11.571Z</published>
    <updated>2019-01-28T05:50:13.068Z</updated>
    
    <content type="html"><![CDATA[<p>mysql在处理大查询的时候需要有自己的内存策略，保证不会出现OOM（Out Of Memory）内存泄漏。我们从server层面和引擎层面剖析一下内存策略。</p><h4 id="server层处理大查询"><a href="#server层处理大查询" class="headerlink" title="server层处理大查询"></a>server层处理大查询</h4><p>server层对大查询的处理，这里针对的大查询是返回的数据量巨大。针对这种查询server层会采用<strong>边读边发</strong>策略。也就是数据由客户端分阶段整合，服务端并不需要保证一个完整的结果集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查看net_buffer_length参数，服务端会先将数据存到这个内存区域，存满之后向客户端发送，不断重复。</span><br><span class="line">show variables like &quot;net_buffer_%&quot;</span><br><span class="line">-- 结果,默认16k大小</span><br><span class="line">net_buffer_length16384</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- show processlist,在大查询执行的过程中，语句会处于sending client data的状态</span><br><span class="line">show processlist;</span><br><span class="line">-- status ，语句的对应状态，如果发现有语句处于这种状态，需要业务方确认是否需要返回如此多的信息。尽量进行优化。</span><br><span class="line">sending client data`</span><br></pre></td></tr></table></figure><p>边读边发：</p><ul><li>1.服务端从磁盘中读取数据加入net_buffer_length内存中。默认16k。</li><li>2.net_buffer_length满，触发发送到客户端操作。</li><li>3.收到Socket Send Buffer结果为发送成功，清空net_buffer_length，重新读取。</li><li>4.如果Socket Send Buffer返回EAGAIN 或 WSAEWOULDBLOCK，表示Socket Send Buffer已满，进入等待直到重新可写。</li></ul><p><img src="http://arthornye.github.io/images/bigquery.jpg" alt="cmd-markdown-logo"></p><h4 id="Innodb处理大查询"><a href="#Innodb处理大查询" class="headerlink" title="Innodb处理大查询"></a>Innodb处理大查询</h4><p>大家都知道Innodb在执行查询的之后都会将sql和对应的数据页，放置在内存中，也就是<strong>Innodb buffer pool size</strong>，这个内存区域我们之前有介绍可以通过redo log减少随机写操作，以及change buffer来减少随机读操作。但是在大查询的情况下会面对哪些问题，先看这个区域采用的<strong>LRU算法（最近最少使用算法）</strong>。</p><ul><li>1.最近最少使用算法采用链表，以一个数据页为单位P1，P2…</li><li>2.从磁盘中读出一个页Pn会放置在链表的头部。</li><li>3.访问到某个数据页Px，先返回客户端结果，然后将该页放置到链表的头部。</li><li>4.当Innodb buffer pool size已经满了，取一个最旧的页，删除数据，存入新数据并将其放置到头部。</li></ul><p><img src="http://arthornye.github.io/images/pagelink.jpg" alt="cmd-markdown-logo"></p><p>针对大查询的场景，如果不断查询出新的数据，单纯采用<strong>LRU算法（最近最少使用）</strong>查询出来的新页会直接替换老页，导致正常的业务内存缓存会被替换掉，增加了磁盘IO，而这些新增的缓存页在第一次使用之后又不会再进行使用。这种场景Innodb<strong>针对LRU做了分代优化，将这个buffer区域按照5:3划分为young和old区。这个概念其实在垃圾回收机制的分代收集的场景类似。针对不同的生命周期定制不同的淘汰方案。</strong></p><p><img src="http://arthornye.github.io/images/youngold.jpg" alt="cmd-markdown-logo"></p><p>需要注意的是，<strong>分代的主要目的还是基于提高内存命中率。</strong></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>mysql针对大查询通过server层进行边读边写的操作防止内存泄漏，如果出现sending client data并且时间特别长的情况下，可以尝试调整net_buffer_length参数。但是还是需要通过业务这边减少查询的数据量来进行优化改善。</p><p>Innodb通过Innodb_buffer_pool_size内存来进行数据页的缓存，大查询可能导致不经常使用的数据页占领这个buffer区域导致其他的查询性能下降。<strong>LRU算法（最近最少使用）基础上的分代算法的改进可以保证正常业务和大查询业务的平衡</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mysql在处理大查询的时候需要有自己的内存策略，保证不会出现OOM（Out Of Memory）内存泄漏。我们从server层面和引擎层面剖析一下内存策略。&lt;/p&gt;
&lt;h4 id=&quot;server层处理大查询&quot;&gt;&lt;a href=&quot;#server层处理大查询&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>消息队列基本介绍</title>
    <link href="http://jianghao.wang/2019/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    <id>http://jianghao.wang/2019/消息队列基本介绍/</id>
    <published>2019-01-25T01:51:12.709Z</published>
    <updated>2019-01-25T02:09:58.672Z</updated>
    
    <content type="html"><![CDATA[<h4 id="主流的消息队列中间件"><a href="#主流的消息队列中间件" class="headerlink" title="主流的消息队列中间件"></a>主流的消息队列中间件</h4><table><br><tr><br>    <th>消息队列\特点</th><br>    <th>优点</th><br>    <th>缺点</th><br></tr><br><tr><br>    <th>ActiveMQ</th><br>    <th>老牌的消息中间件，功能强大。</th><br>    <th>没法确认ActiveMQ可以支撑互联网公司的高并发、高负载以及高吞吐的复杂场景，在国内互联网公司落地较少，多用于异步调用和系统解耦。</th><br></tr><br><tr><br>    <th>RabbitMQ</th><br>    <th>高并发，高吞吐，性能很高，后台管理系统很便捷，开源社区非常活跃。</th><br>    <th>基于erlang开发，较难进行二次开发。</th><br></tr><br><tr><br>    <th>RocketMQ</th><br>    <th>阿里开源，基于java，高并发，高吞吐，支持分布式。</th><br>    <th>未知。</th><br></tr><br></table><h4 id="消息中间件的主要作用"><a href="#消息中间件的主要作用" class="headerlink" title="消息中间件的主要作用"></a>消息中间件的主要作用</h4><h5 id="系统解耦"><a href="#系统解耦" class="headerlink" title="系统解耦"></a>系统解耦</h5><p>将消息存放到消息中间件，避免大量的系统直接调用，可以由被调用方自行进行消费。调用方不用关心结果，代码解耦合。</p><h5 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h5><p>调用链路比较长的情况下，通过消息异步调用减少接口调用时长，防止超时或者等待时间过长。</p><h5 id="流量削减"><a href="#流量削减" class="headerlink" title="流量削减"></a>流量削减</h5><p>在短时间大流量的情况下，需要进行限流，作为后端集群的负载，生产者可以不断生成消息，但是后端集群只会定量消费。保护了后台系统的稳定性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;主流的消息队列中间件&quot;&gt;&lt;a href=&quot;#主流的消息队列中间件&quot; class=&quot;headerlink&quot; title=&quot;主流的消息队列中间件&quot;&gt;&lt;/a&gt;主流的消息队列中间件&lt;/h4&gt;&lt;table&gt;&lt;br&gt;&lt;tr&gt;&lt;br&gt;    &lt;th&gt;消息队列\特点&lt;/th&gt;&lt;b
      
    
    </summary>
    
    
      <category term="消息队列" scheme="http://jianghao.wang/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>sql操作记录</title>
    <link href="http://jianghao.wang/2019/sql%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
    <id>http://jianghao.wang/2019/sql操作记录/</id>
    <published>2019-01-24T07:21:00.479Z</published>
    <updated>2019-01-24T07:25:52.197Z</updated>
    
    <content type="html"><![CDATA[<p>主要记录一些sql的订正的操作。</p><h4 id="insert操作无需指定自增id"><a href="#insert操作无需指定自增id" class="headerlink" title="insert操作无需指定自增id"></a>insert操作无需指定自增id</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- insert的时候指定一个列表</span><br><span class="line">insert into error_level_conf (biz_type,error_type,error_level,handle_num_limit) value(&quot;general_b2C&quot;,&quot;CREATE_COUPON_PAYMENT&quot;,1,10);</span><br></pre></td></tr></table></figure><h4 id="从一个表拷贝数据到另一个表并订正"><a href="#从一个表拷贝数据到另一个表并订正" class="headerlink" title="从一个表拷贝数据到另一个表并订正"></a>从一个表拷贝数据到另一个表并订正</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- retail_coupon.eticket_status 已经落表的数据直接已登账的状态，定金支付完成的订单状态为已分账，这里关联订单表状态150的为已登账，大于150为已分账</span><br><span class="line">-- retail_marketing_order.entry_status 和retail_marketing_order.split_account_status中台不使用，订正到已登账和已分账状态</span><br><span class="line"></span><br><span class="line">INSERT INTO retail_coupon (retail_order_code, eticket_status, tmall_order_id, coupon_type, step_no</span><br><span class="line">, disburse_fee, discount_price, delete_mark, tmall_sku_id, date_create</span><br><span class="line">, date_update, business_type, discount_stage, entry_status, split_account_status)</span><br><span class="line">SELECT t1.retail_order_code</span><br><span class="line">, (</span><br><span class="line">SELECT CASE t2.order_status</span><br><span class="line">WHEN 150 THEN 3</span><br><span class="line">ELSE 4</span><br><span class="line">END</span><br><span class="line">), t1.tmail_order_id, 1, t1.step_count, t1.disburse_fee</span><br><span class="line">, t1.voucher_price, t1.deleted, t1.sku_id, t1.date_create, t1.date_update</span><br><span class="line">, &apos;distributor&apos;, &apos;retainge&apos;, 50, 50</span><br><span class="line">FROM retail_marketing_order t1</span><br><span class="line">LEFT JOIN retail_order t2 ON convert(t1.retail_order_code USING utf8) = t2.order_code;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要记录一些sql的订正的操作。&lt;/p&gt;
&lt;h4 id=&quot;insert操作无需指定自增id&quot;&gt;&lt;a href=&quot;#insert操作无需指定自增id&quot; class=&quot;headerlink&quot; title=&quot;insert操作无需指定自增id&quot;&gt;&lt;/a&gt;insert操作无需指定自增
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>如何处理读写分离</title>
    <link href="http://jianghao.wang/2019/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    <id>http://jianghao.wang/2019/如何处理读写分离/</id>
    <published>2019-01-16T03:09:54.910Z</published>
    <updated>2019-01-19T09:28:21.685Z</updated>
    
    <content type="html"><![CDATA[<p>mysql在读写分离的场景下，可能是一主一从，一主都从。但是在实际应用场景中需要解决一个重要的问题就是<strong>“过期读”</strong>。本篇主要介读写分离可能的架构方式以及如何解决该问题。</p><h4 id="强制从主库读取"><a href="#强制从主库读取" class="headerlink" title="强制从主库读取"></a>强制从主库读取</h4><h5 id="及时查询vs非及时查询"><a href="#及时查询vs非及时查询" class="headerlink" title="及时查询vs非及时查询"></a>及时查询vs非及时查询</h5><p>针对某些必须保证正确读的场景，我们可以设置这个请求只能走主库，例如一个场景，商家在发布了商品之后需要立即看到商品的信息，那么这个我们可以直接从主库去读。同样的场景，买家在前端去看新发布的商品时可能并不需要这么及时，可以容忍有一定时间的延迟，那么这个查询比较适合走从库。这里我们将查询分为两类：<strong>及时查询和非及时查询。</strong></p><ul><li>优点：逻辑上比较简单，易于实现和区分</li><li>缺点：可能会面临所有的查询都是及时查询的情况，例如一些金融系统对及时性要求很高。</li></ul><h5 id="及时查询优化"><a href="#及时查询优化" class="headerlink" title="及时查询优化"></a>及时查询优化</h5><p>即使是刚才讲到的可能面对的及时查询的情况，查询的时效性很高。为了减少主库的查询压力，我们可以让前端直接去跳转，看起来做了查询但是实际上没有查询。上架了商品之后直接将上架的商品信息展示在商品栏，减少了一次查询主库的压力。</p><p>实际上我们在应用中经常会采取强制从主库读取这种方式，但是很可能面对尴尬的场景。整个系统对时效性要求都比较高的时候，而又必须通过读写分离改善的场景下，可以如何解决<strong>过期读</strong>的问题？</p><h4 id="判断主备延迟"><a href="#判断主备延迟" class="headerlink" title="判断主备延迟"></a>判断主备延迟</h4><p>每次在备库执行查询请求之前，先判断下主备是否有延迟。可以通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status;</span><br></pre></td></tr></table></figure><h5 id="seconds-behind-master"><a href="#seconds-behind-master" class="headerlink" title="seconds_behind_master"></a>seconds_behind_master</h5><p>判断seconds_behind_master，通过show slave status可以在从库上查看到这个参数，如果seconds_behind_master</p><p>为零，可以走从库进行查询。缺点是精度比较难保证。</p><h5 id="对比位点和GTID集合"><a href="#对比位点和GTID集合" class="headerlink" title="对比位点和GTID集合"></a>对比位点和GTID集合</h5><p>在备库执行show slave status可以看到备库的位点和GTID集合的状态：</p><p><img src="http://arthornye.github.io/images/poslog.jpg" alt="cmd-markdown-logo"></p><ul><li><strong>Master_Log_File == Relay_Master_Log_File  &amp;&amp; Read_    Master_Log_Pos == Exec_Master_log_File  为true，表明备库已经完成接收到的主库的binlog同步。此为对比位点。</strong></li><li><strong>Retrieved_Gtid_Set(接收到的集合) == Executed_Gtid_Set(已经执行了的集合) 为true表明备库已经完成接受到的主binlog的同步。此为对比GTID。Auto_Position=1 ，表示这对主备关系使用了 GTID协议。</strong></li></ul><p>虽然这种方式都可以保证备库已经执行完了主库存传过来的binlog，但是因为binlog的传送这个过程相对客户端是异步的，那么客户端在收到更新成功的一条语句之后，这个语句可能还没有传送到备库。</p><p><img src="http://arthornye.github.io/images/asynclog.jpg" alt="cmd-markdown-logo"></p><p>这里需要引入<strong>半同步复制semi-sync</strong>:</p><ul><li>1.主库的事务提交之后，向备库发一个binlog，注意这里先不返回客户端更新成功。</li><li>2.备库收到binlog之后，向主库发一个ack，表示收到了这个binlog。</li><li>3.主库收到备库的ack之后，向客户端返回更新成功。</li></ul><p>semi-sync缺陷：<strong>目前只能支持一主一从，如果是一主多从，并不能等待所有备库都接收到binlog，而是收到一个ack就返回给客户端。这样就不能完全保证不会出现过期读。</strong></p><h4 id="业务代码如何写避免过期读？"><a href="#业务代码如何写避免过期读？" class="headerlink" title="业务代码如何写避免过期读？"></a>业务代码如何写避免过期读？</h4><p>针对上节的介绍，我们可以通过判断位点和GTID集合，结合semi-sync半同步复制，判断一主多从不会出现过期读，那么在代码中如何操作实现？</p><h5 id="等主库位点"><a href="#等主库位点" class="headerlink" title="等主库位点"></a>等主库位点</h5><p>这里需要介绍一条数据库sql指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 这里file是master主库上的log文件名，pos是执行到的文件位点，timeout是超时时间</span><br><span class="line">-- 这个的返回表示，备库执行到主库的位点经历了多少个binlog，也就是执行了多少事务，如果返回为正整数，表示同步完成，返回-1表示失败，null表示发生了异常。</span><br><span class="line">select master_pos_wait(file, pos[, timeout]);</span><br></pre></td></tr></table></figure><p>1.更新代码完成之后，查询请求进来，先到master执行show master status，查到file 和pos。</p><p>2.任意选择一个备库，执行select master_pos_wait(file, pos[, timeout])。</p><p>3.如果返回正整数表示该备库已经同步完成，将查询在该备库中进行否则到强制到主库中执行。</p><h5 id="等主库GTID集合"><a href="#等主库GTID集合" class="headerlink" title="等主库GTID集合"></a>等主库GTID集合</h5><p>如果数据库开启了GTID模式，这里同样介绍一个指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--  gtid_set理解为一个字符串，不同于位点方式的是，更新操作完成之后这种方式会返回给客户端这个gtid，客户端在继续进行查询的时候只需要把这个gtid到备库进行判断。</span><br><span class="line">-- 该命令执行逻辑，1.等待，直到该备库中记录了执行该事务的id，返回0  2.超时返回-1，由业务决定走主库还是放弃。</span><br><span class="line">select wait_for_executed_gtid_set(gtid_set, 1);</span><br></pre></td></tr></table></figure><p>1.客户端执行在主库执行更新请求，更新事务提交成功，返回给客户端gtid。</p><p>2.客户端到备库通过拿到的gtid执行select wait_for_executed_gtid_set(gtid_set, 1)。</p><p>3.返回0，表示备库中已经有执行了这个更新事务，可以进行查询。</p><h5 id="等主库位点vs等主库GTID"><a href="#等主库位点vs等主库GTID" class="headerlink" title="等主库位点vs等主库GTID"></a>等主库位点vs等主库GTID</h5><p>相对等主库位点来说，等主库GTID方式减少了一次show master status的主库查询，对主库比较友好。但是GTID方案，如何让客户端的返回中包含事务执行的gtid？</p><ul><li><strong>需要将参数 session_track_gtids 设置为OWN_GTID，然后通过 API 接口mysql_session_track_get_first从返回包解析出 GTID 的值即可。</strong></li></ul><p><img src="http://arthornye.github.io/images/gtid.jpg" alt="cmd-markdown-logo"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本篇文章主要是介绍如何在数据库一主多从类似的读写分离的架构下要如何避免过期读。虽然我们发现GTID这种方式好像能够完全避免过期读，表现比较优秀，但是实际场景下我们还是多种方式混合使用。总之我们还是需要客户端去判断，当前的请求是否可以接受过期读，如果可以接受，那完全没有必要采用等待位点或者等待GTID的方案，否则无需采用。这些都需要在实际的业务场景中去检验和选择。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mysql在读写分离的场景下，可能是一主一从，一主都从。但是在实际应用场景中需要解决一个重要的问题就是&lt;strong&gt;“过期读”&lt;/strong&gt;。本篇主要介读写分离可能的架构方式以及如何解决该问题。&lt;/p&gt;
&lt;h4 id=&quot;强制从主库读取&quot;&gt;&lt;a href=&quot;#强制从主库
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql排序工作原理</title>
    <link href="http://jianghao.wang/2019/mysql%E6%8E%92%E5%BA%8F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://jianghao.wang/2019/mysql排序工作原理/</id>
    <published>2019-01-12T08:44:08.453Z</published>
    <updated>2019-01-12T14:46:45.470Z</updated>
    
    <content type="html"><![CDATA[<p>mysql排序主要针对order by指令，本篇主要介绍mysql是如何进行排序以及性能优化的。我们从全字段排序和rowid排序两种排序方式介绍，当然这两种排序都基于基本的排序算法，归并排序。归并排序主要应用于大文件排序，内存有限的情况下，先将文件分为多个有序的小文件，然后将小文件进行排序，时间复杂度nlogn，当然文件的存储形式还有io的时间消耗，这也是数据库性能优化的主要目标，尽量减少磁盘io。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `words` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `word` varchar(64) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=2800001 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><h4 id="全字段排序-vs-rowId排序"><a href="#全字段排序-vs-rowId排序" class="headerlink" title="全字段排序 vs rowId排序"></a>全字段排序 vs rowId排序</h4><p>顾名思义，全字段排序的意思是将记录的所有行都放到内存中进行排序，排序成功之后取固定的字段或者数量返回给客户端。mysql将所有的排序记录都优先考虑放在内存中，我们通过查询指令可以查到配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- sql query</span><br><span class="line">use souche_study;</span><br><span class="line">show variables like &quot;%sort%&quot;</span><br><span class="line"></span><br><span class="line">-- result</span><br><span class="line">innodb_disable_sort_file_cacheOFF</span><br><span class="line">innodb_ft_sort_pll_degree2</span><br><span class="line">innodb_sort_buffer_size1048576//innodb默认的排序大小</span><br><span class="line">max_length_for_sort_data1024</span><br><span class="line">max_sort_length1024</span><br><span class="line">myisam_max_sort_file_size9223372036853727232</span><br><span class="line">myisam_sort_buffer_size8388608</span><br><span class="line">sort_buffer_size262144 //默认的排序内存大小</span><br></pre></td></tr></table></figure><p>排序的过程如下：</p><p><img src="https://arthornye.github.io/images/orderby.jpg" alt="cmd-markdown-logo"></p><h4 id="analyze-table-命令"><a href="#analyze-table-命令" class="headerlink" title="analyze table 命令"></a>analyze table 命令</h4><p>检测和重组表的关键字分布情况。用来分析和存储表的关键字的分布，使得系统获得准确的统计信息。在执行查询计划的时候可能会错误估计要扫描的条数，导致应用不到索引，通过analyze table命令可以使估计值更加准确。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyze table table_name;//analyze+表名</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mysql排序主要针对order by指令，本篇主要介绍mysql是如何进行排序以及性能优化的。我们从全字段排序和rowid排序两种排序方式介绍，当然这两种排序都基于基本的排序算法，归并排序。归并排序主要应用于大文件排序，内存有限的情况下，先将文件分为多个有序的小文件，然后
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql加锁分析实践</title>
    <link href="http://jianghao.wang/2019/mysql%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90%E5%AE%9E%E8%B7%B5/"/>
    <id>http://jianghao.wang/2019/mysql加锁分析实践/</id>
    <published>2019-01-02T01:58:10.893Z</published>
    <updated>2019-01-22T01:53:39.684Z</updated>
    
    <content type="html"><![CDATA[<p>实践基于以下表结构，分析各个情况下加锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tablet` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  `d` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into t values(0,0,0),(5,5,5),</span><br><span class="line">(10,10,10),(15,15,15),(20,20,20),(25,25,25);</span><br></pre></td></tr></table></figure><h4 id="唯一主键加锁"><a href="#唯一主键加锁" class="headerlink" title="唯一主键加锁"></a>唯一主键加锁</h4><p>先执行session1，query ok :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line"> /*主键等值查询gap锁 */</span><br><span class="line">begin;</span><br><span class="line">select * from tablet where id=10 lock in share mode;</span><br></pre></td></tr></table></figure><p>再执行session2，query ok:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">/*可以正常插入判定没有gap锁，针对唯一索引优化*/</span><br><span class="line">insert into tablet values(9,8,8);</span><br></pre></td></tr></table></figure><p>再执行session3，query blocked：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">update tablet set c=11 where id =10;</span><br></pre></td></tr></table></figure><blockquote><p><strong>唯一主键等值查询不加gap间隙锁，只加对应值的行锁。</strong></p></blockquote><p>这里将session1换成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line"> /*主键范围查询gap锁 */</span><br><span class="line">begin;</span><br><span class="line">select * from tablet where id&gt;=10 and id&lt;15 lock in share mode;</span><br></pre></td></tr></table></figure><p>session2，query ok：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">insert into tablet values(16,8,8);</span><br></pre></td></tr></table></figure><p>session3，query blocked：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">/*gap锁*/</span><br><span class="line">insert into tablet values(12,8,8);</span><br></pre></td></tr></table></figure><p>session4，query blocked：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">/*这里范围查询会多加一个行锁，实际上会感觉比较多余,因为并没有筛选到这个值,但是从逻辑上理解在索引上扫描一个范围并不知道什么时候结束，所以会有多出来的一个行锁，可能为了不违背两阶段锁的协议*/</span><br><span class="line">update tablet set c =0 where id=15;</span><br></pre></td></tr></table></figure><p>这里如果我们将session1中id&lt;15加上一个等号条件也就是id&lt;=15，mysql后在id=20这行也加上锁，同时多了一个gap锁也就是多了一整个<strong>next key lock (15,20]</strong>，这是相当奇怪的 ，因为扫描到15的时候可以确定不再往后进行扫描。这种貌似可以优化的场景但是并没有进行优化。</p><p><strong>最终上面的test发现会加id为10记录的行锁+(10,15]的next key lock。总结下，mysql在唯一主键索引查询的条件为范围索引的条件下会默认向后多加一个next key lock，等值查询直加行锁。</strong></p><blockquote><p><strong>lock in share mode 这种方式只会在索引上加锁，在不回表的情况下不会锁主键索引记录。for update 的方式不管是否回表都会锁主键记录。</strong></p></blockquote><h4 id="唯一普通索引加范围锁"><a href="#唯一普通索引加范围锁" class="headerlink" title="唯一普通索引加范围锁"></a>唯一普通索引加范围锁</h4><p>唯一普通索引有独立的树结构，在加锁上跟主键的索引是有区别的，防止根据主键更新造成不一致读会加行锁。</p><p>将c修改为唯一索引，执行下面的session1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line"></span><br><span class="line">alter table tablet drop index c;</span><br><span class="line">alter table tablet add unique index c(c);</span><br><span class="line">show index from tablet;</span><br><span class="line"></span><br><span class="line">begin;</span><br><span class="line">/* 普通唯一索引加范围锁 */</span><br><span class="line">select * from tablet where c &gt;10 and c &lt;=15 lock in share mode;</span><br><span class="line">/* == select d from tablet where c &gt;10 and c&lt;=15 for update; */</span><br></pre></td></tr></table></figure><p>然后执行session2，query blocked :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">-- 唯一普通索引c加锁范围(10,15],(15,20]，跟上面保持一致，需要多扫描一行数据并加锁（虽然感觉完全没有必要），主键索引加id=15行锁。</span><br><span class="line">-- query ok c=21</span><br><span class="line">insert into tablet values(16,21,8);</span><br><span class="line">-- query blocked c=16 gap间隙锁 </span><br><span class="line">insert into tablet values(19,16,8);</span><br><span class="line">-- blocked c=15 行锁</span><br><span class="line">update tablet set d=111 where c=15;</span><br><span class="line">-- query ok，没有加锁，回表的时候做了优化</span><br><span class="line">update tablet set d=111 where id=20;</span><br><span class="line">-- blocked 加了行锁</span><br><span class="line">update tablet set d=111 where id=15;</span><br></pre></td></tr></table></figure><blockquote><p><strong>唯一索引范围锁搜索到不符合预期范围的第一个值，以该值为最终值进行加锁，上面的语句如果改成c&lt;15那么锁范围变成(10,15]。</strong></p></blockquote><h4 id="非唯一普通索引加范围锁"><a href="#非唯一普通索引加范围锁" class="headerlink" title="非唯一普通索引加范围锁"></a>非唯一普通索引加范围锁</h4><p>类比上面的情况多了一个next key lock，执行session1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">begin;</span><br><span class="line">-- select * from  tablet where d&gt;10 and d&lt;=15 for update;</span><br><span class="line">/* 非唯一索引加范围锁 */</span><br><span class="line">select * from tablet where d &gt;10 and d &lt;=15 lock in share mode;</span><br></pre></td></tr></table></figure><p>执行session2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">-- 同样的情况变成了非唯一索引，加锁情况一致(10,15]，(15,20]（这里并没有多加个间隙锁，作了优化），主键索引加id=15行锁</span><br><span class="line">-- query ok d=8</span><br><span class="line">insert into tablet values(11,8,8)</span><br><span class="line">-- query ok d=23</span><br><span class="line">insert  into tablet values(13,7,23);</span><br><span class="line">-- blocked  d=20行锁</span><br><span class="line">update tablet set c=22 where d=20;</span><br><span class="line">-- query blocked  d=16间隙锁</span><br><span class="line">insert into tablet values(14,16,16);</span><br><span class="line">-- query ok </span><br><span class="line">update tablet set c =24 where id =20;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><blockquote><p><strong>非唯一索引范围锁搜索到不符合预期范围的第一个值，以该值为最终值进行加锁，上面的语句如果改成c&lt;15那么锁范围变成(10,15]。这里并不会在右边多加间隙锁。</strong></p></blockquote><p>#### </p><h4 id="非唯一普通索引加范围锁倒序"><a href="#非唯一普通索引加范围锁倒序" class="headerlink" title="非唯一普通索引加范围锁倒序"></a>非唯一普通索引加范围锁倒序</h4><p>倒序排序默认会从后往前扫描索引，mysql默认多加一个间隙锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- session1</span><br><span class="line">use souche_study;</span><br><span class="line">begin;</span><br><span class="line">-- 锁了(5,10],(10,15],(15,20],(20,25)</span><br><span class="line">select * from tablet where d&gt;=15 and d&lt;=20 order by d desc lock in share mode;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- session2</span><br><span class="line">use souche_study;</span><br><span class="line">-- query ok</span><br><span class="line">update tablet set c=14 where d =25;</span><br><span class="line">-- blocked</span><br><span class="line">insert into tablet values(17,17,6);</span><br><span class="line">-- query ok</span><br><span class="line">update tablet set c = 18 where d=5;</span><br><span class="line">-- blocked 唯一索引不存在(20,25)间隙锁</span><br><span class="line">insert into tablet values(16,16,21);</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总结一下，分析加锁情况主要需要区分出唯一索引和非唯一索引。唯一索引是左半区或者右半区可能插入，非唯一索引是左右半区都可能插入。并且有几个原则和几个优化，原则：</p><blockquote><p>1.加锁的基本单位是next key lock，前开后闭区间。</p><p>2.mysql扫描到的对象才会进行加锁。</p></blockquote><p>优化：</p><blockquote><p>1.索引的唯一等值查询，next key lock退化为行锁。（非唯一等值查询不退化）</p><p>2.等值查询或者范围查询向右遍历到最后一个不符合期望的值，即使是非唯一索引也不会在该值的右侧加一个间隙锁。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实践基于以下表结构，分析各个情况下加锁：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql查询性能优化</title>
    <link href="http://jianghao.wang/2018/mysql%E6%9F%A5%E8%AF%A2%E6%A3%80%E7%B4%A2%E6%80%A7%E8%83%BD%E8%AF%AD%E5%8F%A5%E8%AE%B0%E5%BD%95/"/>
    <id>http://jianghao.wang/2018/mysql查询检索性能语句记录/</id>
    <published>2018-12-28T09:30:02.605Z</published>
    <updated>2019-01-10T01:53:54.447Z</updated>
    
    <content type="html"><![CDATA[<h4 id="查询长时间不返回"><a href="#查询长时间不返回" class="headerlink" title="查询长时间不返回"></a>查询长时间不返回</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.processlist;//这条语句跟下面的语句相同</span><br><span class="line">show processlist;//展示出当前的进程信息</span><br></pre></td></tr></table></figure><p>特殊的，在模拟一种MDL写锁阻塞的情况可以通过该命令查到阻塞的查询，这种情况一般第一时间执行该语句：</p><p>通过kill指令杀掉线程，恢复执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill 4;//kill pid,通过上面的命令查询到可以查询到对应线程的pid</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.innodb_locks;//可以查看死锁，注意锁等待信息不会在这里显示出来，除非发生死锁。包括gap锁和x锁可能导致的死锁等待，数据库开启了死锁等待机制可以检测死锁。</span><br></pre></td></tr></table></figure><h4 id="开启慢查询"><a href="#开启慢查询" class="headerlink" title="开启慢查询"></a>开启慢查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &quot;%query%&quot;</span><br></pre></td></tr></table></figure><p>result:</p><p><img src="https://arthornye.github.io/images/querylog.jpg" alt="cmd-markdown-logo"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 会在当前session立即生效</span><br><span class="line">set global slow_query_log=&apos;ON&apos;;</span><br><span class="line">-- 不会在当前的session生效，很坑，需要开启另一个session才会查询到设置效果</span><br><span class="line">set global long_query_time=0;</span><br></pre></td></tr></table></figure><p>截取一个slow log的记录结果：</p><p><img src="https://arthornye.github.io/images/slowlog.jpg" alt="cmd-markdown-logo"></p><h4 id="慢查询优化步骤"><a href="#慢查询优化步骤" class="headerlink" title="慢查询优化步骤"></a>慢查询优化步骤</h4><p>业务上有个审核表的表结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `audit_order` (</span><br><span class="line">  `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &apos;id&apos;,</span><br><span class="line">  `order_id` int(11) unsigned NOT NULL COMMENT &apos;销售订单号&apos;,</span><br><span class="line">  `order_code` varchar(32) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;订单中心订单号&apos;,</span><br><span class="line">  `user_id` varchar(32) DEFAULT NULL COMMENT &apos;申请人id&apos;,</span><br><span class="line">  `auditor_id` varchar(32) DEFAULT NULL COMMENT &apos;审核人id&apos;,</span><br><span class="line">  `status` tinyint(4) NOT NULL DEFAULT &apos;10&apos; COMMENT &apos;状态 10：待审核 20：审核通过 30：审核驳回 40：审核未通过&apos;,</span><br><span class="line">  `reject_reason` varchar(128) DEFAULT NULL COMMENT &apos;不通过原因&apos;,</span><br><span class="line">  `updater_id` varchar(32) DEFAULT &apos;&apos; COMMENT &apos;更新人&apos;,</span><br><span class="line">  `date_create` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &apos;创建时间&apos;,</span><br><span class="line">  `date_update` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &apos;更新时间&apos;,</span><br><span class="line">  `business_type` varchar(32) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `idx_order_id` (`order_id`),</span><br><span class="line">  KEY `idx_order_code` (`order_code`),</span><br><span class="line">  KEY `date_update` (`date_update`),</span><br><span class="line">  KEY `idx_date_create` (`date_create`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=50571 DEFAULT CHARSET=utf8 COMMENT=&apos;订单审核表&apos;;</span><br></pre></td></tr></table></figure><p>分析下面语句实际扫描的行数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, order_code, status, date_create, date_update</span><br><span class="line">, reject_reason</span><br><span class="line">FROM audit_order</span><br><span class="line">WHERE (business_type = &apos;CUSTOMIZED_CAR&apos;</span><br><span class="line">AND status IN (20)</span><br><span class="line">AND date_update &gt; &apos;2018-01-01&apos;)</span><br><span class="line">ORDER BY date_update</span><br><span class="line">LIMIT 100</span><br></pre></td></tr></table></figure><p>我们explain一下：</p><p><img src="https://arthornye.github.io/images/noindex.jpg" alt="cmd-markdown-logo"></p><p>这里分析显示的扫描行数rows是24786行，但是实际上我们通过慢查询日志发现，实际的扫描行数是接近五万行，接近两倍。using index condition表示通过date_update索引查询过滤到记录之后回表，执行时间在全表数据较少的情况下用了100ms，符合我们的预期：</p><p><img src="https://arthornye.github.io/images/noindexlog.jpg" alt="cmd-markdown-logo"></p><p>加一个索引，重新执行explain，并观察慢查询日志真实扫描行数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE audit_order</span><br><span class="line">ADD INDEX idx_type_status_date (status, business_type, date_update);</span><br></pre></td></tr></table></figure><p><img src="https://arthornye.github.io/images/useindex.jpg" alt="cmd-markdown-logo"></p><p><img src="https://arthornye.github.io/images/useindexlog.jpg" alt="cmd-markdown-logo"></p><p><strong>通常我们观察range级别是索引可用级别，但是实际的扫描行数还是需要参考explain的rows和日志中的rows_examinzed，其中explain是估计值，真正准确的还是rows_examinzed。</strong></p><h4 id="count-性能"><a href="#count-性能" class="headerlink" title="count(*)性能"></a>count(*)性能</h4><p>innnodb在统计行数的时候没有像myisam一样保存了行数，需要重新扫描一遍表。我们比较一下集中查询方式的性能。插入一个两百多万行的数据表word。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER ;;</span><br><span class="line">CREATE DEFINER=`root`@`localhost` PROCEDURE `inputdata`()</span><br><span class="line">begin</span><br><span class="line">  declare i int;</span><br><span class="line">  set i=1;</span><br><span class="line">  while(i&lt;=2800000)do</span><br><span class="line">    insert into words values(i,i);</span><br><span class="line">    set i=i+1;</span><br><span class="line">  end while;</span><br><span class="line">end;;</span><br><span class="line">DELIMITER ;</span><br><span class="line">call inputdata;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-- count(id)</span><br><span class="line"># Time: 2019-01-09T14:10:05.038579Z</span><br><span class="line"># User@Host: root[root] @ localhost []  Id:    14</span><br><span class="line"># Query_time: 0.349229  Lock_time: 0.000062 Rows_sent: 1  Rows_examined: 0</span><br><span class="line">SET timestamp=1547043005;</span><br><span class="line">select count(id) from words;</span><br><span class="line"></span><br><span class="line">-- count(1)</span><br><span class="line"># Time: 2019-01-09T14:10:02.488929Z</span><br><span class="line"># User@Host: root[root] @ localhost []  Id:    14</span><br><span class="line"># Query_time: 0.305565  Lock_time: 0.000060 Rows_sent: 1  Rows_examined: 0</span><br><span class="line">SET timestamp=1547043002;</span><br><span class="line">select count(1) from words;</span><br><span class="line"></span><br><span class="line">-- count(字段)</span><br><span class="line"># Time: 2019-01-09T14:09:56.943701Z</span><br><span class="line"># User@Host: root[root] @ localhost []  Id:    14</span><br><span class="line"># Query_time: 0.544218  Lock_time: 0.000066 Rows_sent: 1  Rows_examined: 2709998</span><br><span class="line">SET timestamp=1547042996;</span><br><span class="line">select count(word) from words;</span><br><span class="line"></span><br><span class="line">-- count(*)</span><br><span class="line"># Time: 2019-01-09T14:09:59.196291Z</span><br><span class="line"># User@Host: root[root] @ localhost []  Id:    14</span><br><span class="line"># Query_time: 0.301123  Lock_time: 0.000057 Rows_sent: 1  Rows_examined: 0</span><br><span class="line">SET timestamp=1547042999;</span><br><span class="line">select count(*) from words;</span><br></pre></td></tr></table></figure><p>结论：<strong>count(*)约等于count(1)&gt;count(id)&gt;count(字段)，推荐使用前三个</strong>，count字段有磁盘io，会把字段的值取出来，进行判断是否为null值。通常我们通过innodb的事务性特征，将总记录条数在一个事务中去取，mysql即使在异常情况下也不会导致数据不一致。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;查询长时间不返回&quot;&gt;&lt;a href=&quot;#查询长时间不返回&quot; class=&quot;headerlink&quot; title=&quot;查询长时间不返回&quot;&gt;&lt;/a&gt;查询长时间不返回&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>react学习</title>
    <link href="http://jianghao.wang/2018/React%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianghao.wang/2018/React学习/</id>
    <published>2018-12-17T11:01:38.088Z</published>
    <updated>2019-01-09T13:28:16.746Z</updated>
    
    <content type="html"><![CDATA[<h4 id="setState异步执行"><a href="#setState异步执行" class="headerlink" title="setState异步执行"></a>setState异步执行</h4><p>在实践的过程中发现一个奇怪的现象，我们如果先进行setState在进行网络请求，那么网络请求很可能提前进行，也就是setState是异步的，正确的同步写法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">onPageChange = (page) =&gt; &#123;</span><br><span class="line">       if(this.state.isSaleOrder)&#123;</span><br><span class="line">           this.setState(&#123;</span><br><span class="line">               sale_page:page,</span><br><span class="line">           &#125;,() =&gt;&#123;//这要采用回调的方式，更新完state再继续进行网络请求，不然会造成异常情况</span><br><span class="line">               this.getOrderManageList();</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           this.setState(&#123;</span><br><span class="line">               purchase_page:page,</span><br><span class="line">           &#125;,() =&gt;&#123;</span><br><span class="line">               this.getOrderManageList();</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="div设置不可见"><a href="#div设置不可见" class="headerlink" title="div设置不可见"></a>div设置不可见</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;display</span> <span class="attr">:</span> <span class="attr">this.state.reject</span>&#125;&#125;&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Form</span> <span class="attr">layout</span>=<span class="string">"inline"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FormItem</span> <span class="attr">label</span>=<span class="string">"审核打回时间段筛选"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">RangePicker</span> <span class="attr">placeholder</span>=<span class="string">&#123;[</span> "开始时间", "结束时间"]&#125; <span class="attr">onChange</span>=<span class="string">&#123;(data)</span>=&gt;</span>&#123; this.state.rejectStartTime = data[0]; this.state.rejectEndTime = data[1] &#125;&#125; /&gt;<span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FormItem</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">type</span>=<span class="string">"primary"</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>this.getAuditList()&#125;&gt; 筛选<span class="tag">&lt;/<span class="name">Button</span>&gt;</span><span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以通过设置<strong>display:’none’</strong>不显示当前div，通过设置<strong>display:’block’</strong>显示当前div。</p><h4 id="通过Form设置组件布局"><a href="#通过Form设置组件布局" class="headerlink" title="通过Form设置组件布局"></a>通过Form设置组件布局</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginTop:</span> <span class="attr">24</span> &#125;&#125;&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Form</span> <span class="attr">layout</span>=<span class="string">"inline"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FormItem</span> <span class="attr">label</span>=<span class="string">"请选择业务类型:"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Select</span> <span class="attr">defaultValue</span>=<span class="string">"全部"</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width:</span> <span class="attr">120</span> &#125;&#125; <span class="attr">onChange</span>=<span class="string">&#123;this.onChangeBusinessType&#125;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Option</span> <span class="attr">value</span>=<span class="string">"ALL"</span>&gt;</span>全部<span class="tag">&lt;/<span class="name">Option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Option</span> <span class="attr">value</span>=<span class="string">"COMMON_NEW_RETAIL"</span>&gt;</span>普通订单<span class="tag">&lt;/<span class="name">Option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Option</span> <span class="attr">value</span>=<span class="string">"CUSTOMIZED_CAR"</span>&gt;</span>定制车订单<span class="tag">&lt;/<span class="name">Option</span>&gt;</span><span class="tag">&lt;/<span class="name">Select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过<strong>label:””</strong>设置左边的显示tab。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;setState异步执行&quot;&gt;&lt;a href=&quot;#setState异步执行&quot; class=&quot;headerlink&quot; title=&quot;setState异步执行&quot;&gt;&lt;/a&gt;setState异步执行&lt;/h4&gt;&lt;p&gt;在实践的过程中发现一个奇怪的现象，我们如果先进行setSta
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql中的隐式类型转换</title>
    <link href="http://jianghao.wang/2018/mysql%E4%B8%AD%E7%9A%84%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://jianghao.wang/2018/mysql中的隐式类型转换/</id>
    <published>2018-12-04T04:52:03.232Z</published>
    <updated>2019-01-21T14:32:53.012Z</updated>
    
    <content type="html"><![CDATA[<h4 id="mysql中的隐式类型转换？"><a href="#mysql中的隐式类型转换？" class="headerlink" title="mysql中的隐式类型转换？"></a>mysql中的隐式类型转换？</h4><p>mysql innodb有行锁的实现，行锁会针对当前读进行加排他锁。</p><p><strong>1.对索引字段做函数操作会导致索引失效，破坏索引的有序性，优化器不走b+树搜索</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from trade_log where month(t_modify)=7;</span><br></pre></td></tr></table></figure><p>上面的语句没办法使用到索引，不可以在索引的字段上加函数操作，这里复杂的函数操作导致了破坏索引的扫描，但是即使类似where id+1=1000这种操作优化器也并不会做优化操作，需要写成where id= 1000-1。</p><h4 id="隐式字符编码转换导致索引失效"><a href="#隐式字符编码转换导致索引失效" class="headerlink" title="隐式字符编码转换导致索引失效"></a>隐式字符编码转换导致索引失效</h4><p>在应用过程中通常会有字段字符集不统一的问题，如a表字段order_code为utf8mb4，关联 b表retail_order_code字段字符集为utf8。utf8mb4为utf8的超集合，也就是如果用a表取关联b表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from a,b where a.order_code=b.retail_order_code;</span><br></pre></td></tr></table></figure><p>实际上这句话在被连接的表上的逻辑==：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from b where convert(b.retail_order_code using utf8mb4) =a.value;</span><br></pre></td></tr></table></figure><p>所以隐式字符编码转换索引失效的条件：<strong>连接过程中被驱动的表的索引字段加函数操作。</strong></p><p>解决的方法：</p><p>1.改字符集，改成同样的字符集。</p><p>2.将驱动表的字符集用函数操作改为被驱动表的字符集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from a,b where convert(a.order_code using utf8) = b.retail_order_code;</span><br></pre></td></tr></table></figure><p>上面的语句在被连接表的逻辑变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from b where b.retail_order_code=a.value;//字符集一致，不需要做索引函数操作</span><br></pre></td></tr></table></figure><h4 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h4><p>在mysql的数据结构中，varchar和int的类型转换级别是不一样的，参考上面的分析方法，我们通过实践语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &quot;10&quot;&gt;9;//输出 1代表将字符串转成了数字</span><br></pre></td></tr></table></figure><p>那么我们可以得出结论，如果一个表a中有个varchar(32)的字段为索引字段order_code, 但是我们执行语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from a where order_code=1111;//会导致全表扫描。</span><br></pre></td></tr></table></figure><p><strong>便于理解，我们将其定义为一个父集一个子集，子集可以自动convert转换为父集。上面utf8为父集，utf8mb4为子集，int为子集，varchar为父集。如果父集为索引字段，子集为查询的字段，那么会出现索引失效。</strong></p><h4 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Illegal mix of collations (utf8_unicode_ci,IMPLICIT) and (utf8_general_ci,IMPLICIT) for operation &apos;=&apos;</span><br></pre></td></tr></table></figure><p>虽然都是utf8，但是mysql在比较的时候无法用具体的字符集进行比较，需要强制指定字符集：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- convert(t1.order_code using utf8)</span><br><span class="line">-- convert(t1.order_code using uft8) COLLATE utf8_unicode_ci</span><br><span class="line">SELECT t1.retail_order_code</span><br><span class="line">, (</span><br><span class="line">SELECT CASE t2.order_status</span><br><span class="line">WHEN 150 THEN 3</span><br><span class="line">ELSE 4</span><br><span class="line">END</span><br><span class="line">), t1.tmail_order_id, 1,t1.step_count, t1.disburse_fee</span><br><span class="line">, t1.voucher_price, t1.deleted, t1.sku_id, t1.date_create, t1.date_update</span><br><span class="line">, &apos;normal&apos;, &apos;retainge&apos;, 50, &apos;3393340311&apos;, &apos;大搜车旗舰店&apos;</span><br><span class="line">, 50</span><br><span class="line">FROM retail_marketing_order t1</span><br><span class="line">LEFT JOIN retail_order t2 ON convert(t1.retail_order_code USING utf8) = t2.order_code;</span><br></pre></td></tr></table></figure><p>值得注意的是convert(t1.order_code using uft8) COLLATE utf8_unicode_ci和convert(t1.order_code using utf8)虽然让字符集标准化了，通过explain我们发现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1SIMPLEt1NULLALLNULLNULLNULLNULL186100.00NULL</span><br><span class="line">1SIMPLEt2NULLindexorder_code_indexsync_index107NULL113582100.00Using where; Using index; Using join buffer (Block Nested Loop)</span><br></pre></td></tr></table></figure><p>sql查询日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Query_time: 0.002302  Lock_time: 0.000244 Rows_sent: 186  Rows_examined: 372  一次回表查询</span><br><span class="line">SET timestamp=1548079631;</span><br><span class="line">SELECT t1.retail_order_code</span><br><span class="line">  , (</span><br><span class="line">    SELECT CASE t2.order_status</span><br><span class="line">        WHEN 150 THEN 3</span><br><span class="line">        ELSE 4</span><br><span class="line">      END</span><br><span class="line">  ), t1.tmail_order_id, 1,t1.step_count, t1.disburse_fee</span><br><span class="line">  , t1.voucher_price, t1.deleted, t1.sku_id, t1.date_create, t1.date_update</span><br><span class="line">  , &apos;distributor&apos;, &apos;retainge&apos;, 50</span><br><span class="line">  , 50</span><br><span class="line">FROM retail_marketing_order t1</span><br><span class="line">  LEFT JOIN retail_order t2 ON convert(t1.retail_order_code USING utf8) = t2.order_code;</span><br></pre></td></tr></table></figure><h4 id="Using-join-buffer-Block-Nested-Loop"><a href="#Using-join-buffer-Block-Nested-Loop" class="headerlink" title="Using join buffer (Block Nested Loop)"></a>Using join buffer (Block Nested Loop)</h4><p>BNL算法建立在join操作的基础上，join操作有一个内表一个外表，外表和内表两层循环。BNL算法取出100条放到join buffer中，内层循环直接从buffer中全部匹配出来100条，这样操作减少了磁盘io</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;mysql中的隐式类型转换？&quot;&gt;&lt;a href=&quot;#mysql中的隐式类型转换？&quot; class=&quot;headerlink&quot; title=&quot;mysql中的隐式类型转换？&quot;&gt;&lt;/a&gt;mysql中的隐式类型转换？&lt;/h4&gt;&lt;p&gt;mysql innodb有行锁的实现，行锁会
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql索引介绍</title>
    <link href="http://jianghao.wang/2018/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/"/>
    <id>http://jianghao.wang/2018/mysql索引介绍/</id>
    <published>2018-11-24T07:16:28.373Z</published>
    <updated>2019-01-22T10:02:35.428Z</updated>
    
    <content type="html"><![CDATA[<h4 id="索引的几种数据模型"><a href="#索引的几种数据模型" class="headerlink" title="索引的几种数据模型"></a>索引的几种数据模型</h4><p>数据库引擎在设计索引结构的时候首先需要数据结构，怎样的数据结构能够兼容查询和更新，在不同的场景下选择也有所不同。下面主要介绍几种模型以及数据结构上的利弊。</p><h5 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h5><p>哈希索引数据模型类似HashMap，KV结构，通过数组+链表的方式去存储。<strong>利于等值查询（单值查询），不利于多值查询（范围查询），利于更新。</strong></p><p>应用：主要是应用在memcache，nosql等。主要为单值查询比较多的场景，更新性能也不差，不考虑IO。</p><h5 id="有序数组索引"><a href="#有序数组索引" class="headerlink" title="有序数组索引"></a>有序数组索引</h5><p>有序数组数据模型类比数组，有序的记录。<strong>利于查询（单值查询和多值查询表现都比较优秀），复杂度O(log n)，不利于更新（需要移动位置）。</strong></p><p>应用：有序数组索引只适用于静态存储引擎，比如你要保存的是某一年某个城市所有的人口信息。多为查询，更新比较少。</p><h5 id="N叉树索引"><a href="#N叉树索引" class="headerlink" title="N叉树索引"></a>N叉树索引</h5><p>N叉树索引数据模型，类比mysql中的B+TREE。<strong>利于IO，查询和更新的表现比较平衡。数据库数据存储在磁盘，多叉树可以减少大量IO。</strong></p><p>应用：mysql innodb采用的b+tree，相较于我们通常看到的平衡二叉树（查询O(log n)，更新O(log n)）兼容了磁盘IO，在大数据存储查询上更有优势。</p><h4 id="innodb的索引模型"><a href="#innodb的索引模型" class="headerlink" title="innodb的索引模型"></a>innodb的索引模型</h4><p>innodb采用b+tree维护每个索引，每个索引对应的都是一个b+tree多叉树的数据结构，其中mysql会为每个表默认生成一个字自增的primary key，作为表的唯一主键。那么我们将mysql的索引类型可以简单的分为主键索引的普通索引。</p><h5 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h5><p>mysql的主键索引我们又可以称之为聚簇索引，索引叶子结点记录了所有的字段信息。</p><p><img src="http://arthornye.github.io/images/mysql.png" alt="cmd-markdown-logo"></p><h5 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h5><p>普通索引只存储了索引的值+主键的值。普通索引查询之后，如果需要取出主键之外的信息，只要索引中不包含，就需要进行一个<strong>“回表”</strong>的操作。这里衍生出一种索引，叫做覆盖索引，意思是不需要回表，所查询的信息已经在普通索引中维护好了。例如我们上面建立的person表，card这个字段上是有一个普通索引的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from person where card=&apos;330...&apos;;//覆盖索引（不会进行回表）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from person where card=&apos;330...&apos;;//用不到覆盖索引（找到id后回表，在主键索引中再执行一次查询）</span><br></pre></td></tr></table></figure><h5 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h5><p>覆盖索引，上面的表中，我们如果根据单个字段的值建立索引，在根据索引遍历到记录之后需要进行回表操作。那么如果我们加索引index（name,card），数据在根据身份证去找名字的时候的查询语句就不需要回表，这个就叫<strong>覆盖索引</strong>。</p><p>可以看到覆盖索引其实也就是在我们通常称为<strong>联合索引</strong>的基础之上的。联合索引会导致一些失效的情况：</p><h4 id="普通索引和唯一索引如何选择"><a href="#普通索引和唯一索引如何选择" class="headerlink" title="普通索引和唯一索引如何选择"></a>普通索引和唯一索引如何选择</h4><p>两种索引的选择主要基于性能，从读和写考虑，普通索引的读和唯一索引的读性能差别基本不大。</p><p><img src="https://arthornye.github.io/images/changebuffer.jpg" alt="cmd-markdown-logo"></p><p><strong>普通索引不需要唯一约束校验，可以将更新语句存储到change buffer中，等到记录被读取的时候再直接更新内存记录，这样节省了一次随机读IO。尽量选择普通索引，能够改善更新效率。</strong></p><h5 id="redo-log-和-change-buffer"><a href="#redo-log-和-change-buffer" class="headerlink" title="redo log 和 change buffer"></a>redo log 和 change buffer</h5><p><strong>1.change buffer 在innodb的内存中，redo log是日志文件。</strong></p><p><strong>2.change buffer主要为了优化随机读，redo log主要优化随机写*（批量写入减少IO）。</strong></p><h4 id="in查询优化"><a href="#in查询优化" class="headerlink" title="in查询优化"></a>in查询优化</h4><p>业务表retail_order假设我们建立一个索引，索引sql如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table retail_order add index idx_type_code(business_type,order_code);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">retail_order1idx_type_code1business_typeA1NULLNULLBTREE</span><br><span class="line">retail_order1idx_type_code2order_codeA113582NULLNULLYESBTREE</span><br></pre></td></tr></table></figure><p>采用union all（不区分重复记录）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(SELECT *</span><br><span class="line">FROM retail_order</span><br><span class="line">WHERE business_type = &apos;CUSTOMIZED_CAR&apos;</span><br><span class="line">ORDER BY order_code</span><br><span class="line">LIMIT 100)</span><br><span class="line">UNION ALL</span><br><span class="line">(SELECT *</span><br><span class="line">FROM retail_order</span><br><span class="line">WHERE business_type = &apos;COMMON_NEW_RETAIL&apos;</span><br><span class="line">ORDER BY order_code</span><br><span class="line">LIMIT 100)</span><br><span class="line">ORDER BY order_code</span><br><span class="line">LIMIT 100;</span><br></pre></td></tr></table></figure><p>分析explain 和 慢查询日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Time: 2019-01-14T07:58:52.068234Z</span><br><span class="line"># User@Host: root[root] @ localhost []  Id:    10</span><br><span class="line"># Query_time: 0.109241  Lock_time: 0.000976 Rows_sent: 100  Rows_examined: 500</span><br><span class="line">SET timestamp = 1547452732;</span><br><span class="line">(SELECT *</span><br><span class="line">FROM retail_order</span><br><span class="line">WHERE business_type = &apos;CUSTOMIZED_CAR&apos;</span><br><span class="line">ORDER BY order_code</span><br><span class="line">LIMIT 100)</span><br><span class="line">UNION ALL</span><br><span class="line">(SELECT *</span><br><span class="line">FROM retail_order</span><br><span class="line">WHERE business_type = &apos;COMMON_NEW_RETAIL&apos;</span><br><span class="line">ORDER BY order_code</span><br><span class="line">LIMIT 100)</span><br><span class="line">ORDER BY order_code</span><br><span class="line">LIMIT 100;</span><br><span class="line">//慢查询日志显示扫描行数为（100+100）*2回表</span><br><span class="line"></span><br><span class="line">//这里是explain 的结果 ，扫描行数并不准确，100条的using filesort可以接受，在程序中排序也会耗费性能。</span><br><span class="line">1PRIMARYretail_orderNULLrefidx_type_codeidx_type_code82const1382100.00Using index condition</span><br><span class="line">2UNIONretail_orderNULLrefidx_type_codeidx_type_code82const56791100.00Using index condition</span><br><span class="line">NULLUNION RESULT&lt;union1,2&gt;NULLALLNULLNULLNULLNULLNULLNULLUsing temporary; Using filesort</span><br></pre></td></tr></table></figure><p>理论上用in查询会使索引失效，但是实际这里我们通过in查询在先前的索引基础上优化器是有做优化的，并且减少了数据库的扫描行数。这里暂时不知道如何做的这个优化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from retail_order where business_type in (&apos;CUSTOMIZED_CAR&apos;,&apos;COMMON_NEW_RETAIL&apos;)   order by order_code limit 100;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- explain result 扫描行数195行，做了优化</span><br><span class="line">1SIMPLEretail_orderNULLindexidx_type_codeorder_code_index99NULL19551.22Using where</span><br><span class="line"></span><br><span class="line">-- 慢查询日志结果 实际上只扫描了100行</span><br><span class="line"># administrator command: Ping;</span><br><span class="line"># Time: 2019-01-14T08:36:22.221282Z</span><br><span class="line"># User@Host: root[root] @ localhost []  Id:    10</span><br><span class="line"># Query_time: 0.108762  Lock_time: 0.000197 Rows_sent: 100  Rows_examined: 100</span><br><span class="line">SET timestamp=1547454982;</span><br><span class="line">select * from retail_order where business_type in (&apos;CUSTOMIZED_CAR&apos;,&apos;COMMON_NEW_RETAIL&apos;)   order by order_code limit 100;</span><br></pre></td></tr></table></figure><p><strong>对比发现，sql优化器有对这种情况的in查询做优化，实际上还是用到了索引。注意这里的耗时比较长主要因为传输的数据量比较大。</strong></p><h4 id="查看索引和库文件大小"><a href="#查看索引和库文件大小" class="headerlink" title="查看索引和库文件大小"></a>查看索引和库文件大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 库文件和索引大小存在information_schema库中的TABLES表</span><br><span class="line">use information_schema;</span><br><span class="line">select concat(round(sum(DATA_LENGTH/1024/1024),2),&apos;MB&apos;) as data  from TABLES where table_schema=&apos;souche_retail&apos;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">216.96MB</span><br></pre></td></tr></table></figure><p>查看线上的索引文件大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use information_schema;</span><br><span class="line">select concat(round(sum(DATA_LENGTH/1024/1024/1024),2),&apos;GB&apos;) as data  from TABLES where table_schema=&apos;souche_retail_pre&apos;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">16.97GB</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;索引的几种数据模型&quot;&gt;&lt;a href=&quot;#索引的几种数据模型&quot; class=&quot;headerlink&quot; title=&quot;索引的几种数据模型&quot;&gt;&lt;/a&gt;索引的几种数据模型&lt;/h4&gt;&lt;p&gt;数据库引擎在设计索引结构的时候首先需要数据结构，怎样的数据结构能够兼容查询和更新，在
      
    
    </summary>
    
    
      <category term="-mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql innodb日志模块介绍</title>
    <link href="http://jianghao.wang/2018/mysql%20innodb%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/"/>
    <id>http://jianghao.wang/2018/mysql innodb日志模块介绍/</id>
    <published>2018-11-17T14:45:21.552Z</published>
    <updated>2018-11-18T02:52:35.993Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍一下mysql的日志系统。我们都知道在数据库的生产环境上，可能会发生一些事故。例如之前有个同事在执行数据订正的时候，不小心将很多的订单数据中的凭证数据覆盖成了空。这样的操作第一时间肯定是想通过数据库备份的形式将数据恢复出来，这个时候你的DBA可能会告诉你，有一周的数据的备份。不幸的是，这个事故发生的情况并没有在一星期之内定位到原因。所幸，有一份较久的备份，DBA可以根据这个备份恢复到丢失前的那个节点。那么这里就需要提到mysql的日志系统是如何实现的，只介绍一下概念，具体的实践由伟大的DBA完成。</p><h4 id="mysql的日志模块以及如何保证一致性"><a href="#mysql的日志模块以及如何保证一致性" class="headerlink" title="mysql的日志模块以及如何保证一致性"></a>mysql的日志模块以及如何保证一致性</h4><p>mysql的日志主要分为物理日志redo log（重做日志）和bin log（归档日志）。这两种日志都是只针对更新操作进行记录，针对查询的记录不会记录到mysql的日志模块。更新语句执行的主要流程：</p><p><img src="http://arthornye.github.io/images/twostep.png" alt="cmd-markdown-logo"></p><h5 id="redo-log（重做日志）"><a href="#redo-log（重做日志）" class="headerlink" title="redo log（重做日志）"></a>redo log（重做日志）</h5><p>这个是只针对数据库引擎innodb才有的日志模块。我们可以类比我们在记账的时候，我们有一个账本，记录了每个顾客的账户余额记录，但是如果人特别多的时候我们很难找到每个顾客的记录然后做个更新操作（这里一次查询io一次更新io），最好的办法是将这次的消费记录更新计算的结果记录到一个“白板”上面，等到空闲的时候再去写账本（sync同步到数据库磁盘）。这个“白板”的功能就是redo log。当然这个“白板”也会有写完的时候，实际情况下redo log文件是存在物理文件中的，假设我们有四个redo log文件总共大小为4g，那么每个文件的容量为1g。</p><p><img src="http://arthornye.github.io/images/pointmove.png" alt="cmd-markdown-logo"></p><p>粉板和账本配合的整个过程，其实就是 MySQL 里经常说到WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。</p><h5 id="bin-log（归档日志）"><a href="#bin-log（归档日志）" class="headerlink" title="bin log（归档日志）"></a>bin log（归档日志）</h5><p>可以简单理解为是记录了又一句的更新sql语句，当你需要进行恢复的时候可以先将表恢复到某个历史时间点，然后通过bin log中的记录一个个去执行到丢失数据前的时间点。那么这两种日志有什么不同，为什么要做区分？</p><p><strong>1.redo log是物理日志，记录了在某行做了修改的结果（修改后的记录）。而bin log是逻辑日志，记录了在某行做了什么操作（执行修改的操作）。</strong></p><p><strong>2.redo log是InnoDB 引擎特有的，而bin log是基于mysql的server引擎的，所有的引擎都有选择启用或者关闭这个日志功能。</strong></p><p><strong>3.redo log是循环写的，如果point重合的话是会强制sync到磁盘的，但是bin log是会一直往下写的。</strong></p><h5 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h5><p>介绍了两种日志模块的功能，我们再来分析开头为什么要做两阶段提交。我们在系统交互的过程中有没有碰到一种情况就是两个任务需要同时完成才算是完成，如果由于异常失败了其中一个，那么整个过程是不成功的，这里我们通常会用一个中间状态来控制整个事务。也就是两阶段提交日志的概念，将写bin log和redo log整个当成一个事务去处理。</p><p><strong>redo log更新成功，binlog更新的时候mysql重启，重启机制检测到之后回滚该事务。redo log更新和bin log更新都成功，提交的时候mysql重启，重启之后检测到该事务已经完成自动提交。那么两个日志模块的数据是始终一致的。</strong></p><p>如果不进行两阶段提交，数据库在异常重启之后恢复的正是库可能和通过bin log恢复的备份数据是不一致的。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>主要介绍了mysql innodb在更新操作的时候是如果记录日志，防止突然的重启以及后续的数据备份恢复。即时突然重启，redo log也记录了原始的物理修改信息。当然如果想要恢复到历史的某一个点，也可以通过bin log的形式在历史某一个版本的数据上进行迭代执行。两个日志模块通过了中间状态进行两阶段提交，同时也保证了数据的一致性（这里如果是分各自提交会有问题，数据不一致）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单介绍一下mysql的日志系统。我们都知道在数据库的生产环境上，可能会发生一些事故。例如之前有个同事在执行数据订正的时候，不小心将很多的订单数据中的凭证数据覆盖成了空。这样的操作第一时间肯定是想通过数据库备份的形式将数据恢复出来，这个时候你的DBA可能会告诉你，有一周的数
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql加锁处理分析</title>
    <link href="http://jianghao.wang/2018/mysql%E5%8A%A0%E9%94%81%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://jianghao.wang/2018/mysql加锁处理分析/</id>
    <published>2018-11-12T06:07:22.527Z</published>
    <updated>2018-12-29T10:02:23.466Z</updated>
    
    <content type="html"><![CDATA[<p>之前的一篇文章介绍了mysql的四种隔离级别，本篇主要介绍一下mysql是如何进行加锁处理的。主要想了解mysql在处理高并发情况下的读写以及可能遇到的并发问题之间是如何去兼容的。我们都知道加锁是比较资源的操作，但是不加锁也会面临一些并发的问题，本篇文章将基于四种隔离级别去介绍mysql是如何进行加锁的处理的。</p><h4 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h4><p>我们需要先了解一下当前读和快照读的区别，实际上在mysql中是区分这两种读的，看两个sql语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from test_test where ? for update;//这一整个事务是一个当前读（实际上是一个写操作）</span><br><span class="line">select * from test_test where ?;//这个事务是一个快照读（实际上只是一个从数据库获取数据的操作）</span><br></pre></td></tr></table></figure><p><strong>当前读：delete，insert，update操作都可以视为当前读，从语义上可以理解为select for udpate，都是先读再写，需要保证并发的读写数据一致性。</strong></p><p><strong>快照读：单纯的select操作，数据库读取操作，不同的数据库隔离级别可能面临重复读的不一致问题和幻读问题。</strong></p><p>在mysql中，针对快照读只有在最高的隔离级别serializable级别下才会对快照读进行加锁，其他的级别下都是不加锁的。针对当前读，mysql在各个级别下为了防止并发的数据不一致问题都会进行加锁，加排他锁，也可以理解为写锁。</p><h4 id="各种隔离级别下的加锁机制"><a href="#各种隔离级别下的加锁机制" class="headerlink" title="各种隔离级别下的加锁机制"></a>各种隔离级别下的加锁机制</h4><p>我们探讨一下RC隔离级别下的几种索引遍历加锁处理的情况：</p><h5 id="RC-UUK（不可重复读-非唯一索引）"><a href="#RC-UUK（不可重复读-非唯一索引）" class="headerlink" title="RC+UUK（不可重复读+非唯一索引）"></a>RC+UUK（不可重复读+非唯一索引）</h5><p>我们将mysql的隔离级别调整为RC，建立一个test_test表，其中id是primary key，code是unique key。分别执行下面的sql：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=5 for update;</span><br><span class="line">//先在session1中执行该sql1</span><br><span class="line">id  name code</span><br><span class="line">13yqz   5</span><br><span class="line">14yqz   5</span><br><span class="line"></span><br><span class="line">update test_test set test_test.name=&apos;pyx&apos; where code =5;</span><br><span class="line">//然后在session2中执行该sql2</span><br><span class="line"></span><br><span class="line">执行结果，sql2获取锁超时。</span><br></pre></td></tr></table></figure><p>结论：RC隔离级别下对快照读不加锁，会存在重复读的数据不一致问题+幻读问题。对当前读，RC隔离级别会加锁，其他事务不允许修改已经被当前读锁定的修改记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=5 for update;</span><br><span class="line">//先在session1中执行该sql1</span><br><span class="line">id  name code</span><br><span class="line">13yqz   5</span><br><span class="line">14yqz   5</span><br><span class="line"></span><br><span class="line">insert into test_test values(20,&apos;yqz&apos;,7);//session2可以正常插入</span><br><span class="line">insert into test_test values(20,&apos;yqz&apos;,5);//session2不能插入，锁竞争</span><br><span class="line">update test_test set code=1 where id=13;//session2不能插入，锁竞争</span><br></pre></td></tr></table></figure><p>做了个图，分析下这里的加锁：</p><p>​    <img src="http://arthornye.github.io/images/lock.png" alt="cmd-markdown-logo"></p><p>结论：RC隔离级别对当前读会加锁，也会加GAP间隙锁防止两次当前读之间发生后幻读。但是两次快照读之前还是不能防止幻读的（这个在mysql事务和事务隔离机制文章中可以看到相关的介绍）。</p><p>分析，insert into test_test values(20,’yqz’,5)语句碰到了GAP间隙锁导致了锁竞争，update test_test set code=1 where id=13语句碰到了主键的记录导致了锁竞争。这也是为什么在根据un unique key遍历的时候我们要加两次锁的原因，因为可能有别的sql udpate是根据primary key来进行的。这里不熟悉mysql的索引的朋友们可以了解下mysql的索引结构，primary key对应的是聚族索引（innodb数据库引擎），基于B+TREE结构，在每个叶子结点都保存了完整的信息。但是建立的所有unuque key只保存了索引相关的信息，我们可以根据un unique key建立的B+TREE去遍历到primary key，再根据这个primary key去遍历主键索引。</p><h5 id="RC-UK（不可重复读-唯一索引）"><a href="#RC-UK（不可重复读-唯一索引）" class="headerlink" title="RC+UK（不可重复读+唯一索引）"></a>RC+UK（不可重复读+唯一索引）</h5><p>基于上面的分析，我们可以类比得到，这种情况下当前读也会在unique key对应的结果加排他锁，同时也加两个间隙锁。在对应的主键记录的叶子节点位置加排他锁，不存在幻读问题。但是针对快照读在RC隔离级别下还是会存在不可重复读+幻读问题。</p><h5 id="RR-UK（可重复读-唯一索引）"><a href="#RR-UK（可重复读-唯一索引）" class="headerlink" title="RR+UK（可重复读+唯一索引）"></a>RR+UK（可重复读+唯一索引）</h5><p>类比RC+UK，在当前读上的加锁处理没有什么区别，都不会存在重复读的问题和幻读问题。但是在快照读上，RR是通过了事务版本号和数据库记录版本号来限制了重复读不一致的问题的，也是旧版本的事务永远读不到新版本的事务提交的更改，删除以及新增记录。有的博客在介绍的时候会说是GAP间隙锁防止了幻读的发生，这个也有一定的道理，但是这个是针对当前读的，并不是针对快照读，快照读除非在串行的前提下才加锁，其他的情况都不加锁。</p><h5 id="RC-RR-NK（不可重复读-可重复读-无索引）"><a href="#RC-RR-NK（不可重复读-可重复读-无索引）" class="headerlink" title="RC/RR+NK（不可重复读/可重复读 +无索引）"></a>RC/RR+NK（不可重复读/可重复读 +无索引）</h5><p>无索引会直接根据主键进行全表扫描，同时会将整个表锁住，这种情况是及其低效的。</p><h4 id="分析一条复杂sql加锁"><a href="#分析一条复杂sql加锁" class="headerlink" title="分析一条复杂sql加锁"></a>分析一条复杂sql加锁</h4><p>通过上面的学习，我们尝试去分析一条sql的加锁情况：</p><p><img src="http://arthornye.github.io/images/sqllock.png" alt="cmd-markdown-logo"></p><p><strong><em>tips:这里有一种场景，mysql innodb默认会在这种查询的时候正向加锁（next-key lock===gap锁+右边的行锁），如果是倒序排序的话，会在倒序的末尾再加一个点。这是比较诡异的地方。</em></strong></p><h4 id="mysql死锁的发生"><a href="#mysql死锁的发生" class="headerlink" title="mysql死锁的发生"></a>mysql死锁的发生</h4><p>在mysql中也会发生一些死锁的情况，我们熟知发生死锁的条件能够帮助我们避免写出死锁。下面几种情况会发生死锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">session1</span><br><span class="line">select * from test_test where code=5 for udpate;</span><br><span class="line">select * from test_test where id=1 for update;</span><br><span class="line"></span><br><span class="line">session2</span><br><span class="line">select * from test_test where id=1 for update;</span><br><span class="line">select * from test_test where code=5 for udpate;</span><br><span class="line">//这种是比较简单的情况，循环加锁导致死锁</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">session1</span><br><span class="line">select * from test_test where code=5 for udpate;</span><br><span class="line">id  name code</span><br><span class="line">13yqz   5</span><br><span class="line">select * from test_test where code=4 for udpate;</span><br><span class="line">id  name code</span><br><span class="line">12yqz   4</span><br><span class="line"></span><br><span class="line">session2</span><br><span class="line">select * from test_test where id=12 for udpate;</span><br><span class="line">select * from test_test where id=13 for udpate;</span><br><span class="line"></span><br><span class="line">//这里虽然不是直接的进行了循环加锁，但是由于在聚簇索引的节点处也加了锁，实际上是有一个加锁的闭环的。我们通过mysql的加锁处理分析可以更准确的得到加锁信息，从而分析出死锁</span><br></pre></td></tr></table></figure><h4 id="MDL表级锁"><a href="#MDL表级锁" class="headerlink" title="MDL表级锁"></a>MDL表级锁</h4><p>mysql事务在执行的过程中，对表级别的操作分为两部分：表数据的增删改查，以及表结构的增删改查。表数据的增删改查需要获取MDL读锁，表结构的增删改查需要获取MDL写锁。MDL表级锁具备如下特性：</p><p><strong>1.MDL读锁是共享锁，不同事务不阻塞。</strong></p><p><strong>2.MDL写锁是独占锁，会阻塞在读锁和写锁上。</strong></p><p>表级锁在实际操作过程中，可能因为不恰当的操作导致业务发生异常，这里给个实例，下面三个事务依次执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">session a:</span><br><span class="line">begin;</span><br><span class="line">select * from test_test where code=2;//事务a获取到mdl表级锁的读锁</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session b:</span><br><span class="line">alter table add column city varchar(16);//事务b获取mdl写锁被block</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session c:</span><br><span class="line">select * from test_test where code=1;//事务c获取mdl读锁被block</span><br></pre></td></tr></table></figure><p>这里我们看到读锁和读锁之间虽然是共享锁，但是如果中间穿插了一个写锁的block，还是会有序被block住的。这里我们如果将事务a提交，mysql会依次执行b，c。所以我们在实际 操作过程中如果要对线上的数据的表进行变更，需要保证没有长事务，如果当前正有个长事务在对表数据进行操作，那么执行表结构变更的写操作会被block导致其他的读操作也被block。可以考虑在执行表结构变更的时候：</p><ul><li>查看执行中是否有长事务，kill长事务</li><li>alter等修改操作设置等待时间（需要引擎支持）</li></ul><h4 id="mysql行锁"><a href="#mysql行锁" class="headerlink" title="mysql行锁"></a>mysql行锁</h4><p>mysql中仅innodb支持行锁，其他引擎不支持行锁。我们通过一个实例来进行介绍mysql的行锁。假如A在B影院买了一张电影票，C也在B影院买了一张电影票。那么这两个事务都需要对客户账户余额做-操作，同时对影院的余额也做+操作。先介绍一些主要的概念再进行展开。</p><ul><li><strong>减少客户的账户余额</strong></li><li><strong>增加商家的账户余额</strong></li><li><strong>增加一条交易记录</strong></li></ul><p>上面的整个过程需要保证原子性。我们通常称之为一个事务，要么全部成功要么全部失败。</p><p><strong>两阶段锁协议</strong>：innodb中的行锁是需要的时候会进行加锁，但是并不是不需要的时候就会释放锁，需要事务提交之后才会释放锁。</p><p><strong>死锁：</strong>行锁发生了循环引用导致发生死锁，线程在锁上持续等待。</p><p><strong>如何解决死锁：</strong>代码中避免循环引用；可以通过设置超时时间和开启数据库死锁检测防止死锁。设置超时时间可能导致部分正常业务也就是没有发生死锁的事务被回滚，对业务是有损的；开启数据库死锁检测对业务是无损的，但是死锁的检测机制会占用大量的cpu。</p><p><strong>热点更新：</strong>这里我们讨论的热点更新，可以假设在上面的事务过程中，出现了双11类似的疯狂买票操作。那么这个场景下对商家余额的记录的写操作是非常频繁的。如果开始了死锁检测，那么等待的线程假设是1000个，那么这些线程会不断去检测死锁也就是1000*1000的复杂度，这个占用大量的cpu。</p><p><strong>如何解决热点更新：</strong> 在并发量比较大的情况下，我们可以通过增加热点更新记录的条数来减少锁的竞争。例如我们可以维护十条B账户余额的记录，在更新的时候随机取其中的某一条去更新，之后将所有的余额数据进行累加。这样的设计也是可以直接减少锁的竞争提高并发量。但是这样的设计需要考虑逆向操作，也就是如果发生退款操作导致其中的某条记录变成了0，代码需要特殊处理。</p><p><strong>并发量如何提高：</strong>尽量将一个事务中可能发生锁竞争的语句往后靠，前面的事务过程中增加商家的余额，这种热点更新其实可以放在后面，减少占有锁之后的锁持有时间。</p><p><strong>死锁检测：</strong>这里需要注意的是死锁检测是当前线程在发现锁阻塞之后就回去扫描别的线程，所以在并发量非常高的时候这个检测影响的性能也就更加明显。通常在秒杀的场景下，单个热点更新会导致不停的进行死锁检测，极大的降低了性能。 </p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本篇主要分析了mysql是如何进行加锁的处理的。mysql在RR隔离级别及以下对快照读是比较友好的，不会加锁，这样也极大地提高了数据库处理并发的能力。但是针对快照读RC隔离级别下还是不能防止幻读，也不能重复读。值得注意的是，mysql在RR,RC的隔离级别下都是有对当前读防止幻读的，通过加排他锁和间隙锁的共同使用。针对RR隔离级别的快照读，通过加版本号达到可重复读和防止幻读的目的。通过总结希望从sql语句，结合隔离级别以及索引判断出在执行过程中可能发生的加锁和锁竞争。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前的一篇文章介绍了mysql的四种隔离级别，本篇主要介绍一下mysql是如何进行加锁处理的。主要想了解mysql在处理高并发情况下的读写以及可能遇到的并发问题之间是如何去兼容的。我们都知道加锁是比较资源的操作，但是不加锁也会面临一些并发的问题，本篇文章将基于四种隔离级别去
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql事务和事务隔离机制</title>
    <link href="http://jianghao.wang/2018/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6/"/>
    <id>http://jianghao.wang/2018/mysql事务和事务隔离机制/</id>
    <published>2018-11-07T09:36:02.887Z</published>
    <updated>2018-11-21T02:06:56.503Z</updated>
    
    <content type="html"><![CDATA[<p>在学习mysql的事务隔离机制的过程中，对mysql的会话和事务的概念有点模糊不清，这里主要通过mysql可视化工具sequel pro来记录在实践过程中遇到的问题以及思考。</p><h4 id="mysql会话begin自动提交事务"><a href="#mysql会话begin自动提交事务" class="headerlink" title="mysql会话begin自动提交事务"></a>mysql会话begin自动提交事务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">update retail_order set order_status=111 where order_code=&apos;899120869590&apos;;</span><br></pre></td></tr></table></figure><p>我们建立一个mysql连接，然后开启一个会话session1，执行上面的sql。这条sql会在行记录上加锁。但是当前的事务是没有提交的，mysql的默认事务隔离机制是RR（可重复读）。我们在另一个会话session2中执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">update retail_order set order_status=111 where order_code=&apos;899120869590&apos;;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>会话2会报超时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure><p>通过这种方式我们成功验证了session1的事务还在执行中，数据库的记录已经上锁。</p><p>那么我们再去验证，当前会话的某个事务还在执行中，当前会话是不是可以继续执行其他事务，执行下面的select</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select order_status from retail_order where order_code=&apos;899120869590&apos;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">111</span><br></pre></td></tr></table></figure><p>实际上这个事务没有被提交上去，但是在本会话中再提交select却可以读取到这个值。这里其实我们应该将其理解为实际上本事务并没有提交，数据库会检测是同一个会话提交的sql，将其整合为一个未提交的事务。所以这里的变更对其他会话的事务依旧是不可见的。</p><p>那么什么时候这个事务什么时候会被提交？我们可以联想到是不是在执行一个commit本会话的事务便会被提交，对其他的会话可见。我们在session1单独执行一句commit，在session2中执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select order_status from retail_order where order_code=&apos;899120869590&apos;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">111</span><br></pre></td></tr></table></figure><p>可见我们的事务已经被提交了，同样的，我们发现在session1中执行一句begin，看session2同样查询的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">111</span><br></pre></td></tr></table></figure><p>做个总结：</p><p><code>当我们忘了对一个事务进行提交的时候，该会话接下来执行的事务也会叠加，直到我们显示的去进去提交或者开启一个新的事务。一个会话的事务没有提交可能导致另一个会话获取不到锁。</code></p><h4 id="mysql事务隔离机制"><a href="#mysql事务隔离机制" class="headerlink" title="mysql事务隔离机制"></a>mysql事务隔离机制</h4><p>熟悉了我们的可视化工具，我们尝试分析mysql的事务隔离机制，相信对mysql有基本了解的都知道，mysql的四种隔离机制。这四种隔离机制是我们分析数据库锁机制的基本，我也将会在本篇介绍隔离机制之后介绍一下mysql的锁机制。接下来的介绍需要我们去改变mysql的事务隔离机制，我们可以通过语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@global.tx_isolation,@@tx_isolation;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPEATABLE-READREPEATABLE-READ</span><br></pre></td></tr></table></figure><p>mysql的默认隔离机制RR,前一个是全局session的隔离级别，后一个是当前会话的隔离级别，我们可以在当前会话中设置隔离级别，通过sql语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level read committed; </span><br><span class="line">set session transaction isolation level repeatable read;</span><br></pre></td></tr></table></figure><h5 id="Read-Uncommited"><a href="#Read-Uncommited" class="headerlink" title="Read Uncommited"></a>Read Uncommited</h5><p>这个基本不用考虑，因为如果事务没有被提交就被其他的事务看到这样的设计从逻辑上来看是不合理的，会造成大量的脏读。</p><h5 id="Read-Commited-不可重复读"><a href="#Read-Commited-不可重复读" class="headerlink" title="Read Commited(不可重复读)"></a>Read Commited(不可重复读)</h5><p>在这个隔离机制下，事务在提交之后对另一个事务可见。如果在一个事务A的执行过程中进行了两次查询，事务B在查询间隙进行了数据更新，这个隔离级别会存在脏读+幻读的可能。我们新建一个test_test表，开启session1，执行事务A，不提交，模拟不可重复读：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1wmm1</span><br><span class="line">2wmm1</span><br><span class="line">3wmm1</span><br><span class="line">4wmm1</span><br><span class="line">5wmm1</span><br></pre></td></tr></table></figure><p>开启session2，执行事务B，直接提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update test_test set name=&apos;wmm&apos; where code=1;</span><br></pre></td></tr></table></figure><p>回到session1，执行查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br></pre></td></tr></table></figure><p>RC隔离级别下不可重复读，两次读的结果不一致。</p><p>用同样的方式，测试该隔离模式下会不会存在幻读：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert test_test values(6,&apos;yqz&apos;,1);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6yqz1</span><br></pre></td></tr></table></figure><p>该模式下存在幻读（如果没有显式begin开始一个事务，事务都默认自动提交，部分语句没有加begin，commit，自动提交）。</p><h4 id="Repeatable-Read-可重复读"><a href="#Repeatable-Read-可重复读" class="headerlink" title="Repeatable Read(可重复读)"></a>Repeatable Read(可重复读)</h4><p>首先通过恢复到该数据库隔离级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level repeatable read;</span><br></pre></td></tr></table></figure><p>模拟是否存在脏读，session1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6yqz1</span><br></pre></td></tr></table></figure><p>session2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update test_test set name=&apos;pyx&apos; where code=1;</span><br></pre></td></tr></table></figure><p>session1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6yqz1</span><br></pre></td></tr></table></figure><p>RR隔离模式下不存在脏读，那么mysql是如何实现该隔离模式下的避免脏读？了解过juc的cas的都知道我们可以通过在共享内存标记一个版本号，来防止aba问题。那么类比mysql也是通过在每行的记录后面添加一列标记版本号，读的时候不会修改这个版本号，但是更新删除都会版本号+1。参考上面的例子，session1在执行事务A的时候，假设当前事务的版本号为1，当前事务并没有提交，然后session2执行了更新事务B，提交之后数据库该行记录的版本号变成了2。在该隔离模式下事务A只会读取到版本号不大于当前事务版本号的记录，也就是说，虽然这条记录的更改已经在数据库真实存在，但是事务A并不能读取到这条记录的变更。</p><ul><li>SELECT时，读取创建版本号&lt;=当前事务版本号，删除版本号为空或&gt;当前事务版本号。</li><li>INSERT时，保存当前事务版本号为行的创建版本号。</li><li>DELETE时，保存当前事务版本号为行的删除版本号。</li><li>UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行。</li></ul><p><strong>2018.11.20增加对MVCC多版本并发控制的理解：</strong>如果我们数据库中某一条记录的值经历的版本变化为4-&gt;3-&gt;2-&gt;1，那么数据库引擎同时会记录一个回滚日志，根据对应事务的版本号去回滚到事务对应的值。</p><p><img src="http://arthornye.github.io/images/mvcc.png" alt="cmd-markdown-logo"></p><p>同样的方式看该该隔离级别下是否存在幻读，session1，事务A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6pyx1</span><br></pre></td></tr></table></figure><p>session2，事务B：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert test_test values(7,&apos;yqz&apos;,1);</span><br></pre></td></tr></table></figure><p>session1，事务A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6pyx1</span><br></pre></td></tr></table></figure><p>session1，事务A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit;</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6pyx1</span><br><span class="line">7yqz1</span><br></pre></td></tr></table></figure><p>可以看到这里是不存在幻读的，很多博客在介绍mysql的四种隔离级别的时候会说RR隔离模式下可以避免脏读但是不能避免幻读，我们通过实践看到这个级别是可以避免幻读的。</p><h4 id="Serializable-串行化"><a href="#Serializable-串行化" class="headerlink" title="Serializable(串行化)"></a>Serializable(串行化)</h4><p>这个隔离级别，个人的理解可以类比RetrantWriteReadLock的设计。事务在执行的时候如果数据行存在写锁（排他锁），读锁是共享锁，这种情况下会等待写锁释放。同样的如果是事务尝试去获取某个数据行的写锁，发现共享锁的读锁没有完全释放开，也需要等待读锁全部释放完才可以获取到写锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level serializable;</span><br></pre></td></tr></table></figure><p>将数据库隔离级别调整为串行，然后分别执行事务，session1，事务A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6pyx1</span><br><span class="line">7yqz1</span><br><span class="line">8yqz1</span><br></pre></td></tr></table></figure><p>session2，事务B：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update test_test set name=&apos;pyx&apos; where id=1</span><br></pre></td></tr></table></figure><p>执行结果，事务B，获取锁超时，Lock wait timeout exceeded; try restarting transaction。通过下面的语句也可以查看到当前存在锁竞争。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.innodb_locks</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5930258879:6688936:3:35930258879XRECORD`souche_retail`.`test_test`PRIMARY668893633NULL</span><br><span class="line">5930501833:6688936:3:35930501833SRECORD`souche_retail`.`test_test`PRIMARY668893633NULL</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本篇主要介绍了mysql的四种事务隔离级别，这里终结下它们的特点：</p><table><br><tr><br>    <th>Read Uncommited</th><br>    <th>不可重复读</th><br>    <th>幻读</th><br></tr><br><tr><br>    <th>Read Commited </th><br>    <th>不可重复读</th><br>    <th>幻读</th><br></tr><br><tr><br>    <th>Repeatable Read</th><br>    <th>可重复读</th><br>    <th>不存在幻读</th><br></tr><br><tr><br>    <th>Serializable</th><br>    <th>不可重复读</th><br>    <th>不存在幻读</th><br></tr><br></table><p>接下来的博客将会主要介绍mysql在这几种隔离机制下是如何加锁保持高并发情况下的数据一致性的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习mysql的事务隔离机制的过程中，对mysql的会话和事务的概念有点模糊不清，这里主要通过mysql可视化工具sequel pro来记录在实践过程中遇到的问题以及思考。&lt;/p&gt;
&lt;h4 id=&quot;mysql会话begin自动提交事务&quot;&gt;&lt;a href=&quot;#mysql会话
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Semaphore控制并发的信号量</title>
    <link href="http://jianghao.wang/2018/Semaphore%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <id>http://jianghao.wang/2018/Semaphore控制并发的信号量/</id>
    <published>2018-11-05T02:07:12.193Z</published>
    <updated>2018-11-07T03:10:35.130Z</updated>
    
    <content type="html"><![CDATA[<p>在面试的时候被问到关于java信号量，并没有很了解这个并发同步器，这里学习之后做一点简单的记录。Semaphore我们通常称之为信号量，这是用来控制同时访问某个资源的线程数量的一个同步器。比如数据库连接，如果数据库连接的数量只有10个，但是此时在执行的线程数量大于10个，那么线程会报错，获取不到数据库连接。为了防止这样的情况，我们可以通过信号量Semaphore来进行流量的控制。</p><h4 id="使用Semaphore控制并发流量"><a href="#使用Semaphore控制并发流量" class="headerlink" title="使用Semaphore控制并发流量"></a>使用Semaphore控制并发流量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 10/25/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个线程池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService threadPoolExecutor= Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="comment">//这里用信号量尝试控制流量</span></span><br><span class="line">            Semaphore semaphore =<span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//public static volatile int count=0;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++)&#123;</span><br><span class="line">            threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        semaphore.acquire();</span><br><span class="line">                        <span class="comment">//模拟获取数据库连接</span></span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">"   get database link : "</span>);</span><br><span class="line">                        semaphore.release();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Semaphore-API介绍"><a href="#Semaphore-API介绍" class="headerlink" title="Semaphore API介绍"></a>Semaphore API介绍</h4><p>Semaphore对每一个进入获取令牌的线程，都会尝试给予令牌，但是如果出现了供不应求的情况，每个线程需要的处理方式可能是不同的：</p><h5 id="semaphore-acquire"><a href="#semaphore-acquire" class="headerlink" title="semaphore.acquire()"></a>semaphore.acquire()</h5><p><strong>线程选择直接获取（非阻塞），进入等待队列，循环等待没获取到线程挂起</strong>。</p><p>通过源码分析在底层的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">               <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                   <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                   <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                       setHeadAndPropagate(node, r);</span><br><span class="line">                       p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                       failed = <span class="keyword">false</span>;</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<span class="comment">//公平加入等待队列，如果没获取到直接触发中断，直接抛出中断异常</span></span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>##### </p><h5 id="semaphore-tryAcquire"><a href="#semaphore-tryAcquire" class="headerlink" title="semaphore.tryAcquire()"></a>semaphore.tryAcquire()</h5><p><strong>线程可以选择等待一段时间（非阻塞），如果超时获取不到返回false，检测到中断信号线程中断</strong>。</p><p>贴上源码的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">               <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//如果超时了返回获取锁失败</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())<span class="comment">//将中断信号标志位复位，同时抛出中断异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();<span class="comment">//检测到当前线程已经被中断，执行自我中断，抛出异常。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="semaphore-acquireUninterruptibly"><a href="#semaphore-acquireUninterruptibly" class="headerlink" title="semaphore.acquireUninterruptibly()"></a>semaphore.acquireUninterruptibly()</h5><p>获取锁的过程中不允许中断，线程会一直处于获取锁的状态，只会在失败之后将标志位置为true。</p><p>贴上源码的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Acquires in shared uninterruptible mode.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">               <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                   <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                   <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                       setHeadAndPropagate(node, r);</span><br><span class="line">                       p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                       <span class="keyword">if</span> (interrupted)</span><br><span class="line">                           selfInterrupt();</span><br><span class="line">                       failed = <span class="keyword">false</span>;</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   interrupted = <span class="keyword">true</span>;<span class="comment">//不抛出异常，方法不支持中断抛出异常</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="Semaphore的两种实现（公平or非公平）"><a href="#Semaphore的两种实现（公平or非公平）" class="headerlink" title="Semaphore的两种实现（公平or非公平）"></a>Semaphore的两种实现（公平or非公平）</h4><p>Semaphore信号量提供了两种实现，公平和非公平的方式，这个可以类比retrantlock的公平非公平机制。一个会加入等待队列，一个不会加入等待队列。我们看下两个的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">//不会中断哦，一直循环占用cpu</span></span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;<span class="comment">//非公平的方式也会一直循环直到获取成功，少了的话也会返回一个负值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasQueuedPredecessors())<span class="comment">//公平的方式这里多维护了一个队列，如果已经加入了队列，直接返回，队列中的线程会被调度。</span></span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>我们看到公平和非公平的方式只是多了一个方法，那么看下这个方法到底实现了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* <span class="meta">@return</span> &#123;<span class="meta">@code</span> <span class="keyword">true</span>&#125; <span class="keyword">if</span> there is a queued thread preceding the</span><br><span class="line">     *         current thread, and &#123;<span class="meta">@code</span> <span class="keyword">false</span>&#125; <span class="keyword">if</span> the current thread</span><br><span class="line">     *         is at the head of the queue or the queue is empty</span><br><span class="line">     * <span class="meta">@since</span> <span class="number">1.7</span></span><br><span class="line">     */</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">        <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">        <span class="comment">// thread is first in queue.</span></span><br><span class="line">        Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//这里是维护的node队列，node是记录一个线程信息的对象。该方法主要判断当前线程是否已经维护进了公平等待的队列中，如果维护进去了，就返回false，没有维护进去就返回true。也就是公平锁会直接返回一个-1，线程继续执行，进入等待队列中调度执行。</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在面试的时候被问到信号量当时也是蛮懵逼的，觉得自己深入了解过AQS队列同步器，但是对java原生实现的一些同步器了解并不是特别多。信号量这个名字并不是特别好理解，可以更形象的称之为令牌管理器。在并发线程比较多的时候，一些有限的资源类似数据库连接数不能及时供应，那么我们需要进行一个流量控制。对于客户端的请求来说，可以在一段时间获取不到这个令牌之后选择不再等待，也可以在获取令牌的方法一直等待直到被中断，或者干脆一直等下去，死磕。网上搜索的时候发现一篇介绍同样内容的[博客]还不错，可以mark下<a href="https://blog.csdn.net/hanchao5272/article/details/79780045。" target="_blank" rel="noopener">https://blog.csdn.net/hanchao5272/article/details/79780045。</a></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在面试的时候被问到关于java信号量，并没有很了解这个并发同步器，这里学习之后做一点简单的记录。Semaphore我们通常称之为信号量，这是用来控制同时访问某个资源的线程数量的一个同步器。比如数据库连接，如果数据库连接的数量只有10个，但是此时在执行的线程数量大于10个，那
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>动态规划经典案例</title>
    <link href="http://jianghao.wang/2018/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B/"/>
    <id>http://jianghao.wang/2018/动态规划经典案例/</id>
    <published>2018-08-22T03:45:39.000Z</published>
    <updated>2018-08-22T06:40:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>​    动态规划是算法中比较重要的一课，是一种典型的空间换取时间的算法。通常是可以用分治法取考虑一个动态规划问题，用递归实现代码上看起来更加浅显易懂。但是基于递归的实现都是n2的复杂度，这样的复杂度在递归栈到达一定深度的时候会变的非常慢，并且有非常多的重复操作。动态规划致力于将这类递归问题，通过空间换取时间，用容器的方式记录递归结果，减少了重复递归，同时降低了时间复杂度。</p><h4 id="最长子数组问题"><a href="#最长子数组问题" class="headerlink" title="最长子数组问题"></a>最长子数组问题</h4><p>​    找出一个数组的连续子数组的最大和。最先想到的solution应该是n2的两次遍历。但是这样的循环是非常耗时的。我们尝试用分治的方式去思考一个复杂的问题，这是算法设计过程中常用的思维。当我们考虑一个任意数组比如{10,-1,2,-4,3,-5,10}，找出最长的子数组。可以先找出{10,-1,2,-4,3,-5}的最长子数组，那么我们可以得到一个数学函数公式（今天想偷个懒，明早去公司画一画）：</p><p>​    <img src="http://arthornye.github.io/images/%E5%AD%90%E4%B8%B2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png" alt="cmd-markdown-logo"></p><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>​    通常得出递归数学公式之后我们可以直接写出一个直观的递归程序。递归程序如下，这里需要维护一个Sum类，需要记录最长子数组的起始元素位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> MaxSubArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 8/21/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer startIndex;</span><br><span class="line">    <span class="keyword">private</span> Integer sum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getStartIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStartIndex</span><span class="params">(Integer startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.startIndex = startIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSum</span><span class="params">(Integer sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sum = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxSubArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Integer[] integerArray=&#123;<span class="number">10</span>,-<span class="number">1</span>,<span class="number">2</span>,-<span class="number">4</span>,<span class="number">3</span>,-<span class="number">5</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        System.out.println(maxSubArray(integerArray,<span class="number">6</span>).getSum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Sum <span class="title">maxSubArray</span><span class="params">(Integer[] integers, Integer index)</span></span>&#123;</span><br><span class="line">        Sum sum=<span class="keyword">new</span> Sum();</span><br><span class="line">        <span class="keyword">if</span>(integers==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(integers!=<span class="keyword">null</span> &amp;&amp; index==<span class="number">0</span>)&#123;</span><br><span class="line">            sum.setStartIndex(<span class="number">0</span>);</span><br><span class="line">            sum.setSum(integers[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Sum tempSum=maxSubArray(integers,index-<span class="number">1</span>);<span class="comment">//一个递归嘛,调用栈在上面的地方pop哦，没问题哦（在这里递归到0的时候pop执行下面的方法栈）。这里获取到子集的最长子串</span></span><br><span class="line">            Integer tempSumValue=<span class="number">0</span>;</span><br><span class="line">            Integer tempIndex=<span class="number">0</span>;<span class="comment">//最长子串的起始元素。必须记录这个元素，不然无法计算最长子数组到integer[i]的和</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=tempSum.getStartIndex();i&lt;=index;i++)&#123;</span><br><span class="line">                tempSumValue+=integers[i];</span><br><span class="line">            &#125;<span class="comment">//计算最长子数组到integer[i]的和</span></span><br><span class="line">            <span class="keyword">if</span>(tempSumValue&lt;integers[index])&#123;</span><br><span class="line">                tempIndex=index;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tempIndex=tempSum.getStartIndex();</span><br><span class="line">            &#125;</span><br><span class="line">            Integer maxSum=max(max(tempSumValue,integers[index]),tempSum.getSum());<span class="comment">//取三种情况的最大值</span></span><br><span class="line">            sum.setStartIndex(tempIndex);<span class="comment">//设置当前递归数组的起始元素和最大数组和</span></span><br><span class="line">            sum.setSum(maxSum);</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="动态规划（DP）"><a href="#动态规划（DP）" class="headerlink" title="动态规划（DP）"></a>动态规划（DP）</h5><p>​    分析上面的递归程序，n2的效率+递归调用栈，空间和时间利用率都不高。我们通过动态规划进行优化，动态规划的精髓可以用空间去换取空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxSubArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Integer[] integerArray=&#123;<span class="number">10</span>,-<span class="number">1</span>,<span class="number">2</span>,-<span class="number">4</span>,<span class="number">3</span>,-<span class="number">5</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> MaxSum = integerArray[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> TempMaxSum = integerArray[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; integerArray.length;i++)<span class="comment">//n的复杂度</span></span><br><span class="line">        &#123;</span><br><span class="line">          TempMaxSum = max(integerArray[i],TempMaxSum + integerArray[i]);<span class="comment">//决定当前最大子数组以哪个元素开头</span></span><br><span class="line">          MaxSum = max(MaxSum,TempMaxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(MaxSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="斐波那契数列问题"><a href="#斐波那契数列问题" class="headerlink" title="斐波那契数列问题"></a>斐波那契数列问题</h4><p>​    斐波那契数列的性质可以得到如下的数学递推公式，同样，我们提供递归和动态规划两种实现方式，这里我们看一下递推的公式：</p><p>​    <img src="http://arthornye.github.io/images/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.png" alt="cmd-markdown-logo"></p><h5 id="递归-DP"><a href="#递归-DP" class="headerlink" title="递归+DP"></a>递归+DP</h5> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Fobi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 8/22/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FoboNaCiArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(fiboNaciDigui(<span class="number">6</span>));<span class="comment">//递归的求斐波那契数列</span></span><br><span class="line">        <span class="comment">//DP求斐波那契数列</span></span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        arrayList.add(<span class="number">0</span>);</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(fiboNaciDP(<span class="number">6</span>,arrayList));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Integer <span class="title">fiboNaciDigui</span><span class="params">(Integer i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fiboNaciDigui(i-<span class="number">1</span>)+fiboNaciDigui(i-<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Integer <span class="title">fiboNaciDP</span><span class="params">(Integer index,ArrayList&lt;Integer&gt; arrayList)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;index;i++)&#123;</span><br><span class="line">            arrayList.add(arrayList.get(i-<span class="number">1</span>)+arrayList.get(i-<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrayList.get(index-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    动态规划是算法中比较重要的一课，是一种典型的空间换取时间的算法。通常是可以用分治法取考虑一个动态规划问题，用递归实现代码上看起来更加浅显易懂。但是基于递归的实现都是n2的复杂度，这样的复杂度在递归栈到达一定深度的时候会变的非常慢，并且有非常多的重复操作。动态规划致
      
    
    </summary>
    
    
      <category term="大搜车的点滴记录" scheme="http://jianghao.wang/tags/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%9A%84%E7%82%B9%E6%BB%B4%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Java 8中的Stream API 详解</title>
    <link href="http://jianghao.wang/2018/Java-8%E4%B8%AD%E7%9A%84Streams-API-%E8%AF%A6%E8%A7%A3/"/>
    <id>http://jianghao.wang/2018/Java-8中的Streams-API-详解/</id>
    <published>2018-08-14T10:07:19.000Z</published>
    <updated>2018-08-15T07:23:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Stream-API概述"><a href="#Stream-API概述" class="headerlink" title="Stream API概述"></a>Stream API概述</h3><p>​    Stream是Java8中的一大亮点，它为容器集合的操作提供了一系列函数式编程方式，节省了大量的重复代码，同时也让代码变得更加简洁精炼。相信在运用java8之前的版本中，我们需要对容器进行操作，手写遍历手写赋值的过程使得代码十分臃肿并且可读性极差。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。可以说stream api是函数式+多核的结合物。</p><h3 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h3><p>​    在之前的工作中，曾经有个需求需要构造一个双层的map结构。我们拿到的是一个仓库的全列表，需要根据城市首字母去聚合所有的城市，然后根据城市去聚合这个城市的仓库列表。从复杂度上考虑，需要两次聚合操作，要有两次循环。这里贴一段java8之前的代码实现（相当繁琐，可读性极差）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TruckStoreDTO&gt; <span class="title">getStorageList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       StorageQO storageQO=<span class="keyword">new</span> StorageQO();</span><br><span class="line">       Page&lt;StorageDTO&gt; storageDTOPage=remoteStorageService.query(storageQO,<span class="number">1</span>,<span class="number">200</span>);</span><br><span class="line">       <span class="keyword">if</span>(storageDTOPage!=<span class="keyword">null</span> &amp;&amp; storageDTOPage.getTotalNumber()!=<span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//获取到原始仓库列表数据</span></span><br><span class="line">           List&lt;StorageDTO&gt; storageDTOList=storageDTOPage.getItems();</span><br><span class="line">           <span class="comment">//根据城市首字母建立一个聚合列表，treemap遍历有序,查询匹配logn复杂度</span></span><br><span class="line">           TreeMap&lt;String,Map&lt;String,List&lt;StorageDetailDTO&gt;&gt;&gt; cityTreeMap=<span class="keyword">new</span> TreeMap();</span><br><span class="line">           <span class="keyword">for</span>(StorageDTO storageDTO:storageDTOList)&#123;</span><br><span class="line">               String pinyinCity= PingYingUtils.getPinYinFirstHeadChar(storageDTO.getCity());</span><br><span class="line">               <span class="comment">//获取到城市名拼音的首字母大写（同拼音城市列表map&lt;cityCode,list&lt;bean&gt;&gt;）</span></span><br><span class="line">               String firstPinyin=pinyinCity.toUpperCase();</span><br><span class="line"></span><br><span class="line">               <span class="comment">//根据城市的code聚合仓库列表，treemap匹配logn复杂度</span></span><br><span class="line">               Map&lt;String,List&lt;StorageDetailDTO&gt;&gt; cityStorageDTOMap;</span><br><span class="line">               List&lt;StorageDetailDTO&gt; storageDetailDTOList;</span><br><span class="line">               <span class="comment">//判断是否包含了该拼音的map&lt;cityCode,List&lt;StorageDetailDTO&gt;</span></span><br><span class="line">               <span class="keyword">if</span> (cityTreeMap.containsKey(firstPinyin)) &#123;</span><br><span class="line">                   cityStorageDTOMap=cityTreeMap.get(firstPinyin);</span><br><span class="line"></span><br><span class="line">                   StorageDetailDTO storageDetailDTO=<span class="keyword">new</span> StorageDetailDTO();</span><br><span class="line">                   storageDetailDTO.setStorageCode(storageDTO.getStorageCode());</span><br><span class="line">                   storageDetailDTO.setStorageName(storageDTO.getStorageName());</span><br><span class="line">                   storageDetailDTO.setCityName(storageDTO.getCity());</span><br><span class="line">                   storageDetailDTO.setAddress(storageDTO.getPlace());</span><br><span class="line">                   <span class="comment">//如果当前城市已经被插入(同城市列表list&lt;bean&gt;)</span></span><br><span class="line">                   <span class="keyword">if</span>(cityStorageDTOMap.containsKey(storageDTO.getCityCode()))&#123;</span><br><span class="line">                       <span class="comment">//在城市中插入多个仓库</span></span><br><span class="line">                       storageDetailDTOList=cityStorageDTOMap.get(storageDTO.getCityCode());</span><br><span class="line">                       storageDetailDTOList.add(storageDetailDTO);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//当前城市未被插入过</span></span><br><span class="line">                   <span class="keyword">else</span> &#123;</span><br><span class="line">                       storageDetailDTOList =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                       storageDetailDTOList.add(storageDetailDTO);</span><br><span class="line">                       cityStorageDTOMap.put(storageDTO.getCityCode(),storageDetailDTOList);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//当前首字母未被插入过</span></span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   cityStorageDTOMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">                   cityTreeMap.put(firstPinyin,cityStorageDTOMap);</span><br><span class="line"></span><br><span class="line">                   storageDetailDTOList =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                   StorageDetailDTO storageDetailDTO=<span class="keyword">new</span> StorageDetailDTO();</span><br><span class="line">                   storageDetailDTO.setStorageCode(storageDTO.getStorageCode());</span><br><span class="line">                   storageDetailDTO.setStorageName(storageDTO.getStorageName());</span><br><span class="line">                   storageDetailDTO.setCityName(storageDTO.getCity());</span><br><span class="line">                   storageDetailDTO.setAddress(storageDTO.getPlace());</span><br><span class="line">                   storageDetailDTOList.add(storageDetailDTO);</span><br><span class="line">                   cityStorageDTOMap.put(storageDTO.getCityCode(),storageDetailDTOList);</span><br><span class="line">                   cityTreeMap.put(firstPinyin,cityStorageDTOMap);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           List&lt;TruckStoreDTO&gt; truckStoreDTOList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span>(Map.Entry cityEntry:cityTreeMap.entrySet())&#123;</span><br><span class="line">               TruckStoreDTO truckStoreDTO=<span class="keyword">new</span> TruckStoreDTO();</span><br><span class="line">               Map&lt;String,List&lt;StorageDetailDTO&gt;&gt; storageDetailListMap=(Map&lt;String,List&lt;StorageDetailDTO&gt;&gt;)cityEntry.getValue();</span><br><span class="line">               List&lt;CityStorageDTO&gt; cityStorageDTOList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">               <span class="keyword">for</span>(Map.Entry storageEntry:storageDetailListMap.entrySet() )&#123;</span><br><span class="line">                   List&lt;StorageDetailDTO&gt; storageDetailDTOList=(List&lt;StorageDetailDTO&gt;)storageEntry.getValue();</span><br><span class="line">                   CityStorageDTO cityStorageDTO=<span class="keyword">new</span> CityStorageDTO();</span><br><span class="line">                   cityStorageDTO.setCityName(storageDetailDTOList.get(<span class="number">0</span>).getCityName());</span><br><span class="line">                   cityStorageDTO.setCityCode((String)storageEntry.getKey());</span><br><span class="line">                   cityStorageDTO.setStorageDetailDTOList(storageDetailDTOList);</span><br><span class="line">                   cityStorageDTOList.add(cityStorageDTO);</span><br><span class="line">               &#125;</span><br><span class="line">               truckStoreDTO.setCityStorageDTOList(cityStorageDTOList);</span><br><span class="line">               truckStoreDTO.setCityListKey((String)cityEntry.getKey());</span><br><span class="line">               truckStoreDTOList.add(truckStoreDTO);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> truckStoreDTOList;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这种实现的弊端：</p><p><strong><em>1.太多的循环导致可读性极差</em></strong></p><p><strong><em>2.重复冗余的代码过多</em></strong></p><p>那么我们希望通过Stream API去改善和优化这段代码，因为这段是之前在项目中的一段代码，我在这里进行模拟操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> StreamAPI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 8/14/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StorageTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;StorageDTO&gt; arrayList=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">27</span>;i++)&#123;</span><br><span class="line">            StorageDTO storageDTO=<span class="keyword">new</span> StorageDTO();</span><br><span class="line">            <span class="keyword">char</span> firstKey=(<span class="keyword">char</span>) (i+<span class="number">65</span>);</span><br><span class="line">            storageDTO.setCityFirstKey(String.valueOf(firstKey));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++) &#123;</span><br><span class="line">                String cityName=<span class="string">"city:"</span>+(<span class="keyword">char</span>) (j+<span class="number">65</span>);</span><br><span class="line">                storageDTO.setCityName(cityName);</span><br><span class="line">                storageDTO.setStorageName(<span class="string">"storage:"</span>+j);</span><br><span class="line">                arrayList.add(storageDTO);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//构造一个两次聚合的仓库数组列表</span></span><br><span class="line">        Stream stream= arrayList.stream();</span><br><span class="line">        Map&lt;String,Map&lt;String,List&lt;StorageDTO&gt;&gt;&gt;storageListMap=(Map&lt;String,Map&lt;String,List&lt;StorageDTO&gt;&gt;&gt;)stream.collect(Collectors.groupingBy(StorageDTO::getCityFirstKey,Collectors.groupingBy(StorageDTO::getCityName)));</span><br><span class="line">        <span class="comment">//通过stream的聚合操作可以直接完成上面的一堆代码的操作，一句代码vs一堆代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到这两种方式的对比是非常明显的，使用Stream API的聚合操作，代码可读性更强。</p><h3 id="流的使用详解"><a href="#流的使用详解" class="headerlink" title="流的使用详解"></a>流的使用详解</h3><p>​    一个流在处理的过程中可能有<strong>Intermediate</strong>（对原数据创建流这个过程会对数据进行过滤和筛选，这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历）。<strong>Terminal</strong>操作会开始真实的遍历过程，会将先前的lazy的遍历条件全部执行。</p><p>​    lazy操作的意思是我们在进行类似filter操作以及limit等操作，实际上并没有开始执行，因为这样如果执行会面临比较大的效率问题。一次循环执行所有的lazy条件，这是对函数式编程的一种技能上的提升。</p><h4 id="流是如何构造"><a href="#流是如何构造" class="headerlink" title="流是如何构造"></a>流是如何构造</h4><p>​    当我们需要去获取或者构造一个流的时候，因为流提供的是一种聚合操作，所以流的数据源是不分层的，类似于简单的对象列表，是没有维度的。那么我们可以通过数组去构造或者通过数组去获得流。常见的几种流的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stream stream = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);<span class="comment">//单纯通过数组去构造流</span></span><br><span class="line"></span><br><span class="line">String [] strArray = <span class="keyword">new</span> String[] &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">stream = Stream.of(strArray);</span><br><span class="line">stream = Arrays.stream(strArray);</span><br><span class="line"><span class="comment">//通过数组容器直接获取到流应该是最常用的一种方式</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(strArray);</span><br><span class="line">stream = list.stream();</span><br></pre></td></tr></table></figure><h4 id="流的主要API"><a href="#流的主要API" class="headerlink" title="流的主要API"></a>流的主要API</h4><p>​    这个模块会主要展示流的几种主要的api，这里根据<strong>Intermediate</strong>，<strong>Short-circuiting</strong>，<strong>Terminal</strong>进行分类：</p><ul><li><p>Intermediate：</p><p>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered</p></li><li><p>Terminal：</p><p>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</p></li><li><p>Short-circuiting：</p><p>anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</p><p>我们下面看一下 Stream 的比较典型用法：</p></li></ul><h5 id="map-flatMap"><a href="#map-flatMap" class="headerlink" title="map/flatMap"></a>map/flatMap</h5><p>map提供流数据一对一的映射操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       arrayList.add(<span class="string">"I"</span>);</span><br><span class="line">       arrayList.add(<span class="string">"LOVE"</span>);</span><br><span class="line">       arrayList.add(<span class="string">"U"</span>);</span><br><span class="line">       arrayList.add(<span class="string">"TOO"</span>);</span><br><span class="line">       arrayList.add(<span class="string">"MUCH"</span>);</span><br><span class="line">       Stream&lt;String&gt; stream=arrayList.stream();</span><br><span class="line">       <span class="comment">//用map将字段映射成小写</span></span><br><span class="line">       List&lt;String&gt; stringList=stream.map(String::toLowerCase).collect(Collectors.toList());</span><br><span class="line">       System.out.println(stringList);</span><br></pre></td></tr></table></figure><p>flatMap提供流数据的一对多映射操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(</span><br><span class="line"> Arrays.asList(<span class="number">1</span>),</span><br><span class="line"> Arrays.asList(<span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line"> Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"> );</span><br><span class="line">Stream&lt;Integer&gt; outputStream = inputStream.</span><br><span class="line">flatMap((childList) -&gt; childList.stream());</span><br><span class="line"><span class="comment">//将一个数组列表的数据扁平化，一对多映射操作</span></span><br></pre></td></tr></table></figure><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><p>filter操作进行进行过滤流数据。例如我们可以对数据急性偶数和奇数的过滤，类似的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer[] sixNums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">Integer[] evens =</span><br><span class="line">Stream.of(sixNums).filter(n -&gt; n%<span class="number">2</span> == <span class="number">0</span>).toArray(Integer[]::<span class="keyword">new</span>);</span><br><span class="line"><span class="comment">//过滤数据</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; output = reader.lines().</span><br><span class="line"> flatMap(line -&gt; Stream.of(line.split(REGEXP))).</span><br><span class="line"> filter(word -&gt; word.length() &gt; <span class="number">0</span>).</span><br><span class="line"> collect(Collectors.toList());</span><br><span class="line"><span class="comment">//过滤单词，flatMap将一行单词转换为一个单词列表</span></span><br></pre></td></tr></table></figure><h5 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h5><p>forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roster.stream()</span><br><span class="line"> .filter(p -&gt; p.getGender() == Person.Sex.MALE)</span><br><span class="line"> .forEach(p -&gt; System.out.println(p.getName()));</span><br></pre></td></tr></table></figure><p>另外需要注意的是如果对一个stream进行两次terminal操作，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stream.forEach(element -&gt; doOneThing(element));</span><br><span class="line">stream.forEach(element -&gt; doAnotherThing(element));</span><br></pre></td></tr></table></figure><p>运行时会报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.IllegalStateException: stream has already been operated upon or closed </span><br><span class="line">at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:<span class="number">229</span>)</span><br><span class="line">at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:<span class="number">499</span>)</span><br><span class="line">at StreamAPI.StreamAPITest.main(StreamAPITest.java:<span class="number">33</span>)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:<span class="number">497</span>)</span><br><span class="line">at com.intellij.rt.execution.application.AppMain.main(AppMain.java:<span class="number">144</span>)</span><br></pre></td></tr></table></figure><p>那么如果我们需要在流数据过滤的过程中进行打印，可以不用terminal操作，采用Intermediate操作，上面的代码可以通过peek操作达到打印的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>)</span><br><span class="line"> .filter(e -&gt; e.length() &gt; <span class="number">3</span>)</span><br><span class="line"> .peek(e -&gt; System.out.println(<span class="string">"Filtered value: "</span> + e))</span><br><span class="line"> .map(String::toUpperCase)</span><br><span class="line"> .peek(e -&gt; System.out.println(<span class="string">"Mapped value: "</span> + e))<span class="comment">//不是teminal操作，Intermediate操作不会报错</span></span><br><span class="line"> .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><p>字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce，例如 Stream 的 sum 就相当于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer sum = integers.reduce(<span class="number">0</span>, (a, b) -&gt; a+b); <span class="comment">//前面是是初始值，右边是操作的元素的函数</span></span><br><span class="line">Integer sum = integers.reduce(<span class="number">0</span>, Integer::sum);:<span class="comment">//sum的简写方式</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找出最长的单词用reduce</span></span><br><span class="line">Optional&lt;String&gt; longest=stream.reduce((s1, s2)-&gt;s1.length()&gt;s2.length()?s1:s2);</span><br><span class="line">System.out.println(<span class="string">"reduce操作找出最长的单词字符串:"</span>);</span><br><span class="line">System.out.println(longest.get());</span><br><span class="line"><span class="comment">//reduce操作拼接字符串</span></span><br><span class="line">String concatStr=stream.reduce(<span class="string">""</span>,String::concat);</span><br><span class="line">System.out.println(<span class="string">"reduce操作拼接字符串"</span>+concatStr);</span><br></pre></td></tr></table></figure><h5 id="limit-skip-sorted"><a href="#limit-skip-sorted" class="headerlink" title="limit/skip/sorted"></a>limit/skip/sorted</h5><p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来），正常的sorted操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; personList=persons.stream().sorted((p1,p2)-&gt;p1.getAge().compareTo(p2.getAge())).limit(<span class="number">3</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>讲到这里可能大家比较好奇的是，这个自带的api是如何保证执行效率的，或者说它内部的时间效率如果是n2那作为调用方其实是未知的。那么实际上排序的时间复杂度是 O(n log n)</p><h5 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h5><p>Stream 有三个 match 方法，从语义上说：</p><ul><li>allMatch：Stream 中全部元素符合传入的 predicate，返回 true</li><li>anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true</li><li>noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList();</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"name"</span> + <span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">2</span>, <span class="string">"name"</span> + <span class="number">2</span>, <span class="number">21</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">3</span>, <span class="string">"name"</span> + <span class="number">3</span>, <span class="number">34</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">4</span>, <span class="string">"name"</span> + <span class="number">4</span>, <span class="number">6</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">5</span>, <span class="string">"name"</span> + <span class="number">5</span>, <span class="number">55</span>));</span><br><span class="line"><span class="keyword">boolean</span> isAllAdult = persons.stream().</span><br><span class="line"> allMatch(p -&gt; p.getAge() &gt; <span class="number">18</span>);</span><br><span class="line">System.out.println(<span class="string">"All are adult? "</span> + isAllAdult);</span><br><span class="line"><span class="keyword">boolean</span> isThereAnyChild = persons.stream().</span><br><span class="line"> anyMatch(p -&gt; p.getAge() &lt; <span class="number">12</span>);</span><br><span class="line">System.out.println(<span class="string">"Any child? "</span> + isThereAnyChild);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">All are adult? <span class="keyword">false</span></span><br><span class="line">Any child? <span class="keyword">true</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>运用Stream API最明显的感觉是提供了类似c++提供的一系列STL容器操作。帮主我们对容器进行更方便可读性更强的处理，减少了很多常用的重复代码。之后在工作种可以用这种写法，这里做一个总结stream的特性：</p><ul><li>不是数据结构</li></ul><ul><li>它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。</li><li>它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。</li></ul><ul><li>所有 Stream 的操作必须以 lambda 表达式为参数</li><li>不支持索引访问</li></ul><ul><li>你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。</li></ul><ul><li>很容易生成数组或者 List</li><li>惰性化</li></ul><ul><li>很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。</li><li>Intermediate 操作永远是惰性化的。</li></ul><ul><li>并行能力</li></ul><ul><li>当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。</li></ul><ul><li>集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Stream-API概述&quot;&gt;&lt;a href=&quot;#Stream-API概述&quot; class=&quot;headerlink&quot; title=&quot;Stream API概述&quot;&gt;&lt;/a&gt;Stream API概述&lt;/h3&gt;&lt;p&gt;​    Stream是Java8中的一大亮点，它为容器集合
      
    
    </summary>
    
    
      <category term="大搜车的点滴记录" scheme="http://jianghao.wang/tags/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%9A%84%E7%82%B9%E6%BB%B4%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>ReetrantWriteReadLock读写锁</title>
    <link href="http://jianghao.wang/2018/ReetrantWriteReadLock%E8%AF%BB%E5%86%99%E9%94%81/"/>
    <id>http://jianghao.wang/2018/ReetrantWriteReadLock读写锁/</id>
    <published>2018-08-09T10:23:29.000Z</published>
    <updated>2018-08-14T08:02:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>####ReetrantWriteReadLock读写锁</p><p>​    Java的同步器，都基于AQS自定义同步器，那么如果设计一个自定义同步器。需要去适应不同的场景，例如我们在讲到ReetrantLock的实现时，它是基于AQS实现的一个可重入，可中断的锁，获取到锁的线程可以在同步块进行竞争对象的读写操作。但是我们可以设想，如果当前请求的线程多为读操作，那么加锁，释放锁的操作就会非常频繁，A线程在读的时候，B线程只能循环等待A线程释放锁（实际上此时此刻并没有线程进行写操作，并不会造城脏读），这样的话实际上是极大的牺牲了程序响应读的性能。</p><h4 id="等待／通知机制"><a href="#等待／通知机制" class="headerlink" title="等待／通知机制"></a>等待／通知机制</h4><p>​    在介绍读写锁的实现之前，介绍下java的线程通信机制wait／notify机制。之前有一篇博客，对比了CountDownLatch和CyclicBarrier，其中一个区别便是CountDownLatch 的主线程需要所有等待子线程完成。而CyclicBarrier建立在等待／通知机制上，实现了线程在等待之后重新被唤醒。</p><p>​    这里我们主要介绍synchronized+object的等待通知机制，建立在两个线程（等待线程和通知线程），可以类比为消费者线程和生产者线程。等待线程（消费者）在生产者完成生产操作之后从wait处继续执行。这里提供一种实现。定义一个消费者线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> NotifyWait;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 8/7/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String threadName;<span class="comment">//线程名</span></span><br><span class="line">    Object object;<span class="comment">//加锁</span></span><br><span class="line">    WaitThread(String threadName,Object object)&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadName=threadName;</span><br><span class="line">        <span class="keyword">this</span>.object=object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            <span class="comment">//看下是否执行了两次</span></span><br><span class="line">            System.out.println(<span class="string">"消费者线程进入同步块,flag:"</span>+NotifyWaitThread.flag);</span><br><span class="line">            <span class="keyword">while</span> (!NotifyWaitThread.flag) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(threadName+<span class="string">"消费者检测到生产者数据未生产完毕，开始等待...."</span>);</span><br><span class="line">                    object.wait();<span class="comment">//从同步队列中被唤醒的时候会重新从这里开始执行</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(threadName+<span class="string">"消费者检测到生产者得数据已经生产完毕，开始执行生产者线程..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个生产者线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> NotifyWait;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 8/7/18. 通知线程（类比生产者，去通知消费者，线程已经执行完毕，获取到所要的结果）</span></span><br><span class="line"><span class="comment"> * 通常在多个网络请求的过程中我们可以通过异步的方式分别去执行请求线程</span></span><br><span class="line"><span class="comment"> * 线程之间如果有数据结果依赖可以基于这种模型去等待通知（消费者等待生产者的数据请求结果）</span></span><br><span class="line"><span class="comment"> * 这里通过flag来模拟标示生产者是否已经将数据生产完毕</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    String threadName;<span class="comment">//线程名</span></span><br><span class="line">    Object object;<span class="comment">//加锁</span></span><br><span class="line">    NotifyThread(String threadName,Object object)&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadName=threadName;</span><br><span class="line">        <span class="keyword">this</span>.object=object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">            <span class="comment">//执行数据的生产过程，过程结束之后进行内存刷新，更新数据刷新成功标志</span></span><br><span class="line">            System.out.println(threadName+<span class="string">"开始生产数据"</span>);</span><br><span class="line">            NotifyWaitThread.flag=<span class="keyword">true</span>;</span><br><span class="line">            object.notifyAll();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.currentThread().sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(threadName+<span class="string">"生产者再次尝试获取锁"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启主线程启动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> NotifyWait;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 8/7/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyWaitThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object object=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> WaitThread(<span class="string">"WaitThread"</span>,object)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> NotifyThread(<span class="string">"NotifyThread"</span>,object)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程启动之后看下执行的结果，消费线程休眠10s，生产者线程先获得锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NotifyThread开始生产数据</span><br><span class="line">NotifyThread生产者再次尝试获取锁</span><br><span class="line">消费者线程进入同步块,flag:<span class="keyword">true</span></span><br><span class="line">WaitThread消费者检测到生产者得数据已经生产完毕，开始执行生产者线程...</span><br></pre></td></tr></table></figure><p>消费线程先获得锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">消费者线程进入同步块,flag:<span class="keyword">false</span></span><br><span class="line">WaitThread消费者检测到生产者数据未生产完毕，开始等待....</span><br><span class="line">NotifyThread开始生产数据</span><br><span class="line">NotifyThread生产者再次尝试获取锁</span><br><span class="line">WaitThread消费者检测到生产者得数据已经生产完毕，开始执行生产者线程...</span><br></pre></td></tr></table></figure><p>​    这里需要注意的一点是，在java的等待通知机制中是必须结合synchronized关键字的（锁的获取和释放）。调用object.wait()，object.notify()，object.notifyAll()，这些方法需要先对object对象进行加锁。下面总结一个经典的等待通知机制范式，等待方（消费者）需要遵循如下原则：</p><p>​    <strong>1.获取对象的锁。</strong></p><p>​    <strong>2.如果条件不满足，那么调用对象的wait方法，被通知到再次进行条件检查。</strong></p><p>​    <strong>3.条件满足之后执行相应的逻辑。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">  <span class="keyword">while</span>(条件不满足)&#123;<span class="comment">//volatile修饰，保证变量的线程可见性</span></span><br><span class="line">    对象.wait();</span><br><span class="line">  &#125;</span><br><span class="line">  对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通知方需要遵循如下原则：</p><p>​        <strong>1.获得对象的锁。</strong></p><p>​    <strong>2.改变判断条件。</strong></p><p>​    <strong>3.通知所有等待在对象上的线程重新开始执行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sychronized(对象)&#123;</span><br><span class="line">  改变条件</span><br><span class="line">    对象.notiryAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到java的等待通知机制完成了单个线程与单个线程的通信，控制代码的执行顺序。这在我们设计一个读写锁的时候，写的时候不能读，读的时候不能写，在写操作完成之后是可以通过这种方式通知读线程可以继续读的。但是基于这种范式的局限性，实际上通过sychronized关键字去修饰的代码块已经是串行执行。而我们的读写锁最终需要保证的是读锁（共享锁）多个线程可重入，而写锁（独占锁）不可重入。获取读锁需要判断当前没有写线程，获取写锁需要保证当前无读线程。</p><h4 id="ReetrantWriteReadLock的应用"><a href="#ReetrantWriteReadLock的应用" class="headerlink" title="ReetrantWriteReadLock的应用"></a>ReetrantWriteReadLock的应用</h4><p>根据ReetrantWriteReadLock的特性，我们可以封装一个线程不安全的hashMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ReetrantWriteAndReadLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于读写锁封装一个hashmap</span></span><br><span class="line"><span class="comment"> * Created by yqz on 8/9/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReetrantWriteAndReadLockExp</span> </span>&#123;</span><br><span class="line">    <span class="comment">//还是定义为volatile吧，不然在ReetrantWriteAndReadLockExp.get触发类加载，创建对象还未完成，就已经被另一个线程空指针调用。volatile的内存屏障可以保证new成功一个对象，写成功之后才被读。</span></span><br><span class="line">    <span class="comment">//这种模式在定义一个可能被并发获取的单例模式对象的时候，也需要定义为volatile，用内存屏障保证不会空指针。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> HashMap&lt;String,String&gt; hashMap=<span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ReadWriteLock readWriteLock=<span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Lock readLock=readWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Lock writeLock=readWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> hashMap.get(key);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key,String value)</span></span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hashMap.put(key,value);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读写锁的设计"><a href="#读写锁的设计" class="headerlink" title="读写锁的设计"></a>读写锁的设计</h4><p>​    读写锁需要在一个int类型的变量（AQS中的state变量）上维护读锁的状态和写锁的状态。按位分割，高十六位表示读锁的状态，低十六位表示写锁的状态，这两部分在判断读锁和写锁状态的时候需要按位去取。这样只需要保证整个int变量的线程可见性即可。可以看下jdk源码是如何去获取读锁和写锁的，获取读锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Walkthrough:</span></span><br><span class="line"><span class="comment">            * 1. If write lock held by another thread, fail.//如果写锁被其他线程持有，获取读锁失败</span></span><br><span class="line"><span class="comment">            * 2. Otherwise, this thread is eligible for</span></span><br><span class="line"><span class="comment">            *    lock wrt state, so ask if it should block</span></span><br><span class="line"><span class="comment">            *    because of queue policy. If not, try</span></span><br><span class="line"><span class="comment">            *    to grant by CASing state and updating count.</span></span><br><span class="line"><span class="comment">            *    Note that step does not check for reentrant</span></span><br><span class="line"><span class="comment">            *    acquires, which is postponed to full version</span></span><br><span class="line"><span class="comment">            *    to avoid having to check hold count in</span></span><br><span class="line"><span class="comment">            *    the more typical non-reentrant case.//读线程不阻塞，线程通过cas去累加读锁的count</span></span><br><span class="line"><span class="comment">            * 3. If step 2 fails either because thread</span></span><br><span class="line"><span class="comment">            *    apparently not eligible or CAS fails or count</span></span><br><span class="line"><span class="comment">            *    saturated, chain to version with full retry loop.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           Thread current = Thread.currentThread();</span><br><span class="line">           <span class="keyword">int</span> c = getState();</span><br><span class="line">           <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">               getExclusiveOwnerThread() != current)<span class="comment">//如果当前写锁的状态不为零，并且不是当前的线程持有锁（那么该读锁即使是共享锁，也是获取失败的）</span></span><br><span class="line">               <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">           <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;<span class="comment">//readerShouldBlock是判断当前锁是不是公平锁，如果是公平锁的话需要等待前置的线程队列，也就是会完全阻塞掉，循环等待调用。如果获取成功了读锁则增加读锁计数状态。</span></span><br><span class="line">               r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">               compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                   firstReader = current;</span><br><span class="line">                   firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                   firstReaderHoldCount++;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                   <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                       cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                       readHolds.set(rh);</span><br><span class="line">                   rh.count++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line"> <span class="comment">//这里循环阻塞，循环获取读锁，循环cas。</span></span><br><span class="line">           <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>获取写锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Walkthrough:</span></span><br><span class="line"><span class="comment">            * 1. If read count nonzero or write count nonzero</span></span><br><span class="line"><span class="comment">            *    and owner is a different thread, fail.//如果读锁的数量不为零或者写锁的数量不为零并且不是当前的线程持有这个写锁。</span></span><br><span class="line"><span class="comment">            * 2. If count would saturate, fail. (This can only</span></span><br><span class="line"><span class="comment">            *    happen if count is already nonzero.)//如果持有写锁的线程可重入最大次数，获取失败。</span></span><br><span class="line"><span class="comment">            * 3. Otherwise, this thread is eligible for lock if</span></span><br><span class="line"><span class="comment">            *    it is either a reentrant acquire or</span></span><br><span class="line"><span class="comment">            *    queue policy allows it. If so, update state</span></span><br><span class="line"><span class="comment">            *    and set owner.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           Thread current = Thread.currentThread();</span><br><span class="line">           <span class="keyword">int</span> c = getState();</span><br><span class="line">           <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">           <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">               <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">               <span class="comment">// Reentrant acquire</span></span><br><span class="line">               setState(c + acquires);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">  <span class="comment">//如果当前写锁的状态为零，并且是非公平锁，而且通过cas成功获取到了锁。那么将写锁的持有线程改写为当前线程。</span></span><br><span class="line">           <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">               !compareAndSetState(c, c + acquires))</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           setExclusiveOwnerThread(current);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    读写锁通过将读写分离，读锁作为一个共享锁，写锁作为一个独占锁，两个锁同时由一个volatile的int state维护，高位维护读锁，低位维护写锁。同时读锁和写锁都可以设置为公平和非公平。通过运用读写锁，可以在并发过程中保证读的正确性以及响应速度。读写锁非常适用于读的频率很高，但是写的频率很小的场景。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;####ReetrantWriteReadLock读写锁&lt;/p&gt;
&lt;p&gt;​    Java的同步器，都基于AQS自定义同步器，那么如果设计一个自定义同步器。需要去适应不同的场景，例如我们在讲到ReetrantLock的实现时，它是基于AQS实现的一个可重入，可中断的锁，获取
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch和CyclicBarrier</title>
    <link href="http://jianghao.wang/2018/CountDownLatch%E5%92%8CCyclicBarrier/"/>
    <id>http://jianghao.wang/2018/CountDownLatch和CyclicBarrier/</id>
    <published>2018-04-04T06:59:44.000Z</published>
    <updated>2018-04-04T06:59:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>CountDownLatch和CyclicBarrier都是给予AQS队列同步器实现的共享锁。</p><p>CountDownLatch是单纯通过维持一个state的计数数值，这个数值在线程调用countDownLatch.countDown()的时候会减1，当计数器的值为零的时候，等待的线程会向前执行。假如我们需要保证在主线程继续往前执行的时候，子任务都已经被启动，可以通过CountDownLatch来进行控制。实际上和ReetrantLock是基于同样的原理实现，不过是实现和覆盖了tryAccquireShare和tryReleaseShare的区别。</p><p>CyclicBarrier则和CountDownLatch以及ReetrantLock不相同，它是通过lock和等待／通知机制实现的，在CountDownLatch实现的多线程模型中，各个线程之间是没办法进行通信的，只能保证一个happens-before，但是CyclicBarrier通过lock+Condition来维持一个同步队列和等待队列（通常将等待在同步块外面的队列称之为同步队列，将等待在某个对象上的队列称之为等待队列），lock中的Condition对象可以有多个，也就是维护多个等待队列。我们观察CyclicBarrier的实现可以看到它的内部只维持了一个等待队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The lock for guarding barrier entry */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/** Condition to wait on until tripped */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();<span class="comment">//维持了一个等待队列，可以通过trip.signal唤醒等待队列中所有的节点加入到同步队列中。</span></span><br><span class="line">    <span class="comment">/** The number of parties */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line">    <span class="comment">/* The command to run when tripped */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line">    <span class="comment">/** The current generation */</span></span><br><span class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br></pre></td></tr></table></figure><h3 id="CountDownLatch的使用"><a href="#CountDownLatch的使用" class="headerlink" title="CountDownLatch的使用"></a>CountDownLatch的使用</h3><p>我们通过一段代码查看CountDownLatch的主要使用方式，我们定义一个woker线程，作为子任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 4/3/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String workerName;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(String workerName,CountDownLatch countDownLatch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.workerName=workerName;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch=countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doWorker();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWorker</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getWorkerName()+<span class="string">"释放一次共享锁"</span>);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWorkerName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> workerName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWorkerName</span><span class="params">(String workerName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.workerName = workerName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过main方法调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 4/3/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line">        ArrayList&lt;Thread&gt; arrayListWorker=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            arrayListWorker.add(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(<span class="string">"worker_"</span>+(i+<span class="number">1</span>),countDownLatch)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread worker:arrayListWorker)&#123;</span><br><span class="line">            worker.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"countDownLatch结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">worker_1释放一次共享锁</span><br><span class="line">worker_4释放一次共享锁</span><br><span class="line">worker_2释放一次共享锁</span><br><span class="line">worker_5释放一次共享锁</span><br><span class="line">worker_3释放一次共享锁</span><br><span class="line">countDownLatch结束</span><br></pre></td></tr></table></figure><p>这样的使用方式我们可以看到CountDownLatch实际上保证了当前主线程会等待所有的线程都启动，我们可以通过countDownLatch.countDown()这个方法去动态更改state的数值，主线程只有在state的数值变成0之后才会选择继续向前执行。这样的处理似乎很像thread.join这种等待当前线程执行结束在执行主线程的方式，不同的是使用CountDownLatch你不一定要保证线程已经执行结束进入死亡状态，你可以在线程执行栈中通过countDownLatch.countDown()手动更改这个state的数值，只要这个数值为0，主线程便可以开始运行。</p><h3 id="CountDownLatch源代码分析"><a href="#CountDownLatch源代码分析" class="headerlink" title="CountDownLatch源代码分析"></a>CountDownLatch源代码分析</h3><p>CountDownLatch实现的几个主要方法，通过内部的sync重写了AQS队列同步器中的获取和释放共享锁的方法。我们通过CountDownLatch的构造方法去设置state的数值。getCount可以获得当前的state值。通过countDown去循环cas减少state的数值，最后的await方法实现循环等待state的值，直到变为零。这里看下await方法的主要源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">  <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">      <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          setHeadAndPropagate(node, r);</span><br><span class="line">          p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">          failed = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">          parkAndCheckInterrupt())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">      cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CyclicBarrier的使用"><a href="#CyclicBarrier的使用" class="headerlink" title="CyclicBarrier的使用"></a>CyclicBarrier的使用</h3><p>对比CountDownLatch的使用我们可以发现CountDownLatch的缺陷是线程是完全互不干扰的，也就是没有相互的协同工作。CyclicBarrier通过lock维护一个同步队列，再通过locks.newCondition获取到的condition对象维护一个等待队列，形成等待／通知机制，conditon的await和signal类似于object的wait和notify。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 4/4/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    CyclicBarrier cyclicBarrier;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrierWorker</span><span class="params">(CyclicBarrier cyclicBarrier,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        <span class="keyword">this</span>.index=index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 用户开始抽奖，持续"</span>+(index+<span class="number">1</span>)+<span class="string">"秒"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((index+<span class="number">1</span>) * <span class="number">1000</span>);</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"所有用户抽奖完毕，颁发奖项。为用户"</span> + Thread.currentThread().getName() + <span class="string">"颁奖。"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数启动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 4/3/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"5个用户开始抽奖"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread(<span class="keyword">new</span> CyclicBarrierWorker(cyclicBarrier,index)), <span class="string">"Thread-"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>个用户开始抽奖Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">18</span> CST <span class="number">2018</span></span><br><span class="line">Thread-<span class="number">0</span> 用户开始抽奖，持续<span class="number">1</span>秒Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">19</span> CST <span class="number">2018</span></span><br><span class="line">Thread-<span class="number">1</span> 用户开始抽奖，持续<span class="number">2</span>秒Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">19</span> CST <span class="number">2018</span></span><br><span class="line">Thread-<span class="number">2</span> 用户开始抽奖，持续<span class="number">3</span>秒Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">19</span> CST <span class="number">2018</span></span><br><span class="line">Thread-<span class="number">3</span> 用户开始抽奖，持续<span class="number">4</span>秒Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">19</span> CST <span class="number">2018</span></span><br><span class="line">Thread-<span class="number">4</span> 用户开始抽奖，持续<span class="number">5</span>秒Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">19</span> CST <span class="number">2018</span></span><br><span class="line">所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">4</span>颁奖。Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">24</span> CST <span class="number">2018</span></span><br><span class="line">所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">0</span>颁奖。Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">24</span> CST <span class="number">2018</span></span><br><span class="line">所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">1</span>颁奖。Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">24</span> CST <span class="number">2018</span></span><br><span class="line">所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">2</span>颁奖。Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">24</span> CST <span class="number">2018</span></span><br><span class="line">所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">3</span>颁奖。Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">24</span> CST <span class="number">2018</span></span><br></pre></td></tr></table></figure><h3 id="CyclicBarrier源码分析"><a href="#CyclicBarrier源码分析" class="headerlink" title="CyclicBarrier源码分析"></a>CyclicBarrier源码分析</h3><p>这里主要分析cyclicBarrier.await方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Main barrier code, covering the various policies.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">TimeoutException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  lock.lock();<span class="comment">//所有进入同步队列获取锁</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g.broken)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">      breakBarrier();</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = --count;<span class="comment">//计数器的值减1</span></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped，如果计数值已经为零代表所有的线程都已经进入了condition对象的等待队列，可以开始通知等待队列进入同步队列。</span></span><br><span class="line">      <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">        <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">          command.run();</span><br><span class="line">        ranAction = <span class="keyword">true</span>;</span><br><span class="line">        nextGeneration();<span class="comment">//内部会调用signalAll方法通知等待队列。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ranAction)</span><br><span class="line">          breakBarrier();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timed)</span><br><span class="line">          trip.await(); <span class="comment">//放到Conditon的等待队列里，同时释放锁，让其他线程执行await方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">          nanos = trip.awaitNanos(nanos);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">          breakBarrier();</span><br><span class="line">          <span class="keyword">throw</span> ie;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">          <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">          <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">          Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (g.broken)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (g != generation)<span class="comment">//说明执行了nextGeneration方法，计数器到了0</span></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">        breakBarrier();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 唤醒Conditon等待队列上的所有线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// 计数器值变成原始值，重新开始</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// generation被重新构造</span></span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个执行的过程，线程在调用了await方法之后，会通过lock方式上锁，然后线程将计数器的值减1。如果计数器的值到达0，说明conditon维护的等待队列已满，调用nextGeneration唤醒condition等待队列上的所有线程。加入到同步队列中，然后返回index，释放锁，之后同步队列中的节点线程就可以被唤醒了。如果线程的计数器没有到达0，那更简单，这个时候其他线程会调用condition的await方法进入等待队列。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里总结下两者的主要区别：</p><ol><li>CountDownLatch用完之后就不能再次使用了，CyclicBarrier用完之后可以再次使用，CyclicBarrier还可以做reset操作</li><li>CountDownLatch底层使用的是共享锁，CyclicBarrier底层使用的是ReentrantLock和这个lock的条件对象Condition</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CountDownLatch和CyclicBarrier都是给予AQS队列同步器实现的共享锁。&lt;/p&gt;
&lt;p&gt;CountDownLatch是单纯通过维持一个state的计数数值，这个数值在线程调用countDownLatch.countDown()的时候会减1，当计数器的值
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>理解Java线程中断</title>
    <link href="http://jianghao.wang/2018/%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/"/>
    <id>http://jianghao.wang/2018/理解Java线程中断/</id>
    <published>2018-03-22T03:09:30.000Z</published>
    <updated>2018-03-22T08:19:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道lock和synchronized在同步运用上的显著区别之一就是lock支持可中断，而synchronized不支持可中断。那么可中断实际上是怎么实现的，或者说我们怎么去理解中断这个概念。在lock的实现ReetrantLock中其实我们可以看到很多中断的运用。我们都知道死锁，作为一种独占的互斥锁，通过中断我们可以保证线程在阻塞的过程中可以响应中断，也就是结束当前线程对cpu的占用，通过向上层抛出异常来结束当前线程。</p><h3 id="ReetrantLock中断的应用"><a href="#ReetrantLock中断的应用" class="headerlink" title="ReetrantLock中断的应用"></a>ReetrantLock中断的应用</h3><p>我们看到ReetrantLock是如何实现中断的，这里主要看到三种中断的运用：</p><h4 id="selfInterrupt"><a href="#selfInterrupt" class="headerlink" title="selfInterrupt()"></a>selfInterrupt()</h4><p>ReetrantLock提供了lock和lockIntteruptibly两种上锁方式，那么他们有什么本质的区别，我们看到lock的一段源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">      acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们分析这段代码，lock默认非公平锁的情况下在tryAcquire(arg)时并不会排队，如果获取不到会去 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)进行排队，如果该方法返回ture则进入线程自我中断。那么我们可以看下这段代码是如何实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())<span class="comment">//这里我们检验了中断标志是否被改变通过currentThread().isInterrupted(true)方法</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 这里的interrupted是我们定义的一个中断变量，可以看到这只是一个临时变量。当我们在队列中循环cas的时候，如果没有收到中断请求，那么最终会在第一组判断内进入并获取到锁，这是的中断标志为false，不中断，那么线程获取到锁之后开始执行同步代码块。但是如果在循环cas获取锁的过程中感知到了中断，中断的标志会被置为true，然后直接返回上层执行selfInterrupt()，我们再看下selfInterrupt()执行了什么操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Convenience method to interrupt current thread.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Thread.currentThread().interrupt();<span class="comment">//当前线程执行自我中断</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>总结：我们可以在获取锁的过程中记录一个临时变量，如果检测到当前执行线程被别的线程进行了某中断操作。将该临时变量置为true然后触发线程的自我中断。</p><h4 id="抛出InterruptedException-异常"><a href="#抛出InterruptedException-异常" class="headerlink" title="抛出InterruptedException()异常"></a>抛出InterruptedException()异常</h4><p>线程在检测到被中断的请求时，不会立即响应这个中断请求，因为它仅仅是改变了中断标示位，但是并不会直接触发中断，是否进行中断还是看当前线程什么时候去检测这个中断标示位。一般在阻塞锁的设计中，我们在循环等待的过程中会进行中断标志位的检测，从而进行InterruptedException()异常的抛出。这个中断异常的过程就好比，你妈妈会交代你好好吃饭，但是具体你是不是要好好吃饭，还是得由你自己决定，也就是我们在设计一个线程的run方法时，同样可以自定义一个volatile类型的中断标志位，来同步记录这个系统的标志位，然后在我们想要抛出异常的时候来检测这个标志位的变化，从而抛出相应的异常。这里看一段lockInterruptibly中的处理：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Acquires in exclusive interruptible mode.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">               <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                   setHead(node);</span><br><span class="line">                   p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                   failed = <span class="keyword">false</span>;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())<span class="comment">//检测到中断标示位被修改为true的时候直接向上层抛出异常。</span></span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="中断的相关方法"><a href="#中断的相关方法" class="headerlink" title="中断的相关方法"></a>中断的相关方法</h3><p>这里记录一下几个关键的调用中断的方法：</p><ul><li>public void interrupt()<br>将调用者线程的中断状态设为true。</li><li>public boolean isInterrupted()<br>判断调用者线程的中断状态。</li><li>public static boolean interrupted<br>只能通过Thread.interrupted()调用。<br>它会做两步操作：返回<strong>当前线程</strong>的中断状态同时将当前线程的中断状态设为false。</li></ul><p>线程通过检查自身是否被中断来进行响应，线程通过方法isInterrupted()来进行判断是否被中断，也可以通过调用静态方法Thread.interrupted()对当前线程的中断标示位进行复位。如果该线程已经处于终结状态，那么即使该线程被中断过，在调用该线程该线程对象的isInterrrupted()时会返回false。</p><p>我们查看java的api可以看到，很多会抛出中断异常的方法都会在抛出异常之前，java虚拟机首先将该线程的中断标示位清除。那么此时我们调用isInterrrupted()时会返回false。</p><h3 id="中断异常代码示例"><a href="#中断异常代码示例" class="headerlink" title="中断异常代码示例"></a>中断异常代码示例</h3><p>我们创建两个线程sleepThread和busyThread，第一个不停的执行休眠，第二个不停的执行循环代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Interrupted;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 3/22/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interrupted</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//新建一个睡眠线程</span></span><br><span class="line">        Thread sleepThread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"sleepThread"</span>);</span><br><span class="line">        <span class="comment">//新建一个忙碌的线程</span></span><br><span class="line">        Thread busyThread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"busyThread"</span>);</span><br><span class="line">        sleepThread.start();</span><br><span class="line">        busyThread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);<span class="comment">//线程休眠十秒</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        sleepThread.interrupt();</span><br><span class="line">        busyThread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"sleepThread的中断标志为："</span>+sleepThread.isInterrupted());</span><br><span class="line">        System.out.println(<span class="string">"busyThread的中断标志为："</span>+busyThread.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果为：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at Interrupted.Interrupted<span class="formula">$1.run(Interrupted.java:14)</span></span><br><span class="line"><span class="formula">at java.lang.Thread.run(Thread.java:745)</span></span><br><span class="line"><span class="formula">sleepThread的中断标志为：false</span></span><br><span class="line"><span class="formula">busyThread的中断标志为：true</span></span><br></pre></td></tr></table></figure><p>可以看到，抛出异常的线程的中断标示位被清除了，但是一直忙碌的线程因为并没有去判断中断标示位，所以即使中断标示位已经是true也不会执行中断操作。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>线程中断是一种是可以理解为一个线程对另一个线程做出了一个标示位的改变，通过触发线程中断会将中断标示位置为true，被中断的线程可以选择忽略这个标志，也可以选择在某个时刻校验标志位抛出异常，同时将标志位清除。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道lock和synchronized在同步运用上的显著区别之一就是lock支持可中断，而synchronized不支持可中断。那么可中断实际上是怎么实现的，或者说我们怎么去理解中断这个概念。在lock的实现ReetrantLock中其实我们可以看到很多中断的运用。我们
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
