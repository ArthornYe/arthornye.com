<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TizzyT&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/9dde1b9d65b89035e235650923e5811e</icon>
  <subtitle>即使是拖后腿的，拼死努力的话，也是可以超越精英的。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jianghao.wang/"/>
  <updated>2018-11-13T06:04:16.747Z</updated>
  <id>http://jianghao.wang/</id>
  
  <author>
    <name>yeqiaozhu</name>
    <email>yqz_zjut@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql加锁处理分析</title>
    <link href="http://jianghao.wang/2018/mysql%E5%8A%A0%E9%94%81%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://jianghao.wang/2018/mysql加锁处理分析/</id>
    <published>2018-11-12T06:07:22.527Z</published>
    <updated>2018-11-13T06:04:16.747Z</updated>
    
    <content type="html"><![CDATA[<p>之前的一篇文章介绍了mysql的四种隔离级别，本篇主要介绍一下mysql是如何进行加锁处理的。主要想了解mysql在处理高并发情况下的读写以及可能遇到的并发问题之间是如何去兼容的。我们都知道加锁是比较资源的操作，但是不加锁也会面临一些并发的问题，本篇文章将基于四种隔离级别去介绍mysql是如何进行加锁的处理的。</p><h4 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h4><p>我们需要先了解一下当前读和快照读的区别，实际上在mysql中是区分这两种读的，看两个sql语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from test_test where ? for update;//这一整个事务是一个当前读（实际上是一个写操作）</span><br><span class="line">select * from test_test where ?;//这个事务是一个快照读（实际上只是一个从数据库获取数据的操作）</span><br></pre></td></tr></table></figure><p><strong>当前读：delete，insert，update操作都可以视为当前读，从语义上可以理解为select for udpate，都是先读再写，需要保证并发的读写数据一致性。</strong></p><p><strong>快照读：单纯的select操作，数据库读取操作，不同的数据库隔离级别可能面临重复读的不一致问题和幻读问题。</strong></p><p>在mysql中，针对快照读只有在最高的隔离级别serializable级别下才会对快照读进行加锁，其他的级别下都是不加锁的。针对当前读，mysql在各个级别下为了防止并发的数据不一致问题都会进行加锁，加排他锁，也可以理解为写锁。</p><h4 id="各种隔离级别下的加锁机制"><a href="#各种隔离级别下的加锁机制" class="headerlink" title="各种隔离级别下的加锁机制"></a>各种隔离级别下的加锁机制</h4><p>我们探讨一下RC隔离级别下的几种索引遍历加锁处理的情况：</p><h5 id="RC-UUK（不可重复读-非唯一索引）"><a href="#RC-UUK（不可重复读-非唯一索引）" class="headerlink" title="RC+UUK（不可重复读+非唯一索引）"></a>RC+UUK（不可重复读+非唯一索引）</h5><p>我们将mysql的隔离级别调整为RC，建立一个test_test表，其中id是primary key，code是unique key。分别执行下面的sql：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=5 for update;</span><br><span class="line">//先在session1中执行该sql1</span><br><span class="line">id  name code</span><br><span class="line">13yqz   5</span><br><span class="line">14yqz   5</span><br><span class="line"></span><br><span class="line">update test_test set test_test.name=&apos;pyx&apos; where code =5;</span><br><span class="line">//然后在session2中执行该sql2</span><br><span class="line"></span><br><span class="line">执行结果，sql2获取锁超时。</span><br></pre></td></tr></table></figure><p>结论：RC隔离级别下对快照读不加锁，会存在重复读的数据不一致问题+幻读问题。对当前读，RC隔离级别会加锁，其他事务不允许修改已经被当前读锁定的修改记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=5 for update;</span><br><span class="line">//先在session1中执行该sql1</span><br><span class="line">id  name code</span><br><span class="line">13yqz   5</span><br><span class="line">14yqz   5</span><br><span class="line"></span><br><span class="line">insert into test_test values(20,&apos;yqz&apos;,7);//session2可以正常插入</span><br><span class="line">insert into test_test values(20,&apos;yqz&apos;,5);//session2不能插入，锁竞争</span><br><span class="line">update test_test set code=1 where id=13;//session2不能插入，锁竞争</span><br></pre></td></tr></table></figure><p>做了个图，分析下这里的加锁：</p><p>​    <img src="http://arthornye.github.io/images/lock.png" alt="cmd-markdown-logo"></p><p>结论：RC隔离级别对当前读会加锁，也会加GAP间隙锁防止两次当前读之间发生后幻读。但是两次快照读之前还是不能防止幻读的（这个在mysql事务和事务隔离机制文章中可以看到相关的介绍）。</p><p>分析，insert into test_test values(20,’yqz’,5)语句碰到了GAP间隙锁导致了锁竞争，update test_test set code=1 where id=13语句碰到了主键的记录导致了锁竞争。这也是为什么在根据un unique key遍历的时候我们要加两次锁的原因，因为可能有别的sql udpate是根据primary key来进行的。这里不熟悉mysql的索引的朋友们可以了解下mysql的索引结构，primary key对应的是聚族索引（innodb数据库引擎），基于B+TREE结构，在每个叶子结点都保存了完整的信息。但是建立的所有unuque key只保存了索引相关的信息，我们可以根据un unique key建立的B+TREE去遍历到primary key，再根据这个primary key去遍历主键索引。</p><h5 id="RC-UK（不可重复读-唯一索引）"><a href="#RC-UK（不可重复读-唯一索引）" class="headerlink" title="RC+UK（不可重复读+唯一索引）"></a>RC+UK（不可重复读+唯一索引）</h5><p>基于上面的分析，我们可以类比得到，这种情况下当前读也会在unique key对应的结果加排他锁，同时也加两个间隙锁。在对应的主键记录的叶子节点位置加排他锁，不存在幻读问题。但是针对快照读在RC隔离级别下还是会存在不可重复读+幻读问题。</p><h5 id="RR-UK（可重复读-唯一索引）"><a href="#RR-UK（可重复读-唯一索引）" class="headerlink" title="RR+UK（可重复读+唯一索引）"></a>RR+UK（可重复读+唯一索引）</h5><p>类比RC+UK，在当前读上的加锁处理没有什么区别，都不会存在重复读的问题和幻读问题。但是在快照读上，RR是通过了事务版本号和数据库记录版本号来限制了重复读不一致的问题的，也是旧版本的事务永远读不到新版本的事务提交的更改，删除以及新增记录。有的博客在介绍的时候会说是GAP间隙锁防止了幻读的发生，这个也有一定的道理，但是这个是针对当前读的，并不是针对快照读，快照读除非在串行的前提下才加锁，其他的情况都不加锁。</p><h5 id="RC-RR-NK（不可重复读-可重复读-无索引）"><a href="#RC-RR-NK（不可重复读-可重复读-无索引）" class="headerlink" title="RC/RR+NK（不可重复读/可重复读 +无索引）"></a>RC/RR+NK（不可重复读/可重复读 +无索引）</h5><p>无索引会直接根据主键进行全表扫描，同时会将整个表锁住，这种情况是及其低效的。</p><h4 id="分析一条复杂sql加锁"><a href="#分析一条复杂sql加锁" class="headerlink" title="分析一条复杂sql加锁"></a>分析一条复杂sql加锁</h4><p>通过上面的学习，我们尝试去分析一条sql的加锁情况：</p><p><img src="http://arthornye.github.io/images/sqllock.png" alt="cmd-markdown-logo"></p><h4 id="mysql死锁的发生"><a href="#mysql死锁的发生" class="headerlink" title="mysql死锁的发生"></a>mysql死锁的发生</h4><p>在mysql中也会发生一些死锁的情况，我们熟知发生死锁的条件能够帮助我们避免写出死锁。下面几种情况会发生死锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">session1</span><br><span class="line">select * from test_test where code=5 for udpate;</span><br><span class="line">select * from test_test where id=1 for update;</span><br><span class="line"></span><br><span class="line">session2</span><br><span class="line">select * from test_test where id=1 for update;</span><br><span class="line">select * from test_test where code=5 for udpate;</span><br><span class="line">//这种是比较简单的情况，循环加锁导致死锁</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">session1</span><br><span class="line">select * from test_test where code=5 for udpate;</span><br><span class="line">id  name code</span><br><span class="line">13yqz   5</span><br><span class="line">select * from test_test where code=4 for udpate;</span><br><span class="line">id  name code</span><br><span class="line">12yqz   4</span><br><span class="line"></span><br><span class="line">session2</span><br><span class="line">select * from test_test where id=12 for udpate;</span><br><span class="line">select * from test_test where id=13 for udpate;</span><br><span class="line"></span><br><span class="line">//这里虽然不是直接的进行了循环加锁，但是由于在聚簇索引的节点处也加了锁，实际上是有一个加锁的闭环的。我们通过mysql的加锁处理分析可以更准确的得到加锁信息，从而分析出死锁</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本篇主要分析了mysql是如何进行加锁的处理的。mysql在RR隔离级别及以下对快照读是比较友好的，不会加锁，这样也极大地提高了数据库处理并发的能力。但是针对快照读RC隔离级别下还是不能防止幻读，也不能重复读。值得注意的是，mysql在RR,RC的隔离级别下都是有对当前读防止幻读的，通过加排他锁和间隙锁的共同使用。针对RR隔离级别的快照读，通过加版本号达到可重复读和防止幻读的目的。通过总结希望从sql语句，结合隔离级别以及索引判断出在执行过程中可能发生的加锁和锁竞争。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前的一篇文章介绍了mysql的四种隔离级别，本篇主要介绍一下mysql是如何进行加锁处理的。主要想了解mysql在处理高并发情况下的读写以及可能遇到的并发问题之间是如何去兼容的。我们都知道加锁是比较资源的操作，但是不加锁也会面临一些并发的问题，本篇文章将基于四种隔离级别去
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql事务和事务隔离机制</title>
    <link href="http://jianghao.wang/2018/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6/"/>
    <id>http://jianghao.wang/2018/mysql事务和事务隔离机制/</id>
    <published>2018-11-07T09:36:02.887Z</published>
    <updated>2018-11-13T06:03:48.436Z</updated>
    
    <content type="html"><![CDATA[<p>在学习mysql的事务隔离机制的过程中，对mysql的会话和事务的概念有点模糊不清，这里主要通过mysql可视化工具sequel pro来记录在实践过程中遇到的问题以及思考。</p><h4 id="mysql会话begin自动提交事务"><a href="#mysql会话begin自动提交事务" class="headerlink" title="mysql会话begin自动提交事务"></a>mysql会话begin自动提交事务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">update retail_order set order_status=111 where order_code=&apos;899120869590&apos;;</span><br></pre></td></tr></table></figure><p>我们建立一个mysql连接，然后开启一个会话session1，执行上面的sql。这条sql会在行记录上加锁。但是当前的事务是没有提交的，mysql的默认事务隔离机制是RR（可重复读）。我们在另一个会话session2中执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">update retail_order set order_status=111 where order_code=&apos;899120869590&apos;;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>会话2会报超时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure><p>通过这种方式我们成功验证了session1的事务还在执行中，数据库的记录已经上锁。</p><p>那么我们再去验证，当前会话的某个事务还在执行中，当前会话是不是可以继续执行其他事务，执行下面的select</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select order_status from retail_order where order_code=&apos;899120869590&apos;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">111</span><br></pre></td></tr></table></figure><p>实际上这个事务没有被提交上去，但是在本会话中再提交select却可以读取到这个值。这里其实我们应该将其理解为实际上本事务并没有提交，数据库会检测是同一个会话提交的sql，将其整合为一个未提交的事务。所以这里的变更对其他会话的事务依旧是不可见的。</p><p>那么什么时候这个事务什么时候会被提交？我们可以联想到是不是在执行一个commit本会话的事务便会被提交，对其他的会话可见。我们在session1单独执行一句commit，在session2中执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select order_status from retail_order where order_code=&apos;899120869590&apos;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">111</span><br></pre></td></tr></table></figure><p>可见我们的事务已经被提交了，同样的，我们发现在session1中执行一句begin，看session2同样查询的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">111</span><br></pre></td></tr></table></figure><p>做个总结：</p><p><code>当我们忘了对一个事务进行提交的时候，该会话接下来执行的事务也会叠加，直到我们显示的去进去提交或者开启一个新的事务。一个会话的事务没有提交可能导致另一个会话获取不到锁。</code></p><h4 id="mysql事务隔离机制"><a href="#mysql事务隔离机制" class="headerlink" title="mysql事务隔离机制"></a>mysql事务隔离机制</h4><p>熟悉了我们的可视化工具，我们尝试分析mysql的事务隔离机制，相信对mysql有基本了解的都知道，mysql的四种隔离机制。这四种隔离机制是我们分析数据库锁机制的基本，我也将会在本篇介绍隔离机制之后介绍一下mysql的锁机制。接下来的介绍需要我们去改变mysql的事务隔离机制，我们可以通过语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@global.tx_isolation,@@tx_isolation;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPEATABLE-READREPEATABLE-READ</span><br></pre></td></tr></table></figure><p>mysql的默认隔离机制RR,前一个是全局session的隔离级别，后一个是当前会话的隔离级别，我们可以在当前会话中设置隔离级别，通过sql语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level read committed; </span><br><span class="line">set session transaction isolation level repeatable read;</span><br></pre></td></tr></table></figure><h5 id="Read-Uncommited"><a href="#Read-Uncommited" class="headerlink" title="Read Uncommited"></a>Read Uncommited</h5><p>这个基本不用考虑，因为如果事务没有被提交就被其他的事务看到这样的设计从逻辑上来看是不合理的，会造成大量的脏读。</p><h5 id="Read-Commited-不可重复读"><a href="#Read-Commited-不可重复读" class="headerlink" title="Read Commited(不可重复读)"></a>Read Commited(不可重复读)</h5><p>在这个隔离机制下，事务在提交之后对另一个事务可见。如果在一个事务A的执行过程中进行了两次查询，事务B在查询间隙进行了数据更新，这个隔离级别会存在脏读+幻读的可能。我们新建一个test_test表，开启session1，执行事务A，不提交，模拟不可重复读：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1wmm1</span><br><span class="line">2wmm1</span><br><span class="line">3wmm1</span><br><span class="line">4wmm1</span><br><span class="line">5wmm1</span><br></pre></td></tr></table></figure><p>开启session2，执行事务B，直接提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update test_test set name=&apos;wmm&apos; where code=1;</span><br></pre></td></tr></table></figure><p>回到session1，执行查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br></pre></td></tr></table></figure><p>RC隔离级别下不可重复读，两次读的结果不一致。</p><p>用同样的方式，测试该隔离模式下会不会存在幻读：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert test_test values(6,&apos;yqz&apos;,1);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6yqz1</span><br></pre></td></tr></table></figure><p>该模式下存在幻读（如果没有显式begin开始一个事务，事务都默认自动提交，部分语句没有加begin，commit，自动提交）。</p><h4 id="Repeatable-Read-可重复读"><a href="#Repeatable-Read-可重复读" class="headerlink" title="Repeatable Read(可重复读)"></a>Repeatable Read(可重复读)</h4><p>首先通过恢复到该数据库隔离级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level repeatable read;</span><br></pre></td></tr></table></figure><p>模拟是否存在脏读，session1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6yqz1</span><br></pre></td></tr></table></figure><p>session2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update test_test set name=&apos;pyx&apos; where code=1;</span><br></pre></td></tr></table></figure><p>session1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6yqz1</span><br></pre></td></tr></table></figure><p>RR隔离模式下不存在脏读，那么mysql是如何实现该隔离模式下的避免脏读？了解过juc的cas的都知道我们可以通过在共享内存标记一个版本号，来防止aba问题。那么类比mysql也是通过在每行的记录后面添加一列标记版本号，读的时候不会修改这个版本号，但是更新删除都会版本号+1。参考上面的例子，session1在执行事务A的时候，假设当前事务的版本号为1，当前事务并没有提交，然后session2执行了更新事务B，提交之后数据库该行记录的版本号变成了2。在该隔离模式下事务A只会读取到版本号不大于当前事务版本号的记录，也就是说，虽然这条记录的更改已经在数据库真实存在，但是事务A并不能读取到这条记录的变更。</p><ul><li>SELECT时，读取创建版本号&lt;=当前事务版本号，删除版本号为空或&gt;当前事务版本号。</li><li>INSERT时，保存当前事务版本号为行的创建版本号。</li><li>DELETE时，保存当前事务版本号为行的删除版本号。</li><li>UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行。</li></ul><p>同样的方式看该该隔离级别下是否存在幻读，session1，事务A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6pyx1</span><br></pre></td></tr></table></figure><p>session2，事务B：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert test_test values(7,&apos;yqz&apos;,1);</span><br></pre></td></tr></table></figure><p>session1，事务A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6pyx1</span><br></pre></td></tr></table></figure><p>session1，事务A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit;</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6pyx1</span><br><span class="line">7yqz1</span><br></pre></td></tr></table></figure><p>可以看到这里是不存在幻读的，很多博客在介绍mysql的四种隔离级别的时候会说RR隔离模式下可以避免脏读但是不能避免幻读，我们通过实践看到这个级别是可以避免幻读的。</p><h4 id="Serializable-串行化"><a href="#Serializable-串行化" class="headerlink" title="Serializable(串行化)"></a>Serializable(串行化)</h4><p>这个隔离级别，个人的理解可以类比RetrantWriteReadLock的设计。事务在执行的时候如果数据行存在写锁（排他锁），读锁是共享锁，这种情况下会等待写锁释放。同样的如果是事务尝试去获取某个数据行的写锁，发现共享锁的读锁没有完全释放开，也需要等待读锁全部释放完才可以获取到写锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level serializable;</span><br></pre></td></tr></table></figure><p>将数据库隔离级别调整为串行，然后分别执行事务，session1，事务A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6pyx1</span><br><span class="line">7yqz1</span><br><span class="line">8yqz1</span><br></pre></td></tr></table></figure><p>session2，事务B：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update test_test set name=&apos;pyx&apos; where id=1</span><br></pre></td></tr></table></figure><p>执行结果，事务B，获取锁超时，Lock wait timeout exceeded; try restarting transaction。通过下面的语句也可以查看到当前存在锁竞争。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.innodb_locks</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5930258879:6688936:3:35930258879XRECORD`souche_retail`.`test_test`PRIMARY668893633NULL</span><br><span class="line">5930501833:6688936:3:35930501833SRECORD`souche_retail`.`test_test`PRIMARY668893633NULL</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本篇主要介绍了mysql的四种事务隔离级别，这里终结下它们的特点：</p><table><br><tr><br>    <th>Read Uncommited</th><br>    <th>不可重复读</th><br>    <th>幻读</th><br></tr><br><tr><br>    <th>Read Commited </th><br>    <th>不可重复读</th><br>    <th>幻读</th><br></tr><br><tr><br>    <th>Repeatable Read</th><br>    <th>可重复读</th><br>    <th>不存在幻读</th><br></tr><br><tr><br>    <th>Serializable</th><br>    <th>不可重复读</th><br>    <th>不存在幻读</th><br></tr><br></table><p>接下来的博客将会主要介绍mysql在这几种隔离机制下是如何加锁保持高并发情况下的数据一致性的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习mysql的事务隔离机制的过程中，对mysql的会话和事务的概念有点模糊不清，这里主要通过mysql可视化工具sequel pro来记录在实践过程中遇到的问题以及思考。&lt;/p&gt;
&lt;h4 id=&quot;mysql会话begin自动提交事务&quot;&gt;&lt;a href=&quot;#mysql会话
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Semaphore控制并发的信号量</title>
    <link href="http://jianghao.wang/2018/Semaphore%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <id>http://jianghao.wang/2018/Semaphore控制并发的信号量/</id>
    <published>2018-11-05T02:07:12.193Z</published>
    <updated>2018-11-07T03:10:35.130Z</updated>
    
    <content type="html"><![CDATA[<p>在面试的时候被问到关于java信号量，并没有很了解这个并发同步器，这里学习之后做一点简单的记录。Semaphore我们通常称之为信号量，这是用来控制同时访问某个资源的线程数量的一个同步器。比如数据库连接，如果数据库连接的数量只有10个，但是此时在执行的线程数量大于10个，那么线程会报错，获取不到数据库连接。为了防止这样的情况，我们可以通过信号量Semaphore来进行流量的控制。</p><h4 id="使用Semaphore控制并发流量"><a href="#使用Semaphore控制并发流量" class="headerlink" title="使用Semaphore控制并发流量"></a>使用Semaphore控制并发流量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 10/25/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个线程池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService threadPoolExecutor= Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="comment">//这里用信号量尝试控制流量</span></span><br><span class="line">            Semaphore semaphore =<span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//public static volatile int count=0;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++)&#123;</span><br><span class="line">            threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        semaphore.acquire();</span><br><span class="line">                        <span class="comment">//模拟获取数据库连接</span></span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">"   get database link : "</span>);</span><br><span class="line">                        semaphore.release();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Semaphore-API介绍"><a href="#Semaphore-API介绍" class="headerlink" title="Semaphore API介绍"></a>Semaphore API介绍</h4><p>Semaphore对每一个进入获取令牌的线程，都会尝试给予令牌，但是如果出现了供不应求的情况，每个线程需要的处理方式可能是不同的：</p><h5 id="semaphore-acquire"><a href="#semaphore-acquire" class="headerlink" title="semaphore.acquire()"></a>semaphore.acquire()</h5><p><strong>线程选择直接获取（非阻塞），进入等待队列，循环等待没获取到线程挂起</strong>。</p><p>通过源码分析在底层的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">               <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                   <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                   <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                       setHeadAndPropagate(node, r);</span><br><span class="line">                       p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                       failed = <span class="keyword">false</span>;</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<span class="comment">//公平加入等待队列，如果没获取到直接触发中断，直接抛出中断异常</span></span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>##### </p><h5 id="semaphore-tryAcquire"><a href="#semaphore-tryAcquire" class="headerlink" title="semaphore.tryAcquire()"></a>semaphore.tryAcquire()</h5><p><strong>线程可以选择等待一段时间（非阻塞），如果超时获取不到返回false，检测到中断信号线程中断</strong>。</p><p>贴上源码的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">               <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//如果超时了返回获取锁失败</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())<span class="comment">//将中断信号标志位复位，同时抛出中断异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();<span class="comment">//检测到当前线程已经被中断，执行自我中断，抛出异常。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="semaphore-acquireUninterruptibly"><a href="#semaphore-acquireUninterruptibly" class="headerlink" title="semaphore.acquireUninterruptibly()"></a>semaphore.acquireUninterruptibly()</h5><p>获取锁的过程中不允许中断，线程会一直处于获取锁的状态，只会在失败之后将标志位置为true。</p><p>贴上源码的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Acquires in shared uninterruptible mode.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">               <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                   <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                   <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                       setHeadAndPropagate(node, r);</span><br><span class="line">                       p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                       <span class="keyword">if</span> (interrupted)</span><br><span class="line">                           selfInterrupt();</span><br><span class="line">                       failed = <span class="keyword">false</span>;</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   interrupted = <span class="keyword">true</span>;<span class="comment">//不抛出异常，方法不支持中断抛出异常</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="Semaphore的两种实现（公平or非公平）"><a href="#Semaphore的两种实现（公平or非公平）" class="headerlink" title="Semaphore的两种实现（公平or非公平）"></a>Semaphore的两种实现（公平or非公平）</h4><p>Semaphore信号量提供了两种实现，公平和非公平的方式，这个可以类比retrantlock的公平非公平机制。一个会加入等待队列，一个不会加入等待队列。我们看下两个的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">//不会中断哦，一直循环占用cpu</span></span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;<span class="comment">//非公平的方式也会一直循环直到获取成功，少了的话也会返回一个负值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasQueuedPredecessors())<span class="comment">//公平的方式这里多维护了一个队列，如果已经加入了队列，直接返回，队列中的线程会被调度。</span></span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>我们看到公平和非公平的方式只是多了一个方法，那么看下这个方法到底实现了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* <span class="meta">@return</span> &#123;<span class="meta">@code</span> <span class="keyword">true</span>&#125; <span class="keyword">if</span> there is a queued thread preceding the</span><br><span class="line">     *         current thread, and &#123;<span class="meta">@code</span> <span class="keyword">false</span>&#125; <span class="keyword">if</span> the current thread</span><br><span class="line">     *         is at the head of the queue or the queue is empty</span><br><span class="line">     * <span class="meta">@since</span> <span class="number">1.7</span></span><br><span class="line">     */</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">        <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">        <span class="comment">// thread is first in queue.</span></span><br><span class="line">        Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//这里是维护的node队列，node是记录一个线程信息的对象。该方法主要判断当前线程是否已经维护进了公平等待的队列中，如果维护进去了，就返回false，没有维护进去就返回true。也就是公平锁会直接返回一个-1，线程继续执行，进入等待队列中调度执行。</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在面试的时候被问到信号量当时也是蛮懵逼的，觉得自己深入了解过AQS队列同步器，但是对java原生实现的一些同步器了解并不是特别多。信号量这个名字并不是特别好理解，可以更形象的称之为令牌管理器。在并发线程比较多的时候，一些有限的资源类似数据库连接数不能及时供应，那么我们需要进行一个流量控制。对于客户端的请求来说，可以在一段时间获取不到这个令牌之后选择不再等待，也可以在获取令牌的方法一直等待直到被中断，或者干脆一直等下去，死磕。网上搜索的时候发现一篇介绍同样内容的[博客]还不错，可以mark下<a href="https://blog.csdn.net/hanchao5272/article/details/79780045。" target="_blank" rel="noopener">https://blog.csdn.net/hanchao5272/article/details/79780045。</a></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在面试的时候被问到关于java信号量，并没有很了解这个并发同步器，这里学习之后做一点简单的记录。Semaphore我们通常称之为信号量，这是用来控制同时访问某个资源的线程数量的一个同步器。比如数据库连接，如果数据库连接的数量只有10个，但是此时在执行的线程数量大于10个，那
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>动态规划经典案例</title>
    <link href="http://jianghao.wang/2018/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B/"/>
    <id>http://jianghao.wang/2018/动态规划经典案例/</id>
    <published>2018-08-22T03:45:39.000Z</published>
    <updated>2018-08-22T06:40:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>​    动态规划是算法中比较重要的一课，是一种典型的空间换取时间的算法。通常是可以用分治法取考虑一个动态规划问题，用递归实现代码上看起来更加浅显易懂。但是基于递归的实现都是n2的复杂度，这样的复杂度在递归栈到达一定深度的时候会变的非常慢，并且有非常多的重复操作。动态规划致力于将这类递归问题，通过空间换取时间，用容器的方式记录递归结果，减少了重复递归，同时降低了时间复杂度。</p><h4 id="最长子数组问题"><a href="#最长子数组问题" class="headerlink" title="最长子数组问题"></a>最长子数组问题</h4><p>​    找出一个数组的连续子数组的最大和。最先想到的solution应该是n2的两次遍历。但是这样的循环是非常耗时的。我们尝试用分治的方式去思考一个复杂的问题，这是算法设计过程中常用的思维。当我们考虑一个任意数组比如{10,-1,2,-4,3,-5,10}，找出最长的子数组。可以先找出{10,-1,2,-4,3,-5}的最长子数组，那么我们可以得到一个数学函数公式（今天想偷个懒，明早去公司画一画）：</p><p>​    <img src="http://arthornye.github.io/images/%E5%AD%90%E4%B8%B2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png" alt="cmd-markdown-logo"></p><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>​    通常得出递归数学公式之后我们可以直接写出一个直观的递归程序。递归程序如下，这里需要维护一个Sum类，需要记录最长子数组的起始元素位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> MaxSubArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 8/21/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer startIndex;</span><br><span class="line">    <span class="keyword">private</span> Integer sum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getStartIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStartIndex</span><span class="params">(Integer startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.startIndex = startIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSum</span><span class="params">(Integer sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sum = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxSubArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Integer[] integerArray=&#123;<span class="number">10</span>,-<span class="number">1</span>,<span class="number">2</span>,-<span class="number">4</span>,<span class="number">3</span>,-<span class="number">5</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        System.out.println(maxSubArray(integerArray,<span class="number">6</span>).getSum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Sum <span class="title">maxSubArray</span><span class="params">(Integer[] integers, Integer index)</span></span>&#123;</span><br><span class="line">        Sum sum=<span class="keyword">new</span> Sum();</span><br><span class="line">        <span class="keyword">if</span>(integers==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(integers!=<span class="keyword">null</span> &amp;&amp; index==<span class="number">0</span>)&#123;</span><br><span class="line">            sum.setStartIndex(<span class="number">0</span>);</span><br><span class="line">            sum.setSum(integers[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Sum tempSum=maxSubArray(integers,index-<span class="number">1</span>);<span class="comment">//一个递归嘛,调用栈在上面的地方pop哦，没问题哦（在这里递归到0的时候pop执行下面的方法栈）。这里获取到子集的最长子串</span></span><br><span class="line">            Integer tempSumValue=<span class="number">0</span>;</span><br><span class="line">            Integer tempIndex=<span class="number">0</span>;<span class="comment">//最长子串的起始元素。必须记录这个元素，不然无法计算最长子数组到integer[i]的和</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=tempSum.getStartIndex();i&lt;=index;i++)&#123;</span><br><span class="line">                tempSumValue+=integers[i];</span><br><span class="line">            &#125;<span class="comment">//计算最长子数组到integer[i]的和</span></span><br><span class="line">            <span class="keyword">if</span>(tempSumValue&lt;integers[index])&#123;</span><br><span class="line">                tempIndex=index;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tempIndex=tempSum.getStartIndex();</span><br><span class="line">            &#125;</span><br><span class="line">            Integer maxSum=max(max(tempSumValue,integers[index]),tempSum.getSum());<span class="comment">//取三种情况的最大值</span></span><br><span class="line">            sum.setStartIndex(tempIndex);<span class="comment">//设置当前递归数组的起始元素和最大数组和</span></span><br><span class="line">            sum.setSum(maxSum);</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="动态规划（DP）"><a href="#动态规划（DP）" class="headerlink" title="动态规划（DP）"></a>动态规划（DP）</h5><p>​    分析上面的递归程序，n2的效率+递归调用栈，空间和时间利用率都不高。我们通过动态规划进行优化，动态规划的精髓可以用空间去换取空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxSubArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Integer[] integerArray=&#123;<span class="number">10</span>,-<span class="number">1</span>,<span class="number">2</span>,-<span class="number">4</span>,<span class="number">3</span>,-<span class="number">5</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> MaxSum = integerArray[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> TempMaxSum = integerArray[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; integerArray.length;i++)<span class="comment">//n的复杂度</span></span><br><span class="line">        &#123;</span><br><span class="line">          TempMaxSum = max(integerArray[i],TempMaxSum + integerArray[i]);<span class="comment">//决定当前最大子数组以哪个元素开头</span></span><br><span class="line">          MaxSum = max(MaxSum,TempMaxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(MaxSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="斐波那契数列问题"><a href="#斐波那契数列问题" class="headerlink" title="斐波那契数列问题"></a>斐波那契数列问题</h4><p>​    斐波那契数列的性质可以得到如下的数学递推公式，同样，我们提供递归和动态规划两种实现方式，这里我们看一下递推的公式：</p><p>​    <img src="http://arthornye.github.io/images/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.png" alt="cmd-markdown-logo"></p><h5 id="递归-DP"><a href="#递归-DP" class="headerlink" title="递归+DP"></a>递归+DP</h5> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Fobi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 8/22/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FoboNaCiArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(fiboNaciDigui(<span class="number">6</span>));<span class="comment">//递归的求斐波那契数列</span></span><br><span class="line">        <span class="comment">//DP求斐波那契数列</span></span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        arrayList.add(<span class="number">0</span>);</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(fiboNaciDP(<span class="number">6</span>,arrayList));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Integer <span class="title">fiboNaciDigui</span><span class="params">(Integer i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fiboNaciDigui(i-<span class="number">1</span>)+fiboNaciDigui(i-<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Integer <span class="title">fiboNaciDP</span><span class="params">(Integer index,ArrayList&lt;Integer&gt; arrayList)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;index;i++)&#123;</span><br><span class="line">            arrayList.add(arrayList.get(i-<span class="number">1</span>)+arrayList.get(i-<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrayList.get(index-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    动态规划是算法中比较重要的一课，是一种典型的空间换取时间的算法。通常是可以用分治法取考虑一个动态规划问题，用递归实现代码上看起来更加浅显易懂。但是基于递归的实现都是n2的复杂度，这样的复杂度在递归栈到达一定深度的时候会变的非常慢，并且有非常多的重复操作。动态规划致
      
    
    </summary>
    
    
      <category term="大搜车的点滴记录" scheme="http://jianghao.wang/tags/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%9A%84%E7%82%B9%E6%BB%B4%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Java 8中的Stream API 详解</title>
    <link href="http://jianghao.wang/2018/Java-8%E4%B8%AD%E7%9A%84Streams-API-%E8%AF%A6%E8%A7%A3/"/>
    <id>http://jianghao.wang/2018/Java-8中的Streams-API-详解/</id>
    <published>2018-08-14T10:07:19.000Z</published>
    <updated>2018-08-15T07:23:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Stream-API概述"><a href="#Stream-API概述" class="headerlink" title="Stream API概述"></a>Stream API概述</h3><p>​    Stream是Java8中的一大亮点，它为容器集合的操作提供了一系列函数式编程方式，节省了大量的重复代码，同时也让代码变得更加简洁精炼。相信在运用java8之前的版本中，我们需要对容器进行操作，手写遍历手写赋值的过程使得代码十分臃肿并且可读性极差。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。可以说stream api是函数式+多核的结合物。</p><h3 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h3><p>​    在之前的工作中，曾经有个需求需要构造一个双层的map结构。我们拿到的是一个仓库的全列表，需要根据城市首字母去聚合所有的城市，然后根据城市去聚合这个城市的仓库列表。从复杂度上考虑，需要两次聚合操作，要有两次循环。这里贴一段java8之前的代码实现（相当繁琐，可读性极差）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TruckStoreDTO&gt; <span class="title">getStorageList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       StorageQO storageQO=<span class="keyword">new</span> StorageQO();</span><br><span class="line">       Page&lt;StorageDTO&gt; storageDTOPage=remoteStorageService.query(storageQO,<span class="number">1</span>,<span class="number">200</span>);</span><br><span class="line">       <span class="keyword">if</span>(storageDTOPage!=<span class="keyword">null</span> &amp;&amp; storageDTOPage.getTotalNumber()!=<span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//获取到原始仓库列表数据</span></span><br><span class="line">           List&lt;StorageDTO&gt; storageDTOList=storageDTOPage.getItems();</span><br><span class="line">           <span class="comment">//根据城市首字母建立一个聚合列表，treemap遍历有序,查询匹配logn复杂度</span></span><br><span class="line">           TreeMap&lt;String,Map&lt;String,List&lt;StorageDetailDTO&gt;&gt;&gt; cityTreeMap=<span class="keyword">new</span> TreeMap();</span><br><span class="line">           <span class="keyword">for</span>(StorageDTO storageDTO:storageDTOList)&#123;</span><br><span class="line">               String pinyinCity= PingYingUtils.getPinYinFirstHeadChar(storageDTO.getCity());</span><br><span class="line">               <span class="comment">//获取到城市名拼音的首字母大写（同拼音城市列表map&lt;cityCode,list&lt;bean&gt;&gt;）</span></span><br><span class="line">               String firstPinyin=pinyinCity.toUpperCase();</span><br><span class="line"></span><br><span class="line">               <span class="comment">//根据城市的code聚合仓库列表，treemap匹配logn复杂度</span></span><br><span class="line">               Map&lt;String,List&lt;StorageDetailDTO&gt;&gt; cityStorageDTOMap;</span><br><span class="line">               List&lt;StorageDetailDTO&gt; storageDetailDTOList;</span><br><span class="line">               <span class="comment">//判断是否包含了该拼音的map&lt;cityCode,List&lt;StorageDetailDTO&gt;</span></span><br><span class="line">               <span class="keyword">if</span> (cityTreeMap.containsKey(firstPinyin)) &#123;</span><br><span class="line">                   cityStorageDTOMap=cityTreeMap.get(firstPinyin);</span><br><span class="line"></span><br><span class="line">                   StorageDetailDTO storageDetailDTO=<span class="keyword">new</span> StorageDetailDTO();</span><br><span class="line">                   storageDetailDTO.setStorageCode(storageDTO.getStorageCode());</span><br><span class="line">                   storageDetailDTO.setStorageName(storageDTO.getStorageName());</span><br><span class="line">                   storageDetailDTO.setCityName(storageDTO.getCity());</span><br><span class="line">                   storageDetailDTO.setAddress(storageDTO.getPlace());</span><br><span class="line">                   <span class="comment">//如果当前城市已经被插入(同城市列表list&lt;bean&gt;)</span></span><br><span class="line">                   <span class="keyword">if</span>(cityStorageDTOMap.containsKey(storageDTO.getCityCode()))&#123;</span><br><span class="line">                       <span class="comment">//在城市中插入多个仓库</span></span><br><span class="line">                       storageDetailDTOList=cityStorageDTOMap.get(storageDTO.getCityCode());</span><br><span class="line">                       storageDetailDTOList.add(storageDetailDTO);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//当前城市未被插入过</span></span><br><span class="line">                   <span class="keyword">else</span> &#123;</span><br><span class="line">                       storageDetailDTOList =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                       storageDetailDTOList.add(storageDetailDTO);</span><br><span class="line">                       cityStorageDTOMap.put(storageDTO.getCityCode(),storageDetailDTOList);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//当前首字母未被插入过</span></span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   cityStorageDTOMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">                   cityTreeMap.put(firstPinyin,cityStorageDTOMap);</span><br><span class="line"></span><br><span class="line">                   storageDetailDTOList =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                   StorageDetailDTO storageDetailDTO=<span class="keyword">new</span> StorageDetailDTO();</span><br><span class="line">                   storageDetailDTO.setStorageCode(storageDTO.getStorageCode());</span><br><span class="line">                   storageDetailDTO.setStorageName(storageDTO.getStorageName());</span><br><span class="line">                   storageDetailDTO.setCityName(storageDTO.getCity());</span><br><span class="line">                   storageDetailDTO.setAddress(storageDTO.getPlace());</span><br><span class="line">                   storageDetailDTOList.add(storageDetailDTO);</span><br><span class="line">                   cityStorageDTOMap.put(storageDTO.getCityCode(),storageDetailDTOList);</span><br><span class="line">                   cityTreeMap.put(firstPinyin,cityStorageDTOMap);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           List&lt;TruckStoreDTO&gt; truckStoreDTOList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span>(Map.Entry cityEntry:cityTreeMap.entrySet())&#123;</span><br><span class="line">               TruckStoreDTO truckStoreDTO=<span class="keyword">new</span> TruckStoreDTO();</span><br><span class="line">               Map&lt;String,List&lt;StorageDetailDTO&gt;&gt; storageDetailListMap=(Map&lt;String,List&lt;StorageDetailDTO&gt;&gt;)cityEntry.getValue();</span><br><span class="line">               List&lt;CityStorageDTO&gt; cityStorageDTOList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">               <span class="keyword">for</span>(Map.Entry storageEntry:storageDetailListMap.entrySet() )&#123;</span><br><span class="line">                   List&lt;StorageDetailDTO&gt; storageDetailDTOList=(List&lt;StorageDetailDTO&gt;)storageEntry.getValue();</span><br><span class="line">                   CityStorageDTO cityStorageDTO=<span class="keyword">new</span> CityStorageDTO();</span><br><span class="line">                   cityStorageDTO.setCityName(storageDetailDTOList.get(<span class="number">0</span>).getCityName());</span><br><span class="line">                   cityStorageDTO.setCityCode((String)storageEntry.getKey());</span><br><span class="line">                   cityStorageDTO.setStorageDetailDTOList(storageDetailDTOList);</span><br><span class="line">                   cityStorageDTOList.add(cityStorageDTO);</span><br><span class="line">               &#125;</span><br><span class="line">               truckStoreDTO.setCityStorageDTOList(cityStorageDTOList);</span><br><span class="line">               truckStoreDTO.setCityListKey((String)cityEntry.getKey());</span><br><span class="line">               truckStoreDTOList.add(truckStoreDTO);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> truckStoreDTOList;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这种实现的弊端：</p><p><strong><em>1.太多的循环导致可读性极差</em></strong></p><p><strong><em>2.重复冗余的代码过多</em></strong></p><p>那么我们希望通过Stream API去改善和优化这段代码，因为这段是之前在项目中的一段代码，我在这里进行模拟操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> StreamAPI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 8/14/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StorageTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;StorageDTO&gt; arrayList=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">27</span>;i++)&#123;</span><br><span class="line">            StorageDTO storageDTO=<span class="keyword">new</span> StorageDTO();</span><br><span class="line">            <span class="keyword">char</span> firstKey=(<span class="keyword">char</span>) (i+<span class="number">65</span>);</span><br><span class="line">            storageDTO.setCityFirstKey(String.valueOf(firstKey));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++) &#123;</span><br><span class="line">                String cityName=<span class="string">"city:"</span>+(<span class="keyword">char</span>) (j+<span class="number">65</span>);</span><br><span class="line">                storageDTO.setCityName(cityName);</span><br><span class="line">                storageDTO.setStorageName(<span class="string">"storage:"</span>+j);</span><br><span class="line">                arrayList.add(storageDTO);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//构造一个两次聚合的仓库数组列表</span></span><br><span class="line">        Stream stream= arrayList.stream();</span><br><span class="line">        Map&lt;String,Map&lt;String,List&lt;StorageDTO&gt;&gt;&gt;storageListMap=(Map&lt;String,Map&lt;String,List&lt;StorageDTO&gt;&gt;&gt;)stream.collect(Collectors.groupingBy(StorageDTO::getCityFirstKey,Collectors.groupingBy(StorageDTO::getCityName)));</span><br><span class="line">        <span class="comment">//通过stream的聚合操作可以直接完成上面的一堆代码的操作，一句代码vs一堆代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到这两种方式的对比是非常明显的，使用Stream API的聚合操作，代码可读性更强。</p><h3 id="流的使用详解"><a href="#流的使用详解" class="headerlink" title="流的使用详解"></a>流的使用详解</h3><p>​    一个流在处理的过程中可能有<strong>Intermediate</strong>（对原数据创建流这个过程会对数据进行过滤和筛选，这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历）。<strong>Terminal</strong>操作会开始真实的遍历过程，会将先前的lazy的遍历条件全部执行。</p><p>​    lazy操作的意思是我们在进行类似filter操作以及limit等操作，实际上并没有开始执行，因为这样如果执行会面临比较大的效率问题。一次循环执行所有的lazy条件，这是对函数式编程的一种技能上的提升。</p><h4 id="流是如何构造"><a href="#流是如何构造" class="headerlink" title="流是如何构造"></a>流是如何构造</h4><p>​    当我们需要去获取或者构造一个流的时候，因为流提供的是一种聚合操作，所以流的数据源是不分层的，类似于简单的对象列表，是没有维度的。那么我们可以通过数组去构造或者通过数组去获得流。常见的几种流的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stream stream = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);<span class="comment">//单纯通过数组去构造流</span></span><br><span class="line"></span><br><span class="line">String [] strArray = <span class="keyword">new</span> String[] &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">stream = Stream.of(strArray);</span><br><span class="line">stream = Arrays.stream(strArray);</span><br><span class="line"><span class="comment">//通过数组容器直接获取到流应该是最常用的一种方式</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(strArray);</span><br><span class="line">stream = list.stream();</span><br></pre></td></tr></table></figure><h4 id="流的主要API"><a href="#流的主要API" class="headerlink" title="流的主要API"></a>流的主要API</h4><p>​    这个模块会主要展示流的几种主要的api，这里根据<strong>Intermediate</strong>，<strong>Short-circuiting</strong>，<strong>Terminal</strong>进行分类：</p><ul><li><p>Intermediate：</p><p>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered</p></li><li><p>Terminal：</p><p>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</p></li><li><p>Short-circuiting：</p><p>anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</p><p>我们下面看一下 Stream 的比较典型用法：</p></li></ul><h5 id="map-flatMap"><a href="#map-flatMap" class="headerlink" title="map/flatMap"></a>map/flatMap</h5><p>map提供流数据一对一的映射操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       arrayList.add(<span class="string">"I"</span>);</span><br><span class="line">       arrayList.add(<span class="string">"LOVE"</span>);</span><br><span class="line">       arrayList.add(<span class="string">"U"</span>);</span><br><span class="line">       arrayList.add(<span class="string">"TOO"</span>);</span><br><span class="line">       arrayList.add(<span class="string">"MUCH"</span>);</span><br><span class="line">       Stream&lt;String&gt; stream=arrayList.stream();</span><br><span class="line">       <span class="comment">//用map将字段映射成小写</span></span><br><span class="line">       List&lt;String&gt; stringList=stream.map(String::toLowerCase).collect(Collectors.toList());</span><br><span class="line">       System.out.println(stringList);</span><br></pre></td></tr></table></figure><p>flatMap提供流数据的一对多映射操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(</span><br><span class="line"> Arrays.asList(<span class="number">1</span>),</span><br><span class="line"> Arrays.asList(<span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line"> Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"> );</span><br><span class="line">Stream&lt;Integer&gt; outputStream = inputStream.</span><br><span class="line">flatMap((childList) -&gt; childList.stream());</span><br><span class="line"><span class="comment">//将一个数组列表的数据扁平化，一对多映射操作</span></span><br></pre></td></tr></table></figure><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><p>filter操作进行进行过滤流数据。例如我们可以对数据急性偶数和奇数的过滤，类似的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer[] sixNums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">Integer[] evens =</span><br><span class="line">Stream.of(sixNums).filter(n -&gt; n%<span class="number">2</span> == <span class="number">0</span>).toArray(Integer[]::<span class="keyword">new</span>);</span><br><span class="line"><span class="comment">//过滤数据</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; output = reader.lines().</span><br><span class="line"> flatMap(line -&gt; Stream.of(line.split(REGEXP))).</span><br><span class="line"> filter(word -&gt; word.length() &gt; <span class="number">0</span>).</span><br><span class="line"> collect(Collectors.toList());</span><br><span class="line"><span class="comment">//过滤单词，flatMap将一行单词转换为一个单词列表</span></span><br></pre></td></tr></table></figure><h5 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h5><p>forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roster.stream()</span><br><span class="line"> .filter(p -&gt; p.getGender() == Person.Sex.MALE)</span><br><span class="line"> .forEach(p -&gt; System.out.println(p.getName()));</span><br></pre></td></tr></table></figure><p>另外需要注意的是如果对一个stream进行两次terminal操作，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stream.forEach(element -&gt; doOneThing(element));</span><br><span class="line">stream.forEach(element -&gt; doAnotherThing(element));</span><br></pre></td></tr></table></figure><p>运行时会报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.IllegalStateException: stream has already been operated upon or closed </span><br><span class="line">at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:<span class="number">229</span>)</span><br><span class="line">at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:<span class="number">499</span>)</span><br><span class="line">at StreamAPI.StreamAPITest.main(StreamAPITest.java:<span class="number">33</span>)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:<span class="number">497</span>)</span><br><span class="line">at com.intellij.rt.execution.application.AppMain.main(AppMain.java:<span class="number">144</span>)</span><br></pre></td></tr></table></figure><p>那么如果我们需要在流数据过滤的过程中进行打印，可以不用terminal操作，采用Intermediate操作，上面的代码可以通过peek操作达到打印的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>)</span><br><span class="line"> .filter(e -&gt; e.length() &gt; <span class="number">3</span>)</span><br><span class="line"> .peek(e -&gt; System.out.println(<span class="string">"Filtered value: "</span> + e))</span><br><span class="line"> .map(String::toUpperCase)</span><br><span class="line"> .peek(e -&gt; System.out.println(<span class="string">"Mapped value: "</span> + e))<span class="comment">//不是teminal操作，Intermediate操作不会报错</span></span><br><span class="line"> .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><p>字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce，例如 Stream 的 sum 就相当于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer sum = integers.reduce(<span class="number">0</span>, (a, b) -&gt; a+b); <span class="comment">//前面是是初始值，右边是操作的元素的函数</span></span><br><span class="line">Integer sum = integers.reduce(<span class="number">0</span>, Integer::sum);:<span class="comment">//sum的简写方式</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找出最长的单词用reduce</span></span><br><span class="line">Optional&lt;String&gt; longest=stream.reduce((s1, s2)-&gt;s1.length()&gt;s2.length()?s1:s2);</span><br><span class="line">System.out.println(<span class="string">"reduce操作找出最长的单词字符串:"</span>);</span><br><span class="line">System.out.println(longest.get());</span><br><span class="line"><span class="comment">//reduce操作拼接字符串</span></span><br><span class="line">String concatStr=stream.reduce(<span class="string">""</span>,String::concat);</span><br><span class="line">System.out.println(<span class="string">"reduce操作拼接字符串"</span>+concatStr);</span><br></pre></td></tr></table></figure><h5 id="limit-skip-sorted"><a href="#limit-skip-sorted" class="headerlink" title="limit/skip/sorted"></a>limit/skip/sorted</h5><p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来），正常的sorted操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; personList=persons.stream().sorted((p1,p2)-&gt;p1.getAge().compareTo(p2.getAge())).limit(<span class="number">3</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>讲到这里可能大家比较好奇的是，这个自带的api是如何保证执行效率的，或者说它内部的时间效率如果是n2那作为调用方其实是未知的。那么实际上排序的时间复杂度是 O(n log n)</p><h5 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h5><p>Stream 有三个 match 方法，从语义上说：</p><ul><li>allMatch：Stream 中全部元素符合传入的 predicate，返回 true</li><li>anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true</li><li>noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList();</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"name"</span> + <span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">2</span>, <span class="string">"name"</span> + <span class="number">2</span>, <span class="number">21</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">3</span>, <span class="string">"name"</span> + <span class="number">3</span>, <span class="number">34</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">4</span>, <span class="string">"name"</span> + <span class="number">4</span>, <span class="number">6</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">5</span>, <span class="string">"name"</span> + <span class="number">5</span>, <span class="number">55</span>));</span><br><span class="line"><span class="keyword">boolean</span> isAllAdult = persons.stream().</span><br><span class="line"> allMatch(p -&gt; p.getAge() &gt; <span class="number">18</span>);</span><br><span class="line">System.out.println(<span class="string">"All are adult? "</span> + isAllAdult);</span><br><span class="line"><span class="keyword">boolean</span> isThereAnyChild = persons.stream().</span><br><span class="line"> anyMatch(p -&gt; p.getAge() &lt; <span class="number">12</span>);</span><br><span class="line">System.out.println(<span class="string">"Any child? "</span> + isThereAnyChild);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">All are adult? <span class="keyword">false</span></span><br><span class="line">Any child? <span class="keyword">true</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>运用Stream API最明显的感觉是提供了类似c++提供的一系列STL容器操作。帮主我们对容器进行更方便可读性更强的处理，减少了很多常用的重复代码。之后在工作种可以用这种写法，这里做一个总结stream的特性：</p><ul><li>不是数据结构</li></ul><ul><li>它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。</li><li>它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。</li></ul><ul><li>所有 Stream 的操作必须以 lambda 表达式为参数</li><li>不支持索引访问</li></ul><ul><li>你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。</li></ul><ul><li>很容易生成数组或者 List</li><li>惰性化</li></ul><ul><li>很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。</li><li>Intermediate 操作永远是惰性化的。</li></ul><ul><li>并行能力</li></ul><ul><li>当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。</li></ul><ul><li>集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Stream-API概述&quot;&gt;&lt;a href=&quot;#Stream-API概述&quot; class=&quot;headerlink&quot; title=&quot;Stream API概述&quot;&gt;&lt;/a&gt;Stream API概述&lt;/h3&gt;&lt;p&gt;​    Stream是Java8中的一大亮点，它为容器集合
      
    
    </summary>
    
    
      <category term="大搜车的点滴记录" scheme="http://jianghao.wang/tags/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%9A%84%E7%82%B9%E6%BB%B4%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>ReetrantWriteReadLock读写锁</title>
    <link href="http://jianghao.wang/2018/ReetrantWriteReadLock%E8%AF%BB%E5%86%99%E9%94%81/"/>
    <id>http://jianghao.wang/2018/ReetrantWriteReadLock读写锁/</id>
    <published>2018-08-09T10:23:29.000Z</published>
    <updated>2018-08-14T08:02:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>####ReetrantWriteReadLock读写锁</p><p>​    Java的同步器，都基于AQS自定义同步器，那么如果设计一个自定义同步器。需要去适应不同的场景，例如我们在讲到ReetrantLock的实现时，它是基于AQS实现的一个可重入，可中断的锁，获取到锁的线程可以在同步块进行竞争对象的读写操作。但是我们可以设想，如果当前请求的线程多为读操作，那么加锁，释放锁的操作就会非常频繁，A线程在读的时候，B线程只能循环等待A线程释放锁（实际上此时此刻并没有线程进行写操作，并不会造城脏读），这样的话实际上是极大的牺牲了程序响应读的性能。</p><h4 id="等待／通知机制"><a href="#等待／通知机制" class="headerlink" title="等待／通知机制"></a>等待／通知机制</h4><p>​    在介绍读写锁的实现之前，介绍下java的线程通信机制wait／notify机制。之前有一篇博客，对比了CountDownLatch和CyclicBarrier，其中一个区别便是CountDownLatch 的主线程需要所有等待子线程完成。而CyclicBarrier建立在等待／通知机制上，实现了线程在等待之后重新被唤醒。</p><p>​    这里我们主要介绍synchronized+object的等待通知机制，建立在两个线程（等待线程和通知线程），可以类比为消费者线程和生产者线程。等待线程（消费者）在生产者完成生产操作之后从wait处继续执行。这里提供一种实现。定义一个消费者线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> NotifyWait;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 8/7/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String threadName;<span class="comment">//线程名</span></span><br><span class="line">    Object object;<span class="comment">//加锁</span></span><br><span class="line">    WaitThread(String threadName,Object object)&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadName=threadName;</span><br><span class="line">        <span class="keyword">this</span>.object=object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            <span class="comment">//看下是否执行了两次</span></span><br><span class="line">            System.out.println(<span class="string">"消费者线程进入同步块,flag:"</span>+NotifyWaitThread.flag);</span><br><span class="line">            <span class="keyword">while</span> (!NotifyWaitThread.flag) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(threadName+<span class="string">"消费者检测到生产者数据未生产完毕，开始等待...."</span>);</span><br><span class="line">                    object.wait();<span class="comment">//从同步队列中被唤醒的时候会重新从这里开始执行</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(threadName+<span class="string">"消费者检测到生产者得数据已经生产完毕，开始执行生产者线程..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个生产者线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> NotifyWait;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 8/7/18. 通知线程（类比生产者，去通知消费者，线程已经执行完毕，获取到所要的结果）</span></span><br><span class="line"><span class="comment"> * 通常在多个网络请求的过程中我们可以通过异步的方式分别去执行请求线程</span></span><br><span class="line"><span class="comment"> * 线程之间如果有数据结果依赖可以基于这种模型去等待通知（消费者等待生产者的数据请求结果）</span></span><br><span class="line"><span class="comment"> * 这里通过flag来模拟标示生产者是否已经将数据生产完毕</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    String threadName;<span class="comment">//线程名</span></span><br><span class="line">    Object object;<span class="comment">//加锁</span></span><br><span class="line">    NotifyThread(String threadName,Object object)&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadName=threadName;</span><br><span class="line">        <span class="keyword">this</span>.object=object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">            <span class="comment">//执行数据的生产过程，过程结束之后进行内存刷新，更新数据刷新成功标志</span></span><br><span class="line">            System.out.println(threadName+<span class="string">"开始生产数据"</span>);</span><br><span class="line">            NotifyWaitThread.flag=<span class="keyword">true</span>;</span><br><span class="line">            object.notifyAll();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.currentThread().sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(threadName+<span class="string">"生产者再次尝试获取锁"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启主线程启动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> NotifyWait;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 8/7/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyWaitThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object object=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> WaitThread(<span class="string">"WaitThread"</span>,object)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> NotifyThread(<span class="string">"NotifyThread"</span>,object)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程启动之后看下执行的结果，消费线程休眠10s，生产者线程先获得锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NotifyThread开始生产数据</span><br><span class="line">NotifyThread生产者再次尝试获取锁</span><br><span class="line">消费者线程进入同步块,flag:<span class="keyword">true</span></span><br><span class="line">WaitThread消费者检测到生产者得数据已经生产完毕，开始执行生产者线程...</span><br></pre></td></tr></table></figure><p>消费线程先获得锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">消费者线程进入同步块,flag:<span class="keyword">false</span></span><br><span class="line">WaitThread消费者检测到生产者数据未生产完毕，开始等待....</span><br><span class="line">NotifyThread开始生产数据</span><br><span class="line">NotifyThread生产者再次尝试获取锁</span><br><span class="line">WaitThread消费者检测到生产者得数据已经生产完毕，开始执行生产者线程...</span><br></pre></td></tr></table></figure><p>​    这里需要注意的一点是，在java的等待通知机制中是必须结合synchronized关键字的（锁的获取和释放）。调用object.wait()，object.notify()，object.notifyAll()，这些方法需要先对object对象进行加锁。下面总结一个经典的等待通知机制范式，等待方（消费者）需要遵循如下原则：</p><p>​    <strong>1.获取对象的锁。</strong></p><p>​    <strong>2.如果条件不满足，那么调用对象的wait方法，被通知到再次进行条件检查。</strong></p><p>​    <strong>3.条件满足之后执行相应的逻辑。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">  <span class="keyword">while</span>(条件不满足)&#123;<span class="comment">//volatile修饰，保证变量的线程可见性</span></span><br><span class="line">    对象.wait();</span><br><span class="line">  &#125;</span><br><span class="line">  对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通知方需要遵循如下原则：</p><p>​        <strong>1.获得对象的锁。</strong></p><p>​    <strong>2.改变判断条件。</strong></p><p>​    <strong>3.通知所有等待在对象上的线程重新开始执行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sychronized(对象)&#123;</span><br><span class="line">  改变条件</span><br><span class="line">    对象.notiryAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到java的等待通知机制完成了单个线程与单个线程的通信，控制代码的执行顺序。这在我们设计一个读写锁的时候，写的时候不能读，读的时候不能写，在写操作完成之后是可以通过这种方式通知读线程可以继续读的。但是基于这种范式的局限性，实际上通过sychronized关键字去修饰的代码块已经是串行执行。而我们的读写锁最终需要保证的是读锁（共享锁）多个线程可重入，而写锁（独占锁）不可重入。获取读锁需要判断当前没有写线程，获取写锁需要保证当前无读线程。</p><h4 id="ReetrantWriteReadLock的应用"><a href="#ReetrantWriteReadLock的应用" class="headerlink" title="ReetrantWriteReadLock的应用"></a>ReetrantWriteReadLock的应用</h4><p>根据ReetrantWriteReadLock的特性，我们可以封装一个线程不安全的hashMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ReetrantWriteAndReadLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于读写锁封装一个hashmap</span></span><br><span class="line"><span class="comment"> * Created by yqz on 8/9/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReetrantWriteAndReadLockExp</span> </span>&#123;</span><br><span class="line">    <span class="comment">//还是定义为volatile吧，不然在ReetrantWriteAndReadLockExp.get触发类加载，创建对象还未完成，就已经被另一个线程空指针调用。volatile的内存屏障可以保证new成功一个对象，写成功之后才被读。</span></span><br><span class="line">    <span class="comment">//这种模式在定义一个可能被并发获取的单例模式对象的时候，也需要定义为volatile，用内存屏障保证不会空指针。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> HashMap&lt;String,String&gt; hashMap=<span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ReadWriteLock readWriteLock=<span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Lock readLock=readWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Lock writeLock=readWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> hashMap.get(key);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key,String value)</span></span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hashMap.put(key,value);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读写锁的设计"><a href="#读写锁的设计" class="headerlink" title="读写锁的设计"></a>读写锁的设计</h4><p>​    读写锁需要在一个int类型的变量（AQS中的state变量）上维护读锁的状态和写锁的状态。按位分割，高十六位表示读锁的状态，低十六位表示写锁的状态，这两部分在判断读锁和写锁状态的时候需要按位去取。这样只需要保证整个int变量的线程可见性即可。可以看下jdk源码是如何去获取读锁和写锁的，获取读锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Walkthrough:</span></span><br><span class="line"><span class="comment">            * 1. If write lock held by another thread, fail.//如果写锁被其他线程持有，获取读锁失败</span></span><br><span class="line"><span class="comment">            * 2. Otherwise, this thread is eligible for</span></span><br><span class="line"><span class="comment">            *    lock wrt state, so ask if it should block</span></span><br><span class="line"><span class="comment">            *    because of queue policy. If not, try</span></span><br><span class="line"><span class="comment">            *    to grant by CASing state and updating count.</span></span><br><span class="line"><span class="comment">            *    Note that step does not check for reentrant</span></span><br><span class="line"><span class="comment">            *    acquires, which is postponed to full version</span></span><br><span class="line"><span class="comment">            *    to avoid having to check hold count in</span></span><br><span class="line"><span class="comment">            *    the more typical non-reentrant case.//读线程不阻塞，线程通过cas去累加读锁的count</span></span><br><span class="line"><span class="comment">            * 3. If step 2 fails either because thread</span></span><br><span class="line"><span class="comment">            *    apparently not eligible or CAS fails or count</span></span><br><span class="line"><span class="comment">            *    saturated, chain to version with full retry loop.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           Thread current = Thread.currentThread();</span><br><span class="line">           <span class="keyword">int</span> c = getState();</span><br><span class="line">           <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">               getExclusiveOwnerThread() != current)<span class="comment">//如果当前写锁的状态不为零，并且不是当前的线程持有锁（那么该读锁即使是共享锁，也是获取失败的）</span></span><br><span class="line">               <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">           <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;<span class="comment">//readerShouldBlock是判断当前锁是不是公平锁，如果是公平锁的话需要等待前置的线程队列，也就是会完全阻塞掉，循环等待调用。如果获取成功了读锁则增加读锁计数状态。</span></span><br><span class="line">               r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">               compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                   firstReader = current;</span><br><span class="line">                   firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                   firstReaderHoldCount++;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                   <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                       cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                       readHolds.set(rh);</span><br><span class="line">                   rh.count++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line"> <span class="comment">//这里循环阻塞，循环获取读锁，循环cas。</span></span><br><span class="line">           <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>获取写锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Walkthrough:</span></span><br><span class="line"><span class="comment">            * 1. If read count nonzero or write count nonzero</span></span><br><span class="line"><span class="comment">            *    and owner is a different thread, fail.//如果读锁的数量不为零或者写锁的数量不为零并且不是当前的线程持有这个写锁。</span></span><br><span class="line"><span class="comment">            * 2. If count would saturate, fail. (This can only</span></span><br><span class="line"><span class="comment">            *    happen if count is already nonzero.)//如果持有写锁的线程可重入最大次数，获取失败。</span></span><br><span class="line"><span class="comment">            * 3. Otherwise, this thread is eligible for lock if</span></span><br><span class="line"><span class="comment">            *    it is either a reentrant acquire or</span></span><br><span class="line"><span class="comment">            *    queue policy allows it. If so, update state</span></span><br><span class="line"><span class="comment">            *    and set owner.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           Thread current = Thread.currentThread();</span><br><span class="line">           <span class="keyword">int</span> c = getState();</span><br><span class="line">           <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">           <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">               <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">               <span class="comment">// Reentrant acquire</span></span><br><span class="line">               setState(c + acquires);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">  <span class="comment">//如果当前写锁的状态为零，并且是非公平锁，而且通过cas成功获取到了锁。那么将写锁的持有线程改写为当前线程。</span></span><br><span class="line">           <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">               !compareAndSetState(c, c + acquires))</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           setExclusiveOwnerThread(current);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    读写锁通过将读写分离，读锁作为一个共享锁，写锁作为一个独占锁，两个锁同时由一个volatile的int state维护，高位维护读锁，低位维护写锁。同时读锁和写锁都可以设置为公平和非公平。通过运用读写锁，可以在并发过程中保证读的正确性以及响应速度。读写锁非常适用于读的频率很高，但是写的频率很小的场景。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;####ReetrantWriteReadLock读写锁&lt;/p&gt;
&lt;p&gt;​    Java的同步器，都基于AQS自定义同步器，那么如果设计一个自定义同步器。需要去适应不同的场景，例如我们在讲到ReetrantLock的实现时，它是基于AQS实现的一个可重入，可中断的锁，获取
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch和CyclicBarrier</title>
    <link href="http://jianghao.wang/2018/CountDownLatch%E5%92%8CCyclicBarrier/"/>
    <id>http://jianghao.wang/2018/CountDownLatch和CyclicBarrier/</id>
    <published>2018-04-04T06:59:44.000Z</published>
    <updated>2018-04-04T06:59:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>CountDownLatch和CyclicBarrier都是给予AQS队列同步器实现的共享锁。</p><p>CountDownLatch是单纯通过维持一个state的计数数值，这个数值在线程调用countDownLatch.countDown()的时候会减1，当计数器的值为零的时候，等待的线程会向前执行。假如我们需要保证在主线程继续往前执行的时候，子任务都已经被启动，可以通过CountDownLatch来进行控制。实际上和ReetrantLock是基于同样的原理实现，不过是实现和覆盖了tryAccquireShare和tryReleaseShare的区别。</p><p>CyclicBarrier则和CountDownLatch以及ReetrantLock不相同，它是通过lock和等待／通知机制实现的，在CountDownLatch实现的多线程模型中，各个线程之间是没办法进行通信的，只能保证一个happens-before，但是CyclicBarrier通过lock+Condition来维持一个同步队列和等待队列（通常将等待在同步块外面的队列称之为同步队列，将等待在某个对象上的队列称之为等待队列），lock中的Condition对象可以有多个，也就是维护多个等待队列。我们观察CyclicBarrier的实现可以看到它的内部只维持了一个等待队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The lock for guarding barrier entry */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/** Condition to wait on until tripped */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();<span class="comment">//维持了一个等待队列，可以通过trip.signal唤醒等待队列中所有的节点加入到同步队列中。</span></span><br><span class="line">    <span class="comment">/** The number of parties */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line">    <span class="comment">/* The command to run when tripped */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line">    <span class="comment">/** The current generation */</span></span><br><span class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br></pre></td></tr></table></figure><h3 id="CountDownLatch的使用"><a href="#CountDownLatch的使用" class="headerlink" title="CountDownLatch的使用"></a>CountDownLatch的使用</h3><p>我们通过一段代码查看CountDownLatch的主要使用方式，我们定义一个woker线程，作为子任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 4/3/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String workerName;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(String workerName,CountDownLatch countDownLatch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.workerName=workerName;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch=countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doWorker();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWorker</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getWorkerName()+<span class="string">"释放一次共享锁"</span>);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWorkerName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> workerName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWorkerName</span><span class="params">(String workerName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.workerName = workerName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过main方法调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 4/3/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line">        ArrayList&lt;Thread&gt; arrayListWorker=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            arrayListWorker.add(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(<span class="string">"worker_"</span>+(i+<span class="number">1</span>),countDownLatch)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread worker:arrayListWorker)&#123;</span><br><span class="line">            worker.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"countDownLatch结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">worker_1释放一次共享锁</span><br><span class="line">worker_4释放一次共享锁</span><br><span class="line">worker_2释放一次共享锁</span><br><span class="line">worker_5释放一次共享锁</span><br><span class="line">worker_3释放一次共享锁</span><br><span class="line">countDownLatch结束</span><br></pre></td></tr></table></figure><p>这样的使用方式我们可以看到CountDownLatch实际上保证了当前主线程会等待所有的线程都启动，我们可以通过countDownLatch.countDown()这个方法去动态更改state的数值，主线程只有在state的数值变成0之后才会选择继续向前执行。这样的处理似乎很像thread.join这种等待当前线程执行结束在执行主线程的方式，不同的是使用CountDownLatch你不一定要保证线程已经执行结束进入死亡状态，你可以在线程执行栈中通过countDownLatch.countDown()手动更改这个state的数值，只要这个数值为0，主线程便可以开始运行。</p><h3 id="CountDownLatch源代码分析"><a href="#CountDownLatch源代码分析" class="headerlink" title="CountDownLatch源代码分析"></a>CountDownLatch源代码分析</h3><p>CountDownLatch实现的几个主要方法，通过内部的sync重写了AQS队列同步器中的获取和释放共享锁的方法。我们通过CountDownLatch的构造方法去设置state的数值。getCount可以获得当前的state值。通过countDown去循环cas减少state的数值，最后的await方法实现循环等待state的值，直到变为零。这里看下await方法的主要源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">  <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">      <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          setHeadAndPropagate(node, r);</span><br><span class="line">          p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">          failed = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">          parkAndCheckInterrupt())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">      cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CyclicBarrier的使用"><a href="#CyclicBarrier的使用" class="headerlink" title="CyclicBarrier的使用"></a>CyclicBarrier的使用</h3><p>对比CountDownLatch的使用我们可以发现CountDownLatch的缺陷是线程是完全互不干扰的，也就是没有相互的协同工作。CyclicBarrier通过lock维护一个同步队列，再通过locks.newCondition获取到的condition对象维护一个等待队列，形成等待／通知机制，conditon的await和signal类似于object的wait和notify。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 4/4/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    CyclicBarrier cyclicBarrier;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrierWorker</span><span class="params">(CyclicBarrier cyclicBarrier,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        <span class="keyword">this</span>.index=index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 用户开始抽奖，持续"</span>+(index+<span class="number">1</span>)+<span class="string">"秒"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((index+<span class="number">1</span>) * <span class="number">1000</span>);</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"所有用户抽奖完毕，颁发奖项。为用户"</span> + Thread.currentThread().getName() + <span class="string">"颁奖。"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数启动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 4/3/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"5个用户开始抽奖"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread(<span class="keyword">new</span> CyclicBarrierWorker(cyclicBarrier,index)), <span class="string">"Thread-"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>个用户开始抽奖Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">18</span> CST <span class="number">2018</span></span><br><span class="line">Thread-<span class="number">0</span> 用户开始抽奖，持续<span class="number">1</span>秒Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">19</span> CST <span class="number">2018</span></span><br><span class="line">Thread-<span class="number">1</span> 用户开始抽奖，持续<span class="number">2</span>秒Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">19</span> CST <span class="number">2018</span></span><br><span class="line">Thread-<span class="number">2</span> 用户开始抽奖，持续<span class="number">3</span>秒Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">19</span> CST <span class="number">2018</span></span><br><span class="line">Thread-<span class="number">3</span> 用户开始抽奖，持续<span class="number">4</span>秒Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">19</span> CST <span class="number">2018</span></span><br><span class="line">Thread-<span class="number">4</span> 用户开始抽奖，持续<span class="number">5</span>秒Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">19</span> CST <span class="number">2018</span></span><br><span class="line">所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">4</span>颁奖。Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">24</span> CST <span class="number">2018</span></span><br><span class="line">所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">0</span>颁奖。Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">24</span> CST <span class="number">2018</span></span><br><span class="line">所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">1</span>颁奖。Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">24</span> CST <span class="number">2018</span></span><br><span class="line">所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">2</span>颁奖。Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">24</span> CST <span class="number">2018</span></span><br><span class="line">所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">3</span>颁奖。Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">24</span> CST <span class="number">2018</span></span><br></pre></td></tr></table></figure><h3 id="CyclicBarrier源码分析"><a href="#CyclicBarrier源码分析" class="headerlink" title="CyclicBarrier源码分析"></a>CyclicBarrier源码分析</h3><p>这里主要分析cyclicBarrier.await方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Main barrier code, covering the various policies.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">TimeoutException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  lock.lock();<span class="comment">//所有进入同步队列获取锁</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g.broken)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">      breakBarrier();</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = --count;<span class="comment">//计数器的值减1</span></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped，如果计数值已经为零代表所有的线程都已经进入了condition对象的等待队列，可以开始通知等待队列进入同步队列。</span></span><br><span class="line">      <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">        <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">          command.run();</span><br><span class="line">        ranAction = <span class="keyword">true</span>;</span><br><span class="line">        nextGeneration();<span class="comment">//内部会调用signalAll方法通知等待队列。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ranAction)</span><br><span class="line">          breakBarrier();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timed)</span><br><span class="line">          trip.await(); <span class="comment">//放到Conditon的等待队列里，同时释放锁，让其他线程执行await方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">          nanos = trip.awaitNanos(nanos);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">          breakBarrier();</span><br><span class="line">          <span class="keyword">throw</span> ie;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">          <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">          <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">          Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (g.broken)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (g != generation)<span class="comment">//说明执行了nextGeneration方法，计数器到了0</span></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">        breakBarrier();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 唤醒Conditon等待队列上的所有线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// 计数器值变成原始值，重新开始</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// generation被重新构造</span></span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个执行的过程，线程在调用了await方法之后，会通过lock方式上锁，然后线程将计数器的值减1。如果计数器的值到达0，说明conditon维护的等待队列已满，调用nextGeneration唤醒condition等待队列上的所有线程。加入到同步队列中，然后返回index，释放锁，之后同步队列中的节点线程就可以被唤醒了。如果线程的计数器没有到达0，那更简单，这个时候其他线程会调用condition的await方法进入等待队列。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里总结下两者的主要区别：</p><ol><li>CountDownLatch用完之后就不能再次使用了，CyclicBarrier用完之后可以再次使用，CyclicBarrier还可以做reset操作</li><li>CountDownLatch底层使用的是共享锁，CyclicBarrier底层使用的是ReentrantLock和这个lock的条件对象Condition</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CountDownLatch和CyclicBarrier都是给予AQS队列同步器实现的共享锁。&lt;/p&gt;
&lt;p&gt;CountDownLatch是单纯通过维持一个state的计数数值，这个数值在线程调用countDownLatch.countDown()的时候会减1，当计数器的值
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>理解Java线程中断</title>
    <link href="http://jianghao.wang/2018/%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/"/>
    <id>http://jianghao.wang/2018/理解Java线程中断/</id>
    <published>2018-03-22T03:09:30.000Z</published>
    <updated>2018-03-22T08:19:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道lock和synchronized在同步运用上的显著区别之一就是lock支持可中断，而synchronized不支持可中断。那么可中断实际上是怎么实现的，或者说我们怎么去理解中断这个概念。在lock的实现ReetrantLock中其实我们可以看到很多中断的运用。我们都知道死锁，作为一种独占的互斥锁，通过中断我们可以保证线程在阻塞的过程中可以响应中断，也就是结束当前线程对cpu的占用，通过向上层抛出异常来结束当前线程。</p><h3 id="ReetrantLock中断的应用"><a href="#ReetrantLock中断的应用" class="headerlink" title="ReetrantLock中断的应用"></a>ReetrantLock中断的应用</h3><p>我们看到ReetrantLock是如何实现中断的，这里主要看到三种中断的运用：</p><h4 id="selfInterrupt"><a href="#selfInterrupt" class="headerlink" title="selfInterrupt()"></a>selfInterrupt()</h4><p>ReetrantLock提供了lock和lockIntteruptibly两种上锁方式，那么他们有什么本质的区别，我们看到lock的一段源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">      acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们分析这段代码，lock默认非公平锁的情况下在tryAcquire(arg)时并不会排队，如果获取不到会去 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)进行排队，如果该方法返回ture则进入线程自我中断。那么我们可以看下这段代码是如何实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())<span class="comment">//这里我们检验了中断标志是否被改变通过currentThread().isInterrupted(true)方法</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 这里的interrupted是我们定义的一个中断变量，可以看到这只是一个临时变量。当我们在队列中循环cas的时候，如果没有收到中断请求，那么最终会在第一组判断内进入并获取到锁，这是的中断标志为false，不中断，那么线程获取到锁之后开始执行同步代码块。但是如果在循环cas获取锁的过程中感知到了中断，中断的标志会被置为true，然后直接返回上层执行selfInterrupt()，我们再看下selfInterrupt()执行了什么操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Convenience method to interrupt current thread.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Thread.currentThread().interrupt();<span class="comment">//当前线程执行自我中断</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>总结：我们可以在获取锁的过程中记录一个临时变量，如果检测到当前执行线程被别的线程进行了某中断操作。将该临时变量置为true然后触发线程的自我中断。</p><h4 id="抛出InterruptedException-异常"><a href="#抛出InterruptedException-异常" class="headerlink" title="抛出InterruptedException()异常"></a>抛出InterruptedException()异常</h4><p>线程在检测到被中断的请求时，不会立即响应这个中断请求，因为它仅仅是改变了中断标示位，但是并不会直接触发中断，是否进行中断还是看当前线程什么时候去检测这个中断标示位。一般在阻塞锁的设计中，我们在循环等待的过程中会进行中断标志位的检测，从而进行InterruptedException()异常的抛出。这个中断异常的过程就好比，你妈妈会交代你好好吃饭，但是具体你是不是要好好吃饭，还是得由你自己决定，也就是我们在设计一个线程的run方法时，同样可以自定义一个volatile类型的中断标志位，来同步记录这个系统的标志位，然后在我们想要抛出异常的时候来检测这个标志位的变化，从而抛出相应的异常。这里看一段lockInterruptibly中的处理：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Acquires in exclusive interruptible mode.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">               <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                   setHead(node);</span><br><span class="line">                   p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                   failed = <span class="keyword">false</span>;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())<span class="comment">//检测到中断标示位被修改为true的时候直接向上层抛出异常。</span></span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="中断的相关方法"><a href="#中断的相关方法" class="headerlink" title="中断的相关方法"></a>中断的相关方法</h3><p>这里记录一下几个关键的调用中断的方法：</p><ul><li>public void interrupt()<br>将调用者线程的中断状态设为true。</li><li>public boolean isInterrupted()<br>判断调用者线程的中断状态。</li><li>public static boolean interrupted<br>只能通过Thread.interrupted()调用。<br>它会做两步操作：返回<strong>当前线程</strong>的中断状态同时将当前线程的中断状态设为false。</li></ul><p>线程通过检查自身是否被中断来进行响应，线程通过方法isInterrupted()来进行判断是否被中断，也可以通过调用静态方法Thread.interrupted()对当前线程的中断标示位进行复位。如果该线程已经处于终结状态，那么即使该线程被中断过，在调用该线程该线程对象的isInterrrupted()时会返回false。</p><p>我们查看java的api可以看到，很多会抛出中断异常的方法都会在抛出异常之前，java虚拟机首先将该线程的中断标示位清除。那么此时我们调用isInterrrupted()时会返回false。</p><h3 id="中断异常代码示例"><a href="#中断异常代码示例" class="headerlink" title="中断异常代码示例"></a>中断异常代码示例</h3><p>我们创建两个线程sleepThread和busyThread，第一个不停的执行休眠，第二个不停的执行循环代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Interrupted;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 3/22/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interrupted</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//新建一个睡眠线程</span></span><br><span class="line">        Thread sleepThread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"sleepThread"</span>);</span><br><span class="line">        <span class="comment">//新建一个忙碌的线程</span></span><br><span class="line">        Thread busyThread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"busyThread"</span>);</span><br><span class="line">        sleepThread.start();</span><br><span class="line">        busyThread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);<span class="comment">//线程休眠十秒</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        sleepThread.interrupt();</span><br><span class="line">        busyThread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"sleepThread的中断标志为："</span>+sleepThread.isInterrupted());</span><br><span class="line">        System.out.println(<span class="string">"busyThread的中断标志为："</span>+busyThread.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果为：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at Interrupted.Interrupted<span class="formula">$1.run(Interrupted.java:14)</span></span><br><span class="line"><span class="formula">at java.lang.Thread.run(Thread.java:745)</span></span><br><span class="line"><span class="formula">sleepThread的中断标志为：false</span></span><br><span class="line"><span class="formula">busyThread的中断标志为：true</span></span><br></pre></td></tr></table></figure><p>可以看到，抛出异常的线程的中断标示位被清除了，但是一直忙碌的线程因为并没有去判断中断标示位，所以即使中断标示位已经是true也不会执行中断操作。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>线程中断是一种是可以理解为一个线程对另一个线程做出了一个标示位的改变，通过触发线程中断会将中断标示位置为true，被中断的线程可以选择忽略这个标志，也可以选择在某个时刻校验标志位抛出异常，同时将标志位清除。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道lock和synchronized在同步运用上的显著区别之一就是lock支持可中断，而synchronized不支持可中断。那么可中断实际上是怎么实现的，或者说我们怎么去理解中断这个概念。在lock的实现ReetrantLock中其实我们可以看到很多中断的运用。我们
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>ReetrantLock实现源码</title>
    <link href="http://jianghao.wang/2018/ReetrantLock%E5%AE%9E%E7%8E%B0%E6%BA%90%E7%A0%81/"/>
    <id>http://jianghao.wang/2018/ReetrantLock实现源码/</id>
    <published>2018-03-19T12:52:17.000Z</published>
    <updated>2018-03-21T09:21:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>ReetrantLock是基于AQS（AbtractQueuedSynchronizer）实现的。本文将逐渐展开分析ReetrantLock的实现机制以及使用场景。</p><h3 id="AQS实现源码"><a href="#AQS实现源码" class="headerlink" title="AQS实现源码"></a>AQS实现源码</h3><p> AQS提供了一个框架，用于实现阻塞锁和相关的同步器(semaphores, events等)，它们依赖于先入先出(FIFO)等待队列。这个类被设计成大多数类型的同步器的基础，它们依赖于单个原子<strong>{@ code int}</strong>值来表示同步状态。子类必须定义更改此状态的受保护方法（重写相关的方法），并重新定义该状态值在实现类中的定义。考虑到这些，这个类中的其他方法需要控制所有队列的进出和阻塞机制。子类可以维护其他的状态字段，但是只有通过使用方法<strong>{@ link # get state}、{@ link # set state}和{@ link # compare和set state}</strong>的原子更新<strong>{@ code int}</strong>值，才会对同步进行跟踪。</p><p>AQS框架要么支持默认的独占模式，要么支持共享模式。当以独占模式获得时，试图通过其他线程获取的尝试无法成功。多个线程的共享模式可以(但不需要)成功。共享模式获得成功时，下一个等待线程(如果存在)还必须确定它是否也能获得。在不同模式中等待的线程共享相同的FIFO队列。通常，实现子类只支持其中一种模式，但都可以在<strong>{@ link Read Write Lock}</strong>中发挥作用。支持唯一或仅共享模式的子类不必定义支持未使用模式的方法。本文分析的ReetrantLock是一种独占模式的实现，同一时间只能有一个线程执行同步代码块，其它线程将被阻塞在队列中，等待state也就是锁释放之后从队列中释放出来执行代码块。</p><h4 id="AQS的使用"><a href="#AQS的使用" class="headerlink" title="AQS的使用"></a>AQS的使用</h4><p>使用这个类作为一个同步器的基础，通过state的暴露方法来同步修改状态，同时需要定义下列方法：</p><ul><li><strong>{@link #tryAcquire}</strong>，获取锁，cas修改state状态。</li><li><strong>{@link #tryRelease}</strong>，释放锁，修改state状态同时将线程移除队列。</li><li><strong>{@link #tryAcquireShared}</strong>，获取共享锁。</li><li><strong>{@link #tryReleaseShared}</strong>，释放共享锁。</li><li><strong>{@link #isHeldExclusively}</strong>，锁是否被独占。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> Acquire:</span><br><span class="line">     <span class="keyword">while</span> (!tryAcquire(arg)) &#123;</span><br><span class="line">        &lt;em&gt;enqueue thread if it is not already queued&lt;/em&gt;;</span><br><span class="line">        &lt;em&gt;possibly block current thread&lt;/em&gt;;</span><br><span class="line">     &#125;</span><br><span class="line"> Release:</span><br><span class="line">     <span class="keyword">if</span> (tryRelease(arg))</span><br><span class="line">        &lt;em&gt;unblock the first queued thread&lt;/em&gt;;</span><br><span class="line"> &lt;/pre&gt;</span><br><span class="line">(Shared mode is similar but may involve cascading signals.)</span><br></pre></td></tr></table></figure><p>这里给一个独占锁的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Our internal helper class</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Reports whether in locked state</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Acquires the lock if state is zero</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Releases the lock by setting state to zero</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">      <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">      setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">      setState(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Provides a Condition</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject(); &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Deserializes properly</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">      s.defaultReadObject();</span><br><span class="line">      setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// The sync object does all the hard work. We just forward to it.</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>                </span>&#123; sync.acquire(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>          </span>&#123; <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>              </span>&#123; sync.release(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> sync.newCondition(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span>         </span>&#123; <span class="keyword">return</span> sync.isHeldExclusively(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sync.hasQueuedThreads(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="AQS队列同步器提供的接口分析"><a href="#AQS队列同步器提供的接口分析" class="headerlink" title="AQS队列同步器提供的接口分析"></a>AQS队列同步器提供的接口分析</h4><p>同步器提供的可供重写的方法：</p><table><thead><tr><th style="text-align:center">方法名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">protected int tryAcquireShared(int arg)</td><td style="text-align:left">共享式获取同步状态，返回&gt;=0的值，表示获取成功，反之获取失败。</td></tr><tr><td style="text-align:center">protected boolean tryReleaseShared(int arg)</td><td style="text-align:left">共享式释放同步状态。</td></tr><tr><td style="text-align:center">protected boolean isHeldExclusively()</td><td style="text-align:left">当前同步器是否在独占模式下被线程占用，一般实现会判断当前线程是否独占锁。</td></tr><tr><td style="text-align:center">protected boolean tryAcquire(int arg)</td><td style="text-align:left">独占式获取锁，该方法为获取锁操作方法。公平锁和非公平锁有不同的实现，非公平锁直接调用同步器底层实现。公平锁会先判断当前队列是否有线程在等待锁。</td></tr><tr><td style="text-align:center">protected  boolean tryRelease(int arg)</td><td style="text-align:left">独占式释放同步锁，其它队列中等待的线程将有机会获取到锁。</td></tr></tbody></table><p>我们可以根据这些可以重写的方法去自定义同步组件，类似公平锁和非公平锁的定义，实际上是对FairSync和NonfairSync对Sync的tyAcquire方法进行了不同的实现。另外队列同步器还提供了一些模板方法：</p><table><thead><tr><th style="text-align:center">方法名称</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">void acquire(int arg)</td><td>独占式获取同步状态，如果获取同步状态成功，进入同步块否则进入等待队列，然后开始循环等待当前线在等待队列中获取到锁，只会记录中断状态不会触发中断。这个方法会调用到tryAcquire方法，可以被自定义同步器重写。</td></tr><tr><td style="text-align:center">boolean tryAccquireNano(int arg,long nanos)</td><td>增加了超时时间限制，如果当前线程在限制的时间内没有获取到锁的话就返回false,否则返回true。</td></tr><tr><td style="text-align:center">void accqureInrruptibly(int arg)</td><td>支持中断模式，当前在，相较于acquire方法该方法同样会进行循环等待队列中获取到锁。但是当它可以响应中断，当其他线程中断当前线程的时候，会抛出InterruptException异常。</td></tr><tr><td style="text-align:center">Collection<thread> getQueuedThreads()</thread></td><td>获取等待在同步队列上的线程集合。</td></tr><tr><td style="text-align:center">boolean tryAccquireSharedNano(int arg,long nanos)</td><td>同样的，我们为该方法在共享锁的前提下增加了超时时间。</td></tr><tr><td style="text-align:center">void acquireShared(int arg)</td><td>共享式获取同步状态，主要区别于独占式获取同步状态，这种方式的特别之处在于同一时间可以有多个线程获得同步状态。</td></tr><tr><td style="text-align:center">void accqureSharedInrruptibly(int arg)</td><td>该方法响应中断。</td></tr><tr><td style="text-align:center">void releasShared(int arg)</td><td>共享锁释放同步状态。</td></tr></tbody></table><p>队列同步器的方法主要分为三类：</p><ul><li><strong>独占式获取与释放同步状态</strong></li><li><strong>共享式获取与释放同步状态</strong></li><li><strong>查询同步队列中线程的等待情况</strong></li></ul><p>同样的，我们提供一个共享锁的实例，类似java.util.concurrent.CountDownLatch CountDownLatch的一种实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSignalled</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> getState() != <span class="number">0</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> ignore)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> isSignalled() ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> ignore)</span> </span>&#123;</span><br><span class="line">      setState(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSignalled</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sync.isSignalled(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span>         </span>&#123; sync.releaseShared(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="ReetrantLock主要方法"><a href="#ReetrantLock主要方法" class="headerlink" title="ReetrantLock主要方法"></a>ReetrantLock主要方法</h3><p>我们通常会用定义一个ReetrantLock，通过调用lock方法和unlock方法来对同步代码块进行加锁和释放锁。我们先来看一下lock方法的调用栈。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment">    * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment">    * given fairness policy.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">       sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看到ReetrantLock提供了两种构造方法，一种会默认初始化一个非公平锁，另一个可以指定公平锁或者非公平锁。公平锁和非公平锁中都有对应的加锁和释放锁实现。观察调用栈可以看到两者的区别。</p><h4 id="lock方法调用公平锁和非公平锁"><a href="#lock方法调用公平锁和非公平锁" class="headerlink" title="lock方法调用公平锁和非公平锁"></a>lock方法调用公平锁和非公平锁</h4><p>我们可以通过源代码看到公平锁和非公平锁的实现都继承了Sync类，实际上这个类是对AQS类的一种独占锁的实现。所以我们最终实现的ReetrantLock是独占的，可重入的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Sync object for non-fair locks</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">        * acquire on failure.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))<span class="comment">//非公平锁调用时就会给一次竞争的机会，如果后来的线程刚好在锁释放的时候去获取锁，那么即使等待队列中还有其它的线程也会被直接忽略，这样的话对队列中等待的线程是不公平的。</span></span><br><span class="line">               setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               acquire(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> nonfairTryAcquire(acquires);<span class="comment">//实际上是直接调用了AQS中的nonfairTryAcquire(acquires)方法。这个方法是不会维持一个等待竞争锁的线程队列的。</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>再看下公平锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sync object for fair locks</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            acquire(<span class="number">1</span>);<span class="comment">//公平锁线程在获取锁的时候直接加入队列，等待前面的线程被执行完之后顺序调用。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">         * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们在进入acquire方法，可以看到非公平锁实际上是直接调用的Sync中nonfairTryAcquire的实现，源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<span class="comment">//ReetrantLock是可重入锁，同一个线程可以再次进入，但是会将state作累加。</span></span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>而公平锁调用的是自己实现的tryAcquire(int acquires)方法，上面关于公平锁的静态类中可以看到。对比之后发现公平锁在判断的时候多了一句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<span class="comment">//这个增加的判断也是保证公平</span></span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;<span class="comment">//这里是通过cas去写state的状态也就是去占用锁</span></span><br><span class="line">                    setExclusiveOwnerThread(current);<span class="comment">//成功获取锁之后记录独占锁线程为当前线程</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>hasQueuedPredecessors()的实现如下，如果当前线程在队列中还有前置线程返回true，不获得准入条件。如果当前线程处于队列的头部，或者队列为空，则返回false，获得准入条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @return &#123;@code true&#125; if there is a queued thread preceding the</span></span><br><span class="line"><span class="comment">     *         current thread, and &#123;@code false&#125; if the current thread</span></span><br><span class="line"><span class="comment">     *         is at the head of the queue or the queue is empty</span></span><br><span class="line"><span class="comment">     * @since 1.7</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">        <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">        <span class="comment">// thread is first in queue.</span></span><br><span class="line">        Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结一下，公平锁和非公平锁相比，保证了FIFO的原则，但是代价是进行了大量的线程切换。而非公平锁虽然可能造成线程 “饥饿”，但是极少的线程切换，同样也保证了更大的吞吐量。</p><h3 id="tryLock-方法和lock方法"><a href="#tryLock-方法和lock方法" class="headerlink" title="tryLock()方法和lock方法"></a>tryLock()方法和lock方法</h3><p>看一下tryLock()方法，实际上调用Sync的nonfairTryAcquire方法，该方法相较于lock方法精简了一些。对比，一下，少了一段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<span class="comment">//这里如果获取失败会尝试将线程加入等待队列</span></span><br><span class="line">         selfInterrupt();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>tryLock()方法默认是非公平方式去调用的，只是一次简单的cas加锁尝试。如果失败了线程不会再被执行，拥有再次竞争锁的机会。</li><li>lock()方法的非公平方式如果获取锁失败会将当前线程加入等待队列。如果失败了线程等待之后还有再次获得锁的机会。</li></ul><p>这样public boolean tryLock(long timeout, TimeUnit unit)，这个方法也就更容易理解了，增加了一个timeout时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));<span class="comment">//默认unit.toNanos(timeout)时间内超时，首先会将这个线程加入队列，然后进行循环自旋，如果时间内线程没有排到队首，会返回一个false。</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>sync.tryAcquireNanos(1, unit.toNanos(timeout))，该方法具体实现如下，咋一看代码很容易将其误认为是在时间段内不断cas自旋去获取锁，如果时间内失败返回false。实际上是会将当前的线程加入等待队列的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);<span class="comment">//会将该线程作为一个node加入到等待队列。Node.EXCLUSIVE定义为独占模式。</span></span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;<span class="comment">//这里开始循环等待加入的线程排到队首，可能会在时间段内排到也可能排不到。</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面是addWaiter(Node mode)，就是生成一个独占的线程节点加入到等待队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">       Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">       <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">       Node pred = tail;</span><br><span class="line">       <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">           node.prev = pred;</span><br><span class="line">           <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">               pred.next = node;</span><br><span class="line">               <span class="keyword">return</span> node;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       enq(node);</span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="unlock方法释放锁"><a href="#unlock方法释放锁" class="headerlink" title="unlock方法释放锁"></a>unlock方法释放锁</h4><p>调用unlock方法，实际上调用的是AQS中的release(1)方法，这个只会把state的值-1，源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中tryRelease(arg)方法执行如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">  <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">  <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//如果当前state保留的值已经变为零，锁释放成功</span></span><br><span class="line">    free = <span class="keyword">true</span>;</span><br><span class="line">    setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  setState(c);</span><br><span class="line">  <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="InterruptedException可中断获取锁"><a href="#InterruptedException可中断获取锁" class="headerlink" title="InterruptedException可中断获取锁"></a>InterruptedException可中断获取锁</h4><p>ReetrantLock提供了一种可中断获取锁的方式，也是实现了定义在lock中的接口，该方法很容易理解，在获取锁的过程中会响应中断，那么这种方式和普通的lock方式有什么本质区别。我们看一下这种方式的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Acquires in exclusive interruptible mode.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">      <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">              <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                  setHead(node);</span><br><span class="line">                  p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                  failed = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                  parkAndCheckInterrupt())</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();<span class="comment">//这里会响应中断，会直接抛异常给上层，在lock中只是维护了一个状态值，进行了状态值的修改，并不会跑出异常到上层。最终回返回false</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (failed)</span><br><span class="line">              cancelAcquire(node);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>结论：ReentrantLock的中断和非中断加锁模式的区别在于：线程尝试获取锁操作失败后，在等待过程中，如果该线程被其他线程中断了，它是如何响应中断请求的。lock方法会忽略中断请求，继续获取锁直到成功；而lockInterruptibly则直接抛出中断异常来立即dsa响应中断，由上层调用者处理中断。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要对ReetrantLock的源码进行了一些分析，ReetrantLock是基于AQS实现的一种独占，可重入的锁，可以自己的定义公平锁或者非公平锁。ReetrantLock通过维护AQS类内部的一个volatile state变量来记录锁的状态，通过cas去竞争，同时记录当前持有锁的线程。支持可重入，当当前持有该锁的线程尝试再次进入的时候会通过准入条件，并将state增加1。实际上公平锁和非公平锁主要是当前线程是否会进入线程等待的队列，AQS在底层维护了一个线程的等待队列，基于先进先出的原则去调度这些等待获取锁的队列。如果非公平锁的话直接调用lock去加锁，可能面临失败的情况，如果失败了，就是一次cas自旋失败，同步代码块并不会被执行。如果用trylock方法的话可以尝试增加一个超时时间，会将当前的线程加入到等待队列中然后在超市时间内等待被调度，这种场景在某些情况下还是很适用的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ReetrantLock是基于AQS（AbtractQueuedSynchronizer）实现的。本文将逐渐展开分析ReetrantLock的实现机制以及使用场景。&lt;/p&gt;
&lt;h3 id=&quot;AQS实现源码&quot;&gt;&lt;a href=&quot;#AQS实现源码&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>AtomicInteger源码分析</title>
    <link href="http://jianghao.wang/2018/AtomicInteger%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://jianghao.wang/2018/AtomicInteger源码分析/</id>
    <published>2018-03-16T10:23:32.000Z</published>
    <updated>2018-03-16T10:23:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>在阅读ConcurrentHashMap源码的过程中，频繁使用了volatile+无锁的方式来处理并发，需要对AtomicInteger源码有更深的了解。将这个模块独立抽离出来形成更深刻的理解。</p><h3 id="AutomicInteger变量"><a href="#AutomicInteger变量" class="headerlink" title="AutomicInteger变量"></a>AutomicInteger变量</h3><p>AutomicInteger作为一个原子操作类，定义了一些变量：</p><ul><li><p>private static final Unsafe unsafe = Unsafe.getUnsafe()，定义了一个usafe类对象，主要对native方法进行调用。</p></li><li><p>private static final long valueOffset，这个值可能会被误以为是默认值，查看部分源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>了解过java虚拟机类加载机制的，类加载触发的其中一个条件是getstatic，这样其他方法在每次访问到这个值的时候都会执行一下静态代码块获取到内存中最新的值。这个值是作为内存中的值，我们在编写程序的时候会存一份拷贝在栈中，通过对比这个值和拷贝值是否一致来决定是否更新新值到内存，也就是这次操作是否成功。</p></li><li><p>private volatile int value，上面通过静态代码块儿去加载的就是内存中value的最新值。</p></li></ul><h3 id="AutomicInteger原子操作"><a href="#AutomicInteger原子操作" class="headerlink" title="AutomicInteger原子操作"></a>AutomicInteger原子操作</h3><p>这里我们通过自己写复杂操作count++对比通过调用AutomicInteger的api，可以对比结果是否保证了正确的输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CasNoLock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 3/16/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger atomicInteger=<span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Thread&gt; threadArrayList=<span class="keyword">new</span> ArrayList&lt;Thread&gt;(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5000</span>;i++)&#123;</span><br><span class="line">                        count();</span><br><span class="line">                        countAtomicInteger();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threadArrayList.add(thread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Thread t:threadArrayList)&#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Thread t:threadArrayList)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"非原子操作累加结果："</span>+count);</span><br><span class="line">        System.out.println(<span class="string">"原子操作累加结果："</span>+atomicInteger.intValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非原子类操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原子类操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countAtomicInteger</span><span class="params">()</span></span>&#123;</span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">非原子操作累加结果：461539</span><br><span class="line">原子操作累加结果：50000</span><br></pre></td></tr></table></figure><h3 id="AutomicInteger-API分析"><a href="#AutomicInteger-API分析" class="headerlink" title="AutomicInteger API分析"></a>AutomicInteger API分析</h3><p>我们查看下atomicInteger.getAndIncrement()在usafe中的实现，实际上它是调用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 查看getAndAddInt方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>compareAndSwapInt(var1, var2, var5, var5 + var4)</strong>换成<strong>compareAndSwapInt(obj, offset, expect, update)</strong>比较清楚，意思就是如果<code>obj</code>内的<code>value</code>和<code>expect</code>相等，就证明没有其他线程改变过这个变量，那么就更新它为<code>update</code>，如果这一步的<code>CAS</code>没有成功，那就采用自旋的方式继续进行<code>CAS</code>操作，取出乍一看这也是两个步骤了啊，其实在<code>JNI</code>里是借助于一个<code>CPU</code>指令完成的。所以还是原子操作。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>AutomicInteger源码最终是通过<strong>usafe.compareAndSwapInt(obj, offset, expect, update)</strong>函数实现cas原子操作的。cas中最重要的三个值，volatile value（内存中最新值），expect（拷贝值）和update（更新值），在函数中分别对应offset，expect，和update入参。对这个关键方法的了解可以帮助深入阅读ConcurrentHashMap源码，jdk1.8中大量运用cas+synchronized关键字来实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在阅读ConcurrentHashMap源码的过程中，频繁使用了volatile+无锁的方式来处理并发，需要对AtomicInteger源码有更深的了解。将这个模块独立抽离出来形成更深刻的理解。&lt;/p&gt;
&lt;h3 id=&quot;AutomicInteger变量&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap实现源码</title>
    <link href="http://jianghao.wang/2018/ConcurrentHashMap%E5%AE%9E%E7%8E%B0%E6%BA%90%E7%A0%81/"/>
    <id>http://jianghao.wang/2018/ConcurrentHashMap实现源码/</id>
    <published>2018-03-16T07:24:07.000Z</published>
    <updated>2018-06-20T02:29:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>在阅读源码的过程中，推荐一个idea的翻译插件<a href="https://github.com/YiiGuxing/TranslationPlugin" target="_blank" rel="noopener">TranslationPlugin</a>，方便阅读源码的注释。本篇主要介绍ConcurrentHashMap在JDK1.8中的实现。</p><h3 id="ConcurrentHashMap静态常量"><a href="#ConcurrentHashMap静态常量" class="headerlink" title="ConcurrentHashMap静态常量"></a>ConcurrentHashMap静态常量</h3><p>ConcurrentHashMap在设计的过程中涉及到扩容和容器收缩等策略，在静态常量中定义了一些比较关键的阈值，这里介绍几个主要的：</p><ul><li><p>private static final int DEFAULT_CAPACITY=16，默认表大小，默认初始化的时候没有传递capacity和concurrentlevel会提供16个hash桶进行映射。否则会根据capacity或者concurrentlevel来确定size的值。</p></li><li><p>private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30，最大表容量，扩容时会判断最大容量。</p></li><li><p>static final int MIN_TREEIFY_CAPACITY = 64，链表树化时的最小表（数组）容量。在列表树化的时候会检测当前的表（数组）容量，如果小于这个数值会首先进行扩容，扩容之后再进行树化。n为表（数组）长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">              tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>private static final float LOAD_FACTOR = 0.75f，装载因子，当数组中已经映射的hash桶已经达到百分之75以上时会自动扩容。代码中可以用 <strong>{@code n - (n &gt;&gt;&gt; 2)}</strong>代替运算，n为表（数组）的长度。</p></li><li><p>static final int TREEIFY_THRESHOLD = 8，链表调整为tree阈值。当链表中的节点数量超过这个数值的时候会调整为树结构。这个数量至少为2最好是大于8。</p></li><li><p>static final int UNTREEIFY_THRESHOLD = 6，当链表的长度小于这个值的时候自动调节树结构为列表结构。</p></li></ul><h3 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h3><p>分析一下数组的扩容方法tryPresize，源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tries to presize table to accommodate the given number of elements.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> size number of elements (doesn't need to be perfectly accurate)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">     <span class="comment">//判断是否为最大超过最大容量的八倍，超过了直接扩容到最大容量。最大容量为1&lt;&lt;30</span></span><br><span class="line">           tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">     <span class="comment">//这里只需要提供一个大概的size，tableSizeFor函数会根据当前的size值匹配一个最近的表大小值，因为我们规定表的大小只能是2的倍数（为了保证在取模进行hash运算的时候可以用（hashcode &amp; n-1） ）</span></span><br><span class="line">       <span class="keyword">int</span> sc;</span><br><span class="line">       <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;</span><br><span class="line">           <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="comment">//如果当前table并没有被初始化，例如在putAll方法中传入一个map，首先进行table的初始化tab</span></span><br><span class="line">               n = (sc &gt; c) ? sc : c;</span><br><span class="line">               <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                 <span class="comment">//这里采用了循环cas来替换sc的值，最后将sizeCtl赋值为sc的值</span></span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                           <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                           Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                           table = nt;</span><br><span class="line">                           sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                       sizeCtl = sc;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">               <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">               <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                   Node&lt;K,V&gt;[] nt;</span><br><span class="line">                   <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                       sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                       transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                       transfer(tab, nt);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                   transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>再看一下主要的putVal方法，源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">int</span> hash = spread(key.hashCode());<span class="comment">//获取hash映射桶，对hashcode做了扰动保证散列的均匀度</span></span><br><span class="line">       <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">           Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">           <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">               tab = initTable();<span class="comment">//如果当前未被初始化过，进行初始化。</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                            <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                   <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin,采用无锁的方式，如果无锁置换成功就直接break出循环，代表成功插入。如果失败，表明有竞争发生，继续执行后续代码，会进行插入。</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)<span class="comment">//表明当前表正在进行扩容。检测到当前映射节点正在进行扩容的时候，当前线程加入帮忙进行扩容工作。</span></span><br><span class="line">               tab = helpTransfer(tab, f);</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               V oldVal = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">synchronized</span> (f) &#123;<span class="comment">//相当于锁住一条链表，这里有一个偏向锁到轻量级锁到重量级锁的升级过程</span></span><br><span class="line">                   <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                           binCount = <span class="number">1</span>;</span><br><span class="line">                           <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                               K ek;</span><br><span class="line">                               <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                   ((ek = e.key) == key ||</span><br><span class="line">                                    (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                   oldVal = e.val;</span><br><span class="line">                                   <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                       e.val = value;</span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                               Node&lt;K,V&gt; pred = e;</span><br><span class="line">                               <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                   pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                             value, <span class="keyword">null</span>);</span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) <span class="comment">//如果已经被树化，以红黑树的方式增加一个节点。</span></span><br><span class="line">                           Node&lt;K,V&gt; p;</span><br><span class="line">                           binCount = <span class="number">2</span>;</span><br><span class="line">                           <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                          value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                               oldVal = p.val;</span><br><span class="line">                               <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                   p.val = value;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<span class="comment">//如果达到树化的阈值，将链表进行树化。</span></span><br><span class="line">                       treeifyBin(tab, i);</span><br><span class="line">                   <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                       <span class="keyword">return</span> oldVal;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    从ConcurrentHashMap的多个版本演变中，最终java9采用了synchronized和cas来实现，之后会抽写一篇对几种版本迭代过程中性能的优异比较。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在阅读源码的过程中，推荐一个idea的翻译插件&lt;a href=&quot;https://github.com/YiiGuxing/TranslationPlugin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TranslationPlugin&lt;/a&gt;，方便阅读
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>面试记录</title>
    <link href="http://jianghao.wang/2018/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <id>http://jianghao.wang/2018/面试记录/</id>
    <published>2018-03-14T10:24:15.000Z</published>
    <updated>2018-10-31T06:56:11.477Z</updated>
    
    <content type="html"><![CDATA[<h4 id="搜车的手写代码"><a href="#搜车的手写代码" class="headerlink" title="搜车的手写代码"></a>搜车的手写代码</h4><p>面试需要手写一段死锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SynchronizedLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 3/14/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MythreadA</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    Object a;</span><br><span class="line">    Object b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MythreadA</span><span class="params">(Object a,Object b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a=a;</span><br><span class="line">        <span class="keyword">this</span>.b=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (a)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程A正在等待获取下个对象的锁，已经获取到对象锁："</span>+a);</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (b)&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程A同时获取到对象A和B的锁"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>触发线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SynchronizedLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 3/14/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedLockMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object a=<span class="keyword">new</span> Object();</span><br><span class="line">        Object b=<span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MythreadA(a,b)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MythreadA(b,a)).start();<span class="comment">//调换一下ab顺序保证死锁发生的条件，否则不会发生死锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2018-10-24-天猫笔试"><a href="#2018-10-24-天猫笔试" class="headerlink" title="2018-10-24 天猫笔试"></a>2018-10-24 天猫笔试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//评测题目: 1.利用多线程有序打印（假定打印为IO阻塞耗时操作）出0~100的所有自然数(使用线程池编码）</span></span><br><span class="line"><span class="number">2</span>.利用数组实现栈的push和pop操作，以及min函数，得到栈的最小元素；</span><br><span class="line">时间：<span class="number">40</span>分钟</span><br><span class="line">说明：如API记不清楚可使用伪代码示意既可</span><br><span class="line">Class ThreadFirst implement Runable&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">ThreadPrint(<span class="keyword">int</span> from ,<span class="keyword">int</span> end)&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//先分三个线程打印吧</span></span><br><span class="line">    <span class="keyword">while</span>(PrintData.count%<span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//第一次打印的线程</span></span><br><span class="line">            printData(from,end);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Class ThreadSecond implement Runable&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">ThreadPrint(<span class="keyword">int</span> from ,<span class="keyword">int</span> end)&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//先分三个线程打印吧</span></span><br><span class="line">    <span class="keyword">while</span>(PrintData.count%<span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//第一次打印的线程</span></span><br><span class="line">            printData(from,end);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Class ThreadThird implement Runable&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">ThreadPrint(<span class="keyword">int</span> from ,<span class="keyword">int</span> end)&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//先分三个线程打印吧</span></span><br><span class="line">    <span class="keyword">while</span>(PrintData.count%<span class="number">3</span> == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">//第一次打印的线程</span></span><br><span class="line">            printData(from,end);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Class PrintData&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> ThreadFirst(<span class="number">0</span>,<span class="number">30</span>).start();</span><br><span class="line">        <span class="keyword">new</span> ThreadFirst(<span class="number">31</span>,<span class="number">60</span>).start();</span><br><span class="line">        <span class="keyword">new</span> ThreadFirst(<span class="number">60</span>,<span class="number">100</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个最小的栈值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Integer&gt; data=<span class="keyword">new</span> ArrayList&lt;Integer&gt;&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; minIntegers= <span class="keyword">new</span> ArrayList&lt;Integer&gt;&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">        data.add(num);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(minIntegers.size() ==<span class="number">0</span>)&#123;</span><br><span class="line">        minIntegers.add(<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//保存一下最小值的索引</span></span><br><span class="line">            <span class="keyword">int</span> min =minOfStack();</span><br><span class="line">            <span class="keyword">if</span>(num &lt; min)&#123;</span><br><span class="line">            <span class="comment">//如果在push的时候找到了更小的值保存到最小值的列表中</span></span><br><span class="line">minIntegers.add(data.size()-<span class="number">1</span>);      </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果data pop完抛出异常</span></span><br><span class="line">        <span class="keyword">if</span>(data.size()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"栈已经没有元素"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//在pop的时候需要同步pop一下最小列表里面的索引值，什么时候出栈？</span></span><br><span class="line">        <span class="keyword">int</span> popIndex=data.size() -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> minIndex = minIntegers.get(minIntegers.size()-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(popIndex == minIndex)&#123;</span><br><span class="line">        <span class="comment">//粗zhan</span></span><br><span class="line">            minIntegers.remove(minIntegers.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minOfStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//判空</span></span><br><span class="line">        <span class="keyword">if</span>(data.size()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"zhan元素异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每次取zhan顶的元素</span></span><br><span class="line">      <span class="keyword">int</span> minIndex = minIntegers.get(minIntegers.size-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> data.get(minIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;搜车的手写代码&quot;&gt;&lt;a href=&quot;#搜车的手写代码&quot; class=&quot;headerlink&quot; title=&quot;搜车的手写代码&quot;&gt;&lt;/a&gt;搜车的手写代码&lt;/h4&gt;&lt;p&gt;面试需要手写一段死锁：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;ta
      
    
    </summary>
    
    
      <category term="面试记录" scheme="http://jianghao.wang/tags/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Java位操作</title>
    <link href="http://jianghao.wang/2018/Java%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    <id>http://jianghao.wang/2018/Java位操作/</id>
    <published>2018-03-13T11:56:58.000Z</published>
    <updated>2018-03-14T01:56:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>在阅读源码的过程中，发现很多地方会使用到位操作来提高计算的效率。我们很常见的取模操作，在源码中都会通过与操作来完成。了解和灵活运用位运算可以帮助我们快速理解源码，写出较为简洁的代码。</p><h3 id="位操作运算符"><a href="#位操作运算符" class="headerlink" title="位操作运算符"></a>位操作运算符</h3><p>针对二进制位操作运算符主要包括：</p><ul><li>与操作（&amp;），1&amp;1才为1，其它都为0.</li><li>非操作（～），简单取反.</li><li>或操作（|），当两边操作数的位有一边为1时,结果为1,否则为0.</li><li>异或操作（^），参与运算的两个值,如果两个相应位相同,则结果为0,否则为1.</li></ul><p>二进制位移动运算符：</p><ul><li>有符号的右移位运算符（&gt;&gt;），使指定值的所有位都向右移规定的次数.正数在高位插入0,负数则在高位插入1. 右移一位相当于除2, 右移n位相当于除以2的n次方.</li><li>有符号的左移动运算符（&lt;&lt;），使指定值的所有位都向左移规定的次数, 丢弃最高位, 在低位补0. 在数字没有溢出的前提下,对于正数和负数, 左移一位都相当于乘以2的1次方, 左移n位就相当于乘以2的n次方.</li><li>无符号的右移位运算符（&gt;&gt;&gt;），忽略了符号位扩展,无论正负,都在高位插入0.</li></ul><h3 id="位操作的应用"><a href="#位操作的应用" class="headerlink" title="位操作的应用"></a>位操作的应用</h3><h4 id="取模操作"><a href="#取模操作" class="headerlink" title="取模操作"></a>取模操作</h4><p>这里截取一段hash算法根据hashcode得到映射桶的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)<span class="comment">//这里的判断先映射到了table的某个桶</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>hashmap在插入元素的时候会首先根据hashcode确定映射到某个桶，注释处采用的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure><p>相当于操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash % (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这里需要注意的是，hash在扩容的都是以2的整数倍进行扩容，也就是为什么hashmap的数组长度要取2的整数次幂。因为这样（数组长度减1）正好相当于一个”低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值。以初始长度16为例，16-1=15。二进制表示为00000000 00000000 00001111。这样和某散列值进行与操作的结果如下，截取了最低的四位值，完成了取模的操作：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10100101 11000100 00100101</span><br><span class="line">&amp;  00000000 00000000 00001111</span><br><span class="line">-----------------------------------</span><br><span class="line">        00000000 00000000 00000101 //高位全部归零，只保留最后四位</span><br></pre></td></tr></table></figure><p>当然二进制&amp;的计算效率是要远远大于十进制%的计算效率。</p><h4 id="交换数字"><a href="#交换数字" class="headerlink" title="交换数字"></a>交换数字</h4><p>一般进行数字交换的操作我们会定义一个中间变量，作为交换的中转站。如果通过异或操作来进行可以省略中间变量的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 数a两次异或同一个数b(a=a^b^b)仍然为原值.*/</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">666</span>;</span><br><span class="line"></span><br><span class="line">        a = a ^ b;</span><br><span class="line">        b = b ^ a;</span><br><span class="line">        a = a ^ b;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"a: "</span> + a + <span class="string">" b "</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a: 666 b 100</span><br></pre></td></tr></table></figure><p><strong>数a两次异或同一个数b(a=a^b^b)仍然为原值.</strong></p><h3 id="HashMap扰动函数"><a href="#HashMap扰动函数" class="headerlink" title="HashMap扰动函数"></a>HashMap扰动函数</h3><p>这里我们分析一段HashMap的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class="line"><span class="comment">     * to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class="line"><span class="comment">     * hashes that vary only in bits above the current mask will</span></span><br><span class="line"><span class="comment">     * always collide. (Among known examples are sets of Float keys</span></span><br><span class="line"><span class="comment">     * holding consecutive whole numbers in small tables.)  So we</span></span><br><span class="line"><span class="comment">     * apply a transform that spreads the impact of higher bits</span></span><br><span class="line"><span class="comment">     * downward. There is a tradeoff between speed, utility, and</span></span><br><span class="line"><span class="comment">     * quality of bit-spreading. Because many common sets of hashes</span></span><br><span class="line"><span class="comment">     * are already reasonably distributed (so don't benefit from</span></span><br><span class="line"><span class="comment">     * spreading), and because we use trees to handle large sets of</span></span><br><span class="line"><span class="comment">     * collisions in bins, we just XOR some shifted bits in the</span></span><br><span class="line"><span class="comment">     * cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class="line"><span class="comment">     * to incorporate impact of the highest bits that would otherwise</span></span><br><span class="line"><span class="comment">     * never be used in index calculations because of table bounds.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里是桶映射的方法函数，针对上面取模操作的介绍，为什么还要对hashcode进行一个这样操作，为什么不直接进行散列？</p><p>这里想象一下hashcode是一个32位数，只保留最后几位的取模操作，碰撞是会相当严重的。而且我们在设计hashcode的时候不能保证是规律分布，很有可能在呈四位的跳跃状，那么很有可能会造成严重的碰撞。这样的话就很蛋疼了，这样的散列是没有任何价值的。那么我们就需要进行高低位的扰动：</p><p><img src="http://arthornye.github.io/images/raoluan.png" alt="cmd-markdown-logo"></p><p>右移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始hash码的高位和低位这样来加大低位的随机性。从而减少碰撞的概率。实验显示，当hashmap数组的长度为512的时候好，也就是用掩码取低9位的时候，在没有扰动函数的情况下发生了103次碰撞，接近百分之三十。在使用了扰动函数之后只有92次碰撞。碰撞减少了将近百分之十。</p><p>Java8只做了一次扰动，一般也可以考虑做多次的扰动，但是可能考虑到效率原因改成了一次。</p><h3 id="INT十进制转换为二进制"><a href="#INT十进制转换为二进制" class="headerlink" title="INT十进制转换为二进制"></a>INT十进制转换为二进制</h3><p>做一段测试代码的小记录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 3/13/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapStudy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">char</span>[] digits=&#123;<span class="string">'0'</span>,<span class="string">'1'</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map=<span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        String testString=<span class="string">"t3"</span>;</span><br><span class="line">        System.out.println(<span class="string">"t3的hashCode为："</span>+testString.hashCode());</span><br><span class="line">        System.out.println(testString.hashCode() ^ testString.hashCode()&gt;&gt;&gt;<span class="number">16</span>);</span><br><span class="line">        System.out.println(<span class="number">173412366</span> ^ <span class="number">8</span>);</span><br><span class="line">        System.out.println(<span class="number">12</span> &amp; <span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="number">12</span> % <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(convertIntToBinary(-<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将int类型转换为二进制字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">convertIntToBinary</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] buf=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">32</span>];<span class="comment">//int为4个Byte，32bit</span></span><br><span class="line">        <span class="keyword">int</span> pos=<span class="number">32</span>;</span><br><span class="line">        <span class="keyword">int</span> mask=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            buf[--pos]= digits[i &amp; mask];</span><br><span class="line">            i &gt;&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pos&gt;<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> String(buf,pos,<span class="number">32</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要解决自己在阅读HashMap源码过程中碰到的一些疑惑，进行记录，接下来将会介绍HashMap相关的源码实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在阅读源码的过程中，发现很多地方会使用到位操作来提高计算的效率。我们很常见的取模操作，在源码中都会通过与操作来完成。了解和灵活运用位运算可以帮助我们快速理解源码，写出较为简洁的代码。&lt;/p&gt;
&lt;h3 id=&quot;位操作运算符&quot;&gt;&lt;a href=&quot;#位操作运算符&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OpenClover提高ut覆盖率</title>
    <link href="http://jianghao.wang/2018/OpenClover%E6%8F%90%E9%AB%98ut%E8%A6%86%E7%9B%96%E7%8E%87/"/>
    <id>http://jianghao.wang/2018/OpenClover提高ut覆盖率/</id>
    <published>2018-03-09T08:59:15.000Z</published>
    <updated>2018-03-09T10:14:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>代码的单元测试覆盖率是衡量代码质量的标准之一，保证一定的ut覆盖率可以帮助提高开发人员的项目提测质量。本文将介绍如何在idea下利用openclover插件提高ut覆盖率。</p><h3 id="安装idea插件"><a href="#安装idea插件" class="headerlink" title="安装idea插件"></a>安装idea插件</h3><h4 id="Atlassian-Clover-for-IDEA"><a href="#Atlassian-Clover-for-IDEA" class="headerlink" title="Atlassian Clover for IDEA"></a>Atlassian Clover for IDEA</h4><p>从ItelliJ IDEA —&gt;Preference—&gt;plugins，idea中有自带的插件可供安装，我们可以搜索到该插件。点击安装之后成功之后我们发现该插件需要舒服注册码license。并且我们根据引导无法从Atlassian获取到对应的注册码。感谢国际友人，在一个论坛上发现该插件已经开源，我们可以通过导入插件的方式安装。</p><p><img src="http://arthornye.github.io/images/OpenClover/cloverage.png" alt="cmd-markdown-logo"></p><h4 id="OpenClover-for-IDEA"><a href="#OpenClover-for-IDEA" class="headerlink" title="OpenClover for IDEA"></a>OpenClover for IDEA</h4><p>1.进入OpenClover官网，根据<a href="http://openclover.org/doc/manual/4.2.0/idea--installation-guide.html" target="_blank" rel="noopener">快速开始OpenClover for IDEA</a>我们将下载到的jar包直接导入到idea下，ItelliJ IDEA —&gt;Preference—&gt;plugins—&gt;Install plugin from disk，如下图：</p><p>​        <img src="http://arthornye.github.io/images/OpenClover/openclover.png" alt="cmd-markdown-logo"></p><p>2.点击View -&gt; Toolbar显示插件按钮，如下图：</p><p><img src="http://arthornye.github.io/images/OpenClover/toolbar.png" alt="cmd-markdown-logo"></p><p>3.通过Preference—&gt;Build,Execution,Deployment—&gt;Clover setting(global settings)—&gt;Clover setting(project setting)我们可以进行一些插件的设置，如下图：</p><p><img src="http://arthornye.github.io/images/OpenClover/view.png" alt="cmd-markdown-logo"></p><h3 id="单元测试覆盖"><a href="#单元测试覆盖" class="headerlink" title="单元测试覆盖"></a>单元测试覆盖</h3><p>一般在开发过程中，开发会对dao层和service层进行基本的单元测试回归保证代码的交付质量，当然单元测试可能并没有覆盖到代码的全部情况。单元测试覆盖需要尽可能覆盖到我们的代码。在使用插件的过程中我们可以看到一张覆盖率的图表：</p><p>​        <img src="http://arthornye.github.io/images/OpenClover/pic.png" alt="cmd-markdown-logo"></p><p>这里主要做了service层的单元测试覆盖，覆盖率平均到了80以上，但是整个项目的覆盖率只有30不到。这里是因为插件统计项目中每个类进行的每个方法以及代码的覆盖率，包括控制层代码。代码中会显示绿色的为覆盖到的代码，红色的未覆盖的代码，包括一些异常，未被执行到的判断。判断如果是多个参数的，需要考虑到所有的情况才算是百分之100通过，可以看到覆盖代码如图：</p><p>​      <img src="http://arthornye.github.io/images/OpenClover/color.png" alt="cmd-markdown-logo"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本次单元测试覆盖率是鉴于部门对代码质量的要求，延续之前增加了sonar自定义检测代码规则。提升代码覆盖率的过程中发现其实是个体力活，这样的覆盖也许在后续补充为了达到指标也许并没有意义。这也许是为了我们可以在项目开发的过程中来补充单元测试用例保证代码交付质量，如果放到后面再来补，也就本末倒置了。希望今后的代码都能在开发过程中做到充分的单元测试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代码的单元测试覆盖率是衡量代码质量的标准之一，保证一定的ut覆盖率可以帮助提高开发人员的项目提测质量。本文将介绍如何在idea下利用openclover插件提高ut覆盖率。&lt;/p&gt;
&lt;h3 id=&quot;安装idea插件&quot;&gt;&lt;a href=&quot;#安装idea插件&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="大搜车的点滴记录" scheme="http://jianghao.wang/tags/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%9A%84%E7%82%B9%E6%BB%B4%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>git如何回滚远程仓库</title>
    <link href="http://jianghao.wang/2018/git%E5%A6%82%E4%BD%95%E5%9B%9E%E6%BB%9A%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <id>http://jianghao.wang/2018/git如何回滚远程仓库/</id>
    <published>2018-02-07T07:45:54.000Z</published>
    <updated>2018-02-07T07:45:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是个浮躁的日子，好像一整天也没有集中注意力看点东西。听到了群里在讨论一个线上的问题，进行了版本回退。响应很及时，想到如果自己的代码需要回退，应该如何操作更为合理。</p><h3 id="git-revert和git-reset的区别"><a href="#git-revert和git-reset的区别" class="headerlink" title="git revert和git reset的区别"></a>git revert和git reset的区别</h3><p>git revert和git reset是两种版本回退操作，revert需要提交信息，会生成一条新的提交，这条提交记录会将指定版本后的提交记录抵消掉，而且以前的历史记录都会保留。但是reset是进行HEAD的位置切换，不会出现新的提交记录。</p><h4 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h4><p>我尝试提交了提交了四次，可以看到我在尝试revert的时候遇到了冲突，git应该是将暂存区关于冲突的文件删除，我需要在处理完冲突之后git add将文件添加到暂存区，然后新建一个提交git commit -m “本次版本回退的commit信息”。</p><p><img src="http://arthornye.github.io/images/git/revert.png" alt="cmd-markdown-logo"></p><p>我们可以看到之前的历史提交记录都没有被改变，只是在之前的基础上添加了一次提交记录：</p><p><img src="http://arthornye.github.io/images/git/log.png" alt="cmd-markdown-logo"></p><h4 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h4><p>git reset的理解相对简单一些，它只是单纯做一个HEAD指针的切换并不会新增一个提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commitid</span><br></pre></td></tr></table></figure><p>通过commitid可以切换到指定的提交。也可以通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD~数值</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>这些形式都可以回退到指定的历史版本。在刚才的git log基础之上git reset —hard HEAD~2：</p><p><img src="http://arthornye.github.io/images/git/reset2.png" alt="cmd-markdown-logo"></p><h3 id="如何进行远程仓库版本回退"><a href="#如何进行远程仓库版本回退" class="headerlink" title="如何进行远程仓库版本回退"></a>如何进行远程仓库版本回退</h3><p>如何进行版本回退，方法一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git revert commitid //可能需要进行merge操作</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commitid</span><br><span class="line">git push -f    //强制提交更改，远程分支的head会被强制更改</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天是个浮躁的日子，好像一整天也没有集中注意力看点东西。听到了群里在讨论一个线上的问题，进行了版本回退。响应很及时，想到如果自己的代码需要回退，应该如何操作更为合理。&lt;/p&gt;
&lt;h3 id=&quot;git-revert和git-reset的区别&quot;&gt;&lt;a href=&quot;#git-re
      
    
    </summary>
    
    
      <category term="大搜车的点滴记录" scheme="http://jianghao.wang/tags/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%9A%84%E7%82%B9%E6%BB%B4%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>搭建本地SonarQube服务</title>
    <link href="http://jianghao.wang/2018/%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0SonarQube%E6%9C%8D%E5%8A%A1/"/>
    <id>http://jianghao.wang/2018/搭建本地SonarQube服务/</id>
    <published>2018-02-05T15:10:19.000Z</published>
    <updated>2018-02-06T09:04:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>部门需要对代码质量和风格进行统一，提高开发效率和质量。本篇主要对搭建sonar服务过程中碰到的问题做一个简单的复习记录。</p><h3 id="SonarQube介绍"><a href="#SonarQube介绍" class="headerlink" title="SonarQube介绍"></a>SonarQube介绍</h3><p>SonarQube是基于docker搭建的一个代码检测工具，内置了包括js，xml，java，c#等主流编程语言的代码检测规则。我们也可以通过sonarqube去添加自定义的检测规则。给予阿里巴巴开发手册尝试添加一个自定义的规则。</p><p>​    <img src="http://arthornye.github.io/images/sonar/sonarqube.png" alt="cmd-markdown-logo"></p><h3 id="搭建本地SonarQube服务"><a href="#搭建本地SonarQube服务" class="headerlink" title="搭建本地SonarQube服务"></a>搭建本地SonarQube服务</h3><p>可以通过<a href="http://sonarqube.com" target="_blank" rel="noopener">sonarqube官网</a>下载一个sonarqube。我本地安装的版本是6.7.1。下载之后直接解压就行，我们可以将这个理解为tomcat类似的服务器。下面会分析这个项目的结构。</p><h4 id="sonarqube目录结构"><a href="#sonarqube目录结构" class="headerlink" title="sonarqube目录结构"></a>sonarqube目录结构</h4><p>​    <img src="http://arthornye.github.io/images/sonar/directory.png" alt="cmd-markdown-logo"></p><p>我们进入到目录下，可以通过extensions目录增加自定义规则，后续会介绍，我们可以将自定义的代码规则打包这个目录下。</p><p>bin目录可以启动sonarqube服务，找到对应macos的版本我们可以尝试启动，注意这边启动的时候有个很诡异的地方，我们输入./sonar.sh status</p><p>可能会弹出提示，sonarqube is running，但是可能实际上服务可能是stopped未启动的状态，我们可以进入到日志文件tail -f logs/sonar.log查看具体的服务器启动状态。</p><p>conf目录下sonar.properties记录sonarqube的配置。我们可以配置访问端口以及本地数据库配置，sonarqube默认会链接到一个临时数据库，数据库主要记录扫描检测代码的结果。</p><h4 id="配置本地数据库"><a href="#配置本地数据库" class="headerlink" title="配置本地数据库"></a>配置本地数据库</h4><p>sonarqube可以配置本地连接mysql数据库，我们先创建本地mysql数据库账号，注意开启mysql本地服务。</p><p><img src="http://arthornye.github.io/images/sonar/database.png" alt="cmd-markdown-logo"></p><h4 id="maven配置打包自定义规则代码"><a href="#maven配置打包自定义规则代码" class="headerlink" title="maven配置打包自定义规则代码"></a>maven配置打包自定义规则代码</h4><p>sonarqube可以将自定义规则打包到extensions文件夹下，首先我们需要将自己写的自定义规则打包成jar包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;pluginGroups&gt;</span><br><span class="line">       &lt;pluginGroup&gt;org.sonarsource.scanner.maven&lt;/pluginGroup&gt;</span><br><span class="line">    &lt;/pluginGroups&gt;</span><br><span class="line">    &lt;profiles&gt;</span><br><span class="line">        &lt;profile&gt;</span><br><span class="line">            &lt;id&gt;sonar&lt;/id&gt;</span><br><span class="line">            &lt;activation&gt;</span><br><span class="line">                &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">            &lt;/activation&gt;</span><br><span class="line">            &lt;properties&gt;</span><br><span class="line">                &lt;!-- Optional URL to server. Default value is http://localhost:9000 --&gt;</span><br><span class="line">                &lt;sonar.host.url&gt;</span><br><span class="line">                  http://localhost:9000</span><br><span class="line">                &lt;/sonar.host.url&gt;</span><br><span class="line">            &lt;/properties&gt;</span><br><span class="line">        &lt;/profile&gt;</span><br><span class="line">     &lt;/profiles&gt;</span><br></pre></td></tr></table></figure><p>那么我们通过mvn sonar:sonar可以打包成功，然后在target目录下获取到打包好的jar包。</p><h4 id="sonarqube设置使用规则"><a href="#sonarqube设置使用规则" class="headerlink" title="sonarqube设置使用规则"></a>sonarqube设置使用规则</h4><p>我们登录到sonarqube创建一个自定义规则组。</p><p><img src="http://arthornye.github.io/images/sonar/addrules.png" alt="cmd-markdown-logo"></p><p>我们可以启用规则。</p><h4 id="Idea拉取代码分析结果sonarlink"><a href="#Idea拉取代码分析结果sonarlink" class="headerlink" title="Idea拉取代码分析结果sonarlink"></a>Idea拉取代码分析结果sonarlink</h4><p>我们可以在idea中下载插件，sonarlink配置到我们的sonarqube代码检测平台，将对应的代码检测结果下载到本地代码中注释。本地代码会在对应行的位置报错，不同的代码规则会给到不同的提示。这里需要保证本地代码的版本和远程分析代码的版本一致，不然可能部分的报错没办法正常显示在正确的位置。</p><p><img src="http://arthornye.github.io/images/sonar/sonartest.png" alt="cmd-markdown-logo"></p><h4 id="如何添加自定义代码规则"><a href="#如何添加自定义代码规则" class="headerlink" title="如何添加自定义代码规则"></a>如何添加自定义代码规则</h4><p>大家可以移步到<a href="https://github.com/ArthornYe/saas-sonar-rules" target="_blank" rel="noopener">我的github</a>，根据readme.md中的demo进行开发自定义规则。这里记录下自己开发过程中碰到的部分问题：</p><p>1.context.reportissue()调用过程需要指定对应的tree</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Rule(</span><br><span class="line">        key = &quot;SaasParamStartCheck&quot;,</span><br><span class="line">        name = &quot;POJO 类中布尔类型的变量，都不要加 is&quot;,</span><br><span class="line">        description = &quot;定义为基本数据类型Boolean isSuccess;的属性，它的方法也是isSuccess()，RPC 框架在反向解析的时候，“以为”对应的属性名称是 success，导致属性获取不到，进而抛出异常。&quot;,</span><br><span class="line">        priority = Priority.CRITICAL,</span><br><span class="line">        tags = &#123;&quot;bug&quot;&#125;)</span><br><span class="line">public class SaasParamStartCheck extends BaseCheck &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void visitClass(ClassTree tree)&#123;</span><br><span class="line">        //1.获取类信息</span><br><span class="line">        //2.获取属性元素</span><br><span class="line">        List&lt;Tree&gt; treeList=tree.members();</span><br><span class="line">        //3.判断属性命名</span><br><span class="line">        for(Tree oneTree:treeList)&#123;</span><br><span class="line">            if(oneTree instanceof VariableTree)&#123;</span><br><span class="line">                VariableTree variableTree=(VariableTree) oneTree;</span><br><span class="line">                if(variableTree.type()!=null &amp;&amp; variableTree.type().symbolType().name().equals(&quot;boolean&quot;))&#123;</span><br><span class="line">                    String name=variableTree.simpleName().name();</span><br><span class="line">                    if(checkStartWithIS(name))&#123;</span><br><span class="line">                        context.reportIssue(this,oneTree,&quot;属性名不能以is开头&quot;);</span><br><span class="line">                       // System.out.println(&quot;命名错误&quot;+&quot;属性名不能以is开头&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        super.visitClass(tree);</span><br><span class="line">    &#125;</span><br><span class="line">    Boolean checkStartWithIS(String name)&#123;</span><br><span class="line">        if(name.startsWith(&quot;is&quot;))&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行测试用例之后报错：</p><p><img src="http://arthornye.github.io/images/sonar/error.png" alt="cmd-markdown-logo"></p><p>因为错将tree打出，所以在报错的时候找错了行。抛出了异常。</p><h4 id="碰到的问题"><a href="#碰到的问题" class="headerlink" title="碰到的问题"></a>碰到的问题</h4><p>1.从本地访问localhost:9000会访问到空白页，一直没办法定位，一开始以为是数据库配置的问题，后面删除了本地数据库所有的表，sonarqube重启之后正常。</p><p>2.从本地访问localhost:9000空白页，上面提到过通过./sonar.sh status访问到的状态是sonarqube is running但是实际上sonarqube并没有启动成功。</p><p>3.从本地访问localhost:9000空白页，可能是本地数据库服务没打开，我们cd到mysql的目录下启动服务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;部门需要对代码质量和风格进行统一，提高开发效率和质量。本篇主要对搭建sonar服务过程中碰到的问题做一个简单的复习记录。&lt;/p&gt;
&lt;h3 id=&quot;SonarQube介绍&quot;&gt;&lt;a href=&quot;#SonarQube介绍&quot; class=&quot;headerlink&quot; title=&quot;So
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Paxos算法和BFT问题</title>
    <link href="http://jianghao.wang/2018/Paxos%E7%AE%97%E6%B3%95%E5%92%8CBFT%E9%97%AE%E9%A2%98/"/>
    <id>http://jianghao.wang/2018/Paxos算法和BFT问题/</id>
    <published>2018-02-05T10:18:04.000Z</published>
    <updated>2018-02-05T13:13:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>区块链可以去中心化，很大程度上依赖于自建的“共识机制”。Paxos是古代希腊的一个城邦，城邦中有众多议员，议员会对法律提案进行决议，提案通过通讯员进行提交。当某个提案者的提案获得大部分议员的赞同时，代表议案通过。这里涉及到的三个角色，议员，提案者，通讯员，可以对应到区块链网络。每个节点可以去计算hash值，将其作为一个提案，提交给区块链网络中其他的所有节点，这个过程中每个节点都在进行计算和提交：</p><p>1.Paxos问题保证这样的分布式网络中节点可能存在故障的情况下在最快的时间内达成共识。</p><p>2.BFT保证允许少数节点作恶（企图伪造消息）场景下的一致性达成问题。</p><h2 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h2><h3 id="什么是Paxos算法"><a href="#什么是Paxos算法" class="headerlink" title="什么是Paxos算法"></a>什么是Paxos算法</h3><p>Paxos问题是指分布式系统中存在故障（fault），但是不存在恶意（corrupt）节点场景（消息可能重复或者丢失但是没有错误消息）下的共识达成（consensus）问题。最早是Leslise Lamport用Paxos岛的故事模型来进行描述而命名。</p><p>Paxos可以保证在一半正常节点存在时，系统能达成共识。</p><h4 id="单个提案者-多个接收者"><a href="#单个提案者-多个接收者" class="headerlink" title="单个提案者+多个接收者"></a>单个提案者+多个接收者</h4><p>系统中只指定某个特定的节点时提案者，那么一致性肯定可以达成（只有一个方案，要么达成要么失败）。提案者只要收到了来自多数接收者的投票即可认为是通过，因为系统中不存在其他的提案。</p><h4 id="多个提案者-单个接收者"><a href="#多个提案者-单个接收者" class="headerlink" title="多个提案者+单个接收者"></a>多个提案者+单个接收者</h4><p>限定某个节点作为接收者。这种情况下，共识也很容易达成，接收者接收到多个提案，选择第一个提案作为决议，拒绝掉后续的提案。</p><p>缺陷也是容易发生单点故障，包括接受者故障或者首个提案节点发生故障。</p><p>上面这两种情形实际上类似主从模式，虽然并不是很可靠，但是原理十分简单，在zookeeper等应用中广泛存在。这里主要介绍提案者和接收者扩展到多个的情形。</p><h4 id="多个提案者-多个接受者"><a href="#多个提案者-多个接受者" class="headerlink" title="多个提案者+多个接受者"></a>多个提案者+多个接受者</h4><p>这种情况最接近于区块链共识机制，在区块链的所有节点中每个节点都可以去计算hash值，并发布给网络中的所有节点，当某个值获得大部分节点的赞同（校验hash值，可参考上篇文章）时，通过并写入数据库。</p><p>像这样的场景下，同一个时间片段内可能会有多个节点会去提交自己算出的hash值，企图通过大部分节点的校验。那么当同一个节点收到多个提案的时候如何进行区分？如果只接受第一个这样的方式，也会造成节点对提案的混乱。所以我们需要定一个意见领袖，也就是先来后到，当某个节点已经有提案被提交的时候，后续提交的节点可以广播这个节点的提案，这样不断扩散，也加速了达成共识的速度。</p><p>我们为每个提交的hash记录根据时间分配一个序号？我们可以尝试为每个节点进行编号，配合在前面加上时间戳来达到递增的目的。</p><h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><p>想象节点在发出自己的提案的时候，收到一些反馈。一种结果是自己的提案被大多数接收，另一种结果是没被接收。但是即便收到了来自大多数的反馈，也不能认为就是最终确认，因为这些接收者并不知道自己刚才反馈的就是全局的大多数，也就是意见领袖。</p><p>那么我们引入一个新的阶段，提案者在前一阶段拿到所有的反馈之后，判断这个提案是可能被大多数接受的提案，需要对其进行最终确认。</p><p>将Paxos分为准备（prepare）和提交（commit）两个阶段。准备阶段解决大家对哪个提案进行投票的问题（统一意见领袖），提交阶段解决确认最终值的问题。</p><h5 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h5><p>接受者时刻保留收到过的提案的最大编号和接受过的最大提案编号。如果收到的提案号比目前保留的最大的提案号还大，则返回自己已接受的提案值（如果还未收到过任何提案，则为空）给提案者，更新当前最大提案号，并说明不再接收小于最大提案号的提案。提案者以这样的方式去锁定大部分节点的支持。</p><h5 id="提交阶段"><a href="#提交阶段" class="headerlink" title="提交阶段"></a>提交阶段</h5><p>提案者如果收到大多数的回复(表示大部分人听到它的请求)，则可准备发出带有刚才<br>提案号的接受消息。如果收到的回复中不带有新的提案，说明锁定成功，则使用自己的提案内容（hash值）;如果返回中有提案内容，则替换提案值为返回中编号最大的提案值。接受者收到接受消息后，如果发现提案号不小于已接受的最大提案号，则接受该提案，  并更新接受的最大提案。</p><p>一旦多数接受了共同的提案值，则形成决议，成为最终确认的提案。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>区块链网络模型在对hash值达成共识的过程中可以类比多个提案者+多个接受者模型。当某个节点A计算出了某个hash值，会根据时间戳生成一个唯一的编号，然后将这个hash值提交给网络中其他节点进行审核。当然这个过程中可能也有别的节点B尝试进行提交。为了统一对某个hash值进行共识判断，我们首先要统一意见领袖，也就是尽量让整个系统统一对某个hash值进行判断。当统一之后再对这个hash值进行提交，这时系统中所有节点在准备阶段都已经保留了接受的提案编号，从而辨识当前提交的提案是否为意见领袖也就是第一阶段大家统一要处理的提案。在大多数节点统一之后这个hash值便会被直接写入数据库。</p><h2 id="BFT（Byzantine-Generals-Problem）拜占庭问题"><a href="#BFT（Byzantine-Generals-Problem）拜占庭问题" class="headerlink" title="BFT（Byzantine Generals Problem）拜占庭问题"></a>BFT（Byzantine Generals Problem）拜占庭问题</h2><p>拜占庭问题更为广泛，讨论的是允许少数节点作恶的（消息被伪造）场景下的一致性达成问题。拜占庭算法讨论的是最坏情况下的保障。</p><h4 id="中国将军问题"><a href="#中国将军问题" class="headerlink" title="中国将军问题"></a>中国将军问题</h4><p>拜占庭将军问题之前，就已经存在中国将军问题:两个将军要通过信使来达成进攻还是撤退的约定，但信使可能迷路或被敌军阻拦(消息丢失或伪造)，如何达成一致。</p><h4 id="拜占庭问题"><a href="#拜占庭问题" class="headerlink" title="拜占庭问题"></a>拜占庭问题</h4><p>拜占庭将军(Byzantine Generals Problem)问题，是 Leslie Lamport 1982 年提出用来解释一致性问题的一个虚构模型。拜占庭是古代东罗马帝国的首都，由于地域宽广，守卫边境的多个将军(系统中的多个节点)需要通过信使来传递消息，达成某些一致的决定。但由于将军中可能存在叛徒(系统中节点出错)，这些叛徒将努力向不同的将军发送不同的消息，试图会干扰一致性的达成。</p><p>拜占庭问题即为在此情况下，如何让忠诚的将军们能达成行动的一致。</p><p>对于拜占庭问题，如果节点总数为N，叛变的将军数为F，那么当N和F呈现怎样的分布时会让忠诚的将军们保证正确的决策。</p><p>我们很容易可以推理到N&gt;2F，当某个忠诚的节点希望得到正确的决策，会有F个篡改节点进行干扰，那么需要满足N-F&gt;F才能保证忠诚的一方可以胜利。</p><h4 id="PoW（Proof-of-Work）算法"><a href="#PoW（Proof-of-Work）算法" class="headerlink" title="PoW（Proof of Work）算法"></a>PoW（Proof of Work）算法</h4><p>比特币区块链网络在设计之初提出了创新的PoW（Proof of Work）算法思路。一个限制了一段时间内整个网络中出现的提案个数（增加提案成本，减少坏节点对系统的干扰）另外一个是放宽对最终一致性确认的需求，约定好大家都确认并沿着已知最长的链进行拓宽。这样，如果有人试图去篡改一条链，那么他的计算速度永远要大于网络中节点的计算速度。</p><p>这里的话个人理解，如果有人试图篡改一条链，在主链上生产一个分支链，是不是意味着他需要自己编写自己的账本数据计算hash值然后不断添加伪造链，那么这样的链是永远不可能被读到的。因为总是默认读最长的链，伪造的速度不可能大于真实存在的链的增长速度，因为算力上的差距是很大的。而且即使伪造链的长度要大于真实链，那么根据大多数原则，这条链也肯定会立即被系统中所共识的链取代。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>BFT和PoW算法为区块链的共识机制奠定了算法基础。这部分的东西个人觉得理解起来还是比较抽象的，需要具体化到很多现实的场景下可能会更好理解。我将Paxos共识的准备阶段类比为拿票，提案者先扫描所有决策者的队列去拿票（每个决策者只有一张票），先来的人（如果当前没人拿票）先拿到票，后来的人没办法拿票，只能查看当前票被谁拿走了，然后帮那个人先提交提案。<br>​<br>​<br>​<br>​<br>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;区块链可以去中心化，很大程度上依赖于自建的“共识机制”。Paxos是古代希腊的一个城邦，城邦中有众多议员，议员会对法律提案进行决议，提案通过通讯员进行提交。当某个提案者的提案获得大部分议员的赞同时，代表议案通过。这里涉及到的三个角色，议员，提案者，通讯员，可以对应到区块链网
      
    
    </summary>
    
    
      <category term="科技" scheme="http://jianghao.wang/tags/%E7%A7%91%E6%8A%80/"/>
    
  </entry>
  
  <entry>
    <title>工作问题记录</title>
    <link href="http://jianghao.wang/2018/%E5%B7%A5%E4%BD%9C%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://jianghao.wang/2018/工作问题记录/</id>
    <published>2018-01-28T04:03:44.000Z</published>
    <updated>2018-10-24T02:49:49.912Z</updated>
    
    <content type="html"><![CDATA[<h4 id="工作问题记录"><a href="#工作问题记录" class="headerlink" title="工作问题记录"></a>工作问题记录</h4><p>1.mac os查看本地ip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig |grep &quot;inet&quot;</span><br></pre></td></tr></table></figure><p>服务器git切换分支:</p><p>2.修改脚本指向本地分支，通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b localbranchname remotebranchname</span><br></pre></td></tr></table></figure><p>3.idea中java文件右下角有个红色的j：</p><p>不可编译，File—&gt;Project Structure—&gt;Module—&gt;Sources将右边第一个X点掉，去掉Root路径之后重新添加。</p><p>4.引入不必要文件修改.gitignore忽略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">'update .gitignore'</span></span><br></pre></td></tr></table></figure><p>我们在修改了gitignore文件之后，如果想要被忽略的文件目录已经被git add记录到git工作区中。需要git rm -r –cached .将文件从git中清除再重新add。之后所有被add的文件都会检验.gitignore文件是否忽略。</p><p><strong>如果git目录下没有.gitignore文件可以自行添加</strong></p><p>5.关闭linux服务器上所有的tomcat进程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep <span class="string">'org.apache.catalina.startup.Bootstrap start'</span> | awk <span class="string">'&#123; print $2 &#125;'</span> | xargs kill -<span class="number">9</span></span><br></pre></td></tr></table></figure><p>6.mvn clean install 找不到symbol问题</p><p>会报错maven-compile-plugin的版本问题，实际上是找不到依赖的包。这种问题可以从以下两个方面定位：</p><p>1.依赖错误，引用了低版本的jar包，部分本地仓库有低版本的拷贝，不会报错。</p><p>2.编译错误</p><p>有时候本地的引用类库和远程的类库不一致，或者低版本不被维护了，导致部分引用到低版本的在存在本地复制的情况下不会报错。</p><p>7.在最外层依赖jar包完全依赖不到</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--仓储服务--&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.souche&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;souche-storage-api&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>这样是不能将远程仓库的jar包直接下载到本地的，需要在parent上级添加依赖：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--仓储服务--&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.souche&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;souche-storage-api&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>这样就可以将包下载到本地。</p><p>8.打包执行了测试用例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -DskipTests 或者 mvn clean install -Dmaven.test.skip=<span class="keyword">true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;工作问题记录&quot;&gt;&lt;a href=&quot;#工作问题记录&quot; class=&quot;headerlink&quot; title=&quot;工作问题记录&quot;&gt;&lt;/a&gt;工作问题记录&lt;/h4&gt;&lt;p&gt;1.mac os查看本地ip&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;ta
      
    
    </summary>
    
    
      <category term="大搜车的点滴记录" scheme="http://jianghao.wang/tags/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%9A%84%E7%82%B9%E6%BB%B4%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>WTF is The BlockChain?</title>
    <link href="http://jianghao.wang/2018/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <id>http://jianghao.wang/2018/区块链/</id>
    <published>2018-01-15T03:32:25.000Z</published>
    <updated>2018-01-15T09:37:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近区块链大热，走到哪儿都有人在讨论区块链和比特币，甚至于一些对密码学完全没有概念的人都开始大肆吹捧，不免让人嗤之以鼻。相信很多技术和非技术的朋友都希望能够更深层次地去了解它是如何工作的。本文将用不到四千字来尝试阐述区块链的实现原理：</p><h3 id="为什么需要区块链这么复杂玩意儿？"><a href="#为什么需要区块链这么复杂玩意儿？" class="headerlink" title="为什么需要区块链这么复杂玩意儿？"></a>为什么需要区块链这么复杂玩意儿？</h3><blockquote><p>For every complex problem there is an answer that is clear, simple, and wrong.” — H. L. Mencken        </p></blockquote><p>在这里不尝试去给区块链一个准确的定义，而是通过区块链可以被使用的地方去分析和深入理解这项技术可能给世界带来的改变。</p><p>可以想象一个场景，你的朋友Joe在国外旅行，在旅行将要结束的第五天，他打电话给你说自己需要借点钱。你在接到电话之后会通知银行进行转账到Joe的指定账户，银行客户经理审查你的账户余额是否足够之后打钱给指定的Joe的账户。然后银行会产生一条转账记录：</p><p>​                             <img src="https://arthornye.github.io/images/banktransfer.png" alt="cmd-markdown-logo"></p><p>​    在打帐成功之后，银行通知你钱已经转账到位然后你会通知Joe打帐成功让其确认。<img src="https://arthornye.github.io/images/sure.png" alt="cmd-markdown-logo"></p><p>这样的转账方式是我们目前乃至几个世纪之前一直使用的，我们需要一个第三方机构进行担保，才能在彼此之间建立一种信任。但是这样的方式往往机构是单一的，也就是说如果这个第三方机构产生腐化，那么造成的影响也是巨大的（金融次贷危机的屡次发生），这就需要很多的人力去维持机构的工作以及政府的有力监管（政企腐败难以监管）。同时还会面临可能出现的几个问题：</p><ul><li>如果这个第三方机构的数据在一次火灾中被烧毁或者数据库数据直接被篡改。</li><li>又或者客户经理（第三方机构）在转账数额上动手脚，客户可能根本无法感知到（可以关注相关新闻）。</li></ul><blockquote><p>多年以来我们都将所有的鸡蛋放在第三方机构，并且建立了一种习惯上的信任。</p></blockquote><p>那么我们是否可以自己去建立这种信任，而不是通过第三方…….</p><h4 id="所以，区块链是如何工作的？"><a href="#所以，区块链是如何工作的？" class="headerlink" title="所以，区块链是如何工作的？"></a>所以，区块链是如何工作的？</h4><p>要达到不通过第三方的目的，我们需要聚集这些志同道合的人形成一个团队，以某种方式在内部建立一种信任机制。</p><p><img src="https://arthornye.github.io/images/group.png" alt="cmd-markdown-logo"></p><h4 id="一个空的文件夹"><a href="#一个空的文件夹" class="headerlink" title="一个空的文件夹"></a>一个空的文件夹</h4><p>现在我们发给每个人一个空的文件夹，这个团队内部所有的交易都会被写到各自的文件夹中，这些所有文件夹的集合共同建立了一种信任机制。</p><h4 id="发生转账事务"><a href="#发生转账事务" class="headerlink" title="发生转账事务"></a>发生转账事务</h4><p>每个人都配有一支笔和空白页，当团队内部发生转账交易时，会记录在自己的纸上，纸张满了会将其存入文件夹。那么我们假设#2想转10美元给#9，然后2号大喊一声：“我要转10块钱给9号，所有人都写下这笔记录”。</p><p><img src="https://arthornye.github.io/images/transaction.png" alt="cmd-markdown-logo"></p><p>然后每个人都去check一下2号是否有足够的钱去支持这笔转账，如果有的话每个人都写一份记录在自己的纸上。</p><p>​                            <img src="https://arthornye.github.io/images/firsttrans.png" alt="cmd-markdown-logo"></p><h4 id="持续产生转账记录"><a href="#持续产生转账记录" class="headerlink" title="持续产生转账记录"></a>持续产生转账记录</h4><p>通过这样的方式团队中每个人想转账就喊一声让其他人记录下这次转账记录，假设一张纸可以写十条记录，那么十条记录写满之后就需要将这张纸存进文件夹，然后拿出一张新的纸开始循环第二步。</p><p><img src="https://arthornye.github.io/images/fullfull.png" alt="cmd-markdown-logo"></p><p>在我们将写满的一页加入文件夹时，我们需要考虑一个问题如何保证这张被记录的纸是可信任的（所有的记录都未被篡改，所有人的纸张内容不一定一致，即使通过非对称加密保证通讯的加密性也不能保证每个节点都是忠诚的为这个分布式系统服务），那么我们需要给这张纸的内容盖一个印章。盖这个章的目的：</p><ul><li>保证团队所有写入的记录都是未被篡改而且一致。</li><li>保证团队从文件夹取出的历史记录未被篡改。</li></ul><h3 id="如何去进行签章"><a href="#如何去进行签章" class="headerlink" title="如何去进行签章"></a>如何去进行签章</h3><p>以前我们通过第三方/中间人建立信任，无条件信任第三方。在区块链这样的分布式和分散系统中，这个印章将会提供信任。在进行签章之前我们需要了解hash算法：</p><blockquote><p>Given an output, it is extremely difficult to calculate the input, but given an input and output, it is pretty easy to verify if the input leads to the output.</p></blockquote><ul><li>无冲突。任何一个a通过hash算法能生成一个唯一对应的b。</li><li>不可逆。任何一个a通过hash算法生成的b是不可逆的，也就是知道b不能推出a。</li></ul><p>那么我们可以用一种box的概念来描述这种算法：</p><p><img src="https://arthornye.github.io/images/hash.png" alt="cmd-markdown-logo"></p><p>​                            <img src="https://arthornye.github.io/images/testhash.png" alt="cmd-markdown-logo"></p><p>一个input对应一个output，现在我们可以假设我们要得到的结果必须以三个零开头，得到这样的结果集算成功。</p><p><img src="https://arthornye.github.io/images/threezero.png" alt="cmd-markdown-logo"></p><p>然后开始不停地计算和重试，挖矿的过程就是计算签章的过程，实际的过程比这更复杂，但是可以用这种方式类比。</p><p><img src="https://arthornye.github.io/images/try.png" alt="cmd-markdown-logo"></p><p>经过无数次尝试可能得到结果：</p><p><img src="https://arthornye.github.io/images/result.png" alt="cmd-markdown-logo"></p><h4 id="如何利用hash算法去进行签章？"><a href="#如何利用hash算法去进行签章？" class="headerlink" title="如何利用hash算法去进行签章？"></a>如何利用hash算法去进行签章？</h4><p>在hash算法的基础之上，我们需要关联纸张中的内容，通过下面的算法得到签章：</p><p><img src="https://arthornye.github.io/images/get.png" alt="cmd-markdown-logo"></p><p>矿工帮我们计算好的到的签章数字为“21191”：</p><p><img src="https://arthornye.github.io/images/sign.png" alt="cmd-markdown-logo"></p><p>然后我们将签章通知团队中所有的人，他们会各自验证，这个签章的值+纸张内容值的hash结果是不是符合000开头的标准。只要大多数通过，那么这个数值有效，挖出这个数值的矿工会获得相应的奖励，最后所有人都签上这个签章，然后将记录存储在文件夹中：</p><p>​                            <img src="https://arthornye.github.io/images/signresult.png" alt="cmd-markdown-logo"></p><p>在矿工工作的过程中，也可能产生欺诈行为，错误的签章数字不能通过团队其他人的校验。其他人如果内容记录被修改过也不能通过校验，这样就保证了被存储的记录永远是可信任的（通过大多数人一致的原则保证）。在挖矿的过程中会消耗“燃料”，这个成本和电力的消耗是巨大的，团队中每个人必须签上章，签章校验不过可能的原因：</p><p>​                          <img src="https://arthornye.github.io/images/seal.png" alt="cmd-markdown-logo"></p><ul><li>节点可能误听了网络中的交易。</li><li>节点可能错写了网络中的交易。</li><li>节点可能试图盗取或者欺骗网络中的其他节点。</li></ul><p>当然无论出于何种原因，校验不通过的节点只能从其他节点中拷贝一份账本到自己的文件夹中。</p><h4 id="为什么要建立一种竞争机制"><a href="#为什么要建立一种竞争机制" class="headerlink" title="为什么要建立一种竞争机制"></a>为什么要建立一种竞争机制</h4><p>我们可能有个疑问，为什么花费大量的资源去计算这个签章值，建立在竞争机制下的计算出了第一个算力的结果值是有效的。其他的算力都是在产生浪费，之前新加坡一家区块链公司针对比特币产生的大量资源浪费提出了分块计算进行资源利用的优化，但是并没有消除这种竞争，那么我们为什么需要这种竞争？</p><p>这就是我们需要了解的激励机制，每个区块链中的节点都可以去竞争这个奖励。第一个计算出来签章的会获得一定的奖励（在消耗大量cpu和电力资源的前提下）。</p><p>假设五号计算出了这个签章值，它会获得这个奖励可能是1bitcorn，它的账户余额也会相应增加。这就是比特币以及大多区块链一致存在的原因，不断会有新的节点加入挖矿，成为分布式账本中的一员参与竞争。只有足够多的节点加入，这个区块链才能建立一种更为健全的共识机制。</p><p>当有足够的人拥有比特币时，他们的价值就会增长，使其他人想要比特币;使比特币进一步增长;使更多的人想要比特币;使其进一步增长;等等</p><blockquote><p>激励机制使网络中所有节点都在努力工作。</p></blockquote><p>在此之前我并没有提到过一个问题，想象一下如果我们现在的文件夹已经存储了五页纸张，都被签上了各自的签章。那么如果我找到第二页并且企图去修改一次交易信息？签章会保证这次修改再取出的时候被检测到被修改对吧？但是如果我同时计算一个新的签章，并且替换掉旧的签章呢，我可以修改一个就可以修改网络节点中其他的节点，当超过百分之五十的节点都被篡改了签章，那么这页数据也就被成功篡改，网络的共识机制无法感知。所以我们的区块链设计有漏洞？</p><h4 id="如何防止签章被篡改"><a href="#如何防止签章被篡改" class="headerlink" title="如何防止签章被篡改"></a>如何防止签章被篡改</h4><p>我们其实很容易想到，在上面产生签章的模型中我们用了页面的内容和一个未知值作为input，实际上如果要防止签章数字被篡改。我们可以在input中增加一个数值，将上一页的签章数值作为这一页数值计算的输入：</p><p>​    <img src="https://arthornye.github.io/images/right.png" alt="cmd-markdown-logo"></p><p>当我们通过这样的方式将每一页的数据关联在一起的时候，如果有人试图去篡改某一页的签章，那么它需要篡改之前连续很多页的签章和内容，这样的代价是极大的，修改一个节点数据的代价是完全创造一份新的数据，然后为了破坏共识机制还需要修改网络中大于一半的节点数据。</p><p>也就是说基于现在区块链的设计，你需要不断去产生新的区块，篡改节点全部的数据，通过计算不断去篡改，但是一个人的篡改速度远远没有其他节点继续计算和不断回写数据的速度。即使是针对同一个节点，最长的链也永远是最可信的：</p><blockquote><p>Longest chain is the honest chain.</p></blockquote><p><img src="https://arthornye.github.io/images/longest.png" alt="cmd-markdown-logo"></p><p>绿色的部分是篡改者企图想要开启的一条篡改的链路，红色的部分是正常发展的链路，下面的链路计算能力永远大于上面链路的计算能力，基于共识机制团队中大部分人都是诚实的。</p><h4 id="团队中超过半数的人不诚实？"><a href="#团队中超过半数的人不诚实？" class="headerlink" title="团队中超过半数的人不诚实？"></a>团队中超过半数的人不诚实？</h4><p>这就是区块链如果可能会崩溃的唯一脆弱的原因。 要知道，这是不太可能发生的，但我们都必须知道系统的弱点。 它建立在大多数人群总是诚实的假设之上。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文希望给大家一个对区块链较为深入的了解。区块链是如何达到去中心化的目的的，明白了共识机制以及共识机制的基本条件，我们可以尝试去理解区块链能够如何改变我们的生活。其实不难发现，区块链的设计并没有那么复杂，将所有的节点理解为区块，每个区块都是链接起来的账本数据。</p><p>向创造区块链思想的中本聪致敬，我们需要从不同的角度去思考现在的生活，正如乔布斯所说，世界上没有一种设计是理所当然的。也许有一天我们不再需要键盘来操作电脑，于是苹果设计了触摸板，至今没有用过比这更有创意的快捷操作。</p><p>最后，希望我们都能想孩童一样去思考，创造一个不一样的世界。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近区块链大热，走到哪儿都有人在讨论区块链和比特币，甚至于一些对密码学完全没有概念的人都开始大肆吹捧，不免让人嗤之以鼻。相信很多技术和非技术的朋友都希望能够更深层次地去了解它是如何工作的。本文将用不到四千字来尝试阐述区块链的实现原理：&lt;/p&gt;
&lt;h3 id=&quot;为什么需要区块
      
    
    </summary>
    
    
      <category term="科技" scheme="http://jianghao.wang/tags/%E7%A7%91%E6%8A%80/"/>
    
  </entry>
  
  <entry>
    <title>微信小游戏那些坑</title>
    <link href="http://jianghao.wang/2018/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
    <id>http://jianghao.wang/2018/微信小游戏那些坑/</id>
    <published>2018-01-12T10:04:24.000Z</published>
    <updated>2018-01-15T09:55:49.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-未找到入口-app-json-文件，或者文件读取失败，请检查后重新编译"><a href="#1-未找到入口-app-json-文件，或者文件读取失败，请检查后重新编译" class="headerlink" title="1.未找到入口 app.json 文件，或者文件读取失败，请检查后重新编译"></a>1.未找到入口 app.json 文件，或者文件读取失败，请检查后重新编译</h4><p>微信小程序和小游戏在微信公众号是两个不同的东西，安装开发者工具错误安装了微信小程序。从微信开放平台重新瞎下载<a href="https://mp.weixin.qq.com/debug/wxagame/dev/devtools/download.html?t=2018110" target="_blank" rel="noopener">微信游戏开发者工具</a>最新版本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-未找到入口-app-json-文件，或者文件读取失败，请检查后重新编译&quot;&gt;&lt;a href=&quot;#1-未找到入口-app-json-文件，或者文件读取失败，请检查后重新编译&quot; class=&quot;headerlink&quot; title=&quot;1.未找到入口 app.json 文
      
    
    </summary>
    
    
      <category term="大搜车微信小游戏学习点滴" scheme="http://jianghao.wang/tags/%E5%A4%A7%E6%90%9C%E8%BD%A6%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%AD%A6%E4%B9%A0%E7%82%B9%E6%BB%B4/"/>
    
  </entry>
  
</feed>
