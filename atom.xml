<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TizzyT&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/9dde1b9d65b89035e235650923e5811e</icon>
  <subtitle>即使是拖后腿的，拼死努力的话，也是可以超越精英的。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jianghao.wang/"/>
  <updated>2019-09-30T06:56:29.390Z</updated>
  <id>http://jianghao.wang/</id>
  
  <author>
    <name>yeqiaozhu</name>
    <email>yqz_zjut@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Balanced Binary Tree</title>
    <link href="http://jianghao.wang/2019/P110%20Balanced%20Binary%20Tree/"/>
    <id>http://jianghao.wang/2019/P110 Balanced Binary Tree/</id>
    <published>2019-09-30T06:09:52.696Z</published>
    <updated>2019-09-30T06:56:29.390Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度简单-110）"><a href="#问题描述（难度简单-110）" class="headerlink" title="问题描述（难度简单-110）"></a>问题描述（难度简单-110）</h3><p>Given a binary tree, determine if it is height-balanced.</p><p>For this problem, a height-balanced binary tree is defined as:</p><blockquote><p>a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p></blockquote><p><strong>Example 1:</strong></p><p>Given the following tree <code>[3,9,20,null,null,15,7]</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>Return true.</p><p><strong>Example 2:</strong></p><p>Given the following tree <code>[1,2,2,3,3,null,null,4,4]</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     / \</span><br><span class="line">    2   2</span><br><span class="line">   / \</span><br><span class="line">  3   3</span><br><span class="line"> / \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure><p>Return false.</p><h3 id="方法一：递归（Recursive）"><a href="#方法一：递归（Recursive）" class="headerlink" title="方法一：递归（Recursive）"></a>方法一：递归（Recursive）</h3><p>判断平衡树是否平衡的标准：</p><ul><li><strong>左右子树的高度差不大于1。这里的高度值得是树的最大高度。</strong></li></ul><p>根据标准得到一个递归公式（没有好的作图工具，直接看height函数的递归实现）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> height(root)==-<span class="number">1</span>?<span class="keyword">false</span>:<span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode treeNode)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (treeNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> leftHeight=height(treeNode.left);</span><br><span class="line">       <span class="keyword">int</span> rightHeight=height(treeNode.right);</span><br><span class="line">       <span class="keyword">if</span>(leftHeight==-<span class="number">1</span> || rightHeight==-<span class="number">1</span> || Math.abs(leftHeight-rightHeight)&gt;<span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> Math.max(leftHeight,rightHeight)+<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>首先掌握平衡树的判断标准，不能用最大深度减去最小深度来进行计算。需要递归判断左右子树的高度差，当递归到高度差大于1的时候递归往上返回-1值。递归到null时，说明到达了叶子结点的下的空节点，返回0。其他情况都返回左右节点的最大高度加1。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度简单-110）&quot;&gt;&lt;a href=&quot;#问题描述（难度简单-110）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度简单-110）&quot;&gt;&lt;/a&gt;问题描述（难度简单-110）&lt;/h3&gt;&lt;p&gt;Given a binary tree, d
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Single Number</title>
    <link href="http://jianghao.wang/2019/P136%20Single%20Number/"/>
    <id>http://jianghao.wang/2019/P136 Single Number/</id>
    <published>2019-09-20T07:00:07.169Z</published>
    <updated>2019-09-30T06:15:52.530Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度简单-136）"><a href="#问题描述（难度简单-136）" class="headerlink" title="问题描述（难度简单-136）"></a>问题描述（难度简单-136）</h3><p>Given a <strong>non-empty</strong> array of integers, every element appears <em>twice</em> except for one. Find that single one.</p><p><strong>Note:</strong></p><p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,1,2,1,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><h3 id="XOR（异或）"><a href="#XOR（异或）" class="headerlink" title="XOR（异或）"></a>XOR（异或）</h3><p>如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。</p><h3 id="方法一：一边遍历Map"><a href="#方法一：一边遍历Map" class="headerlink" title="方法一：一边遍历Map"></a>方法一：一边遍历Map</h3><p>一遍遍历保留只出现一次的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map= <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(nums[i])==<span class="keyword">null</span>)&#123;</span><br><span class="line">                map.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                map.remove(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (Integer) map.keySet().toArray()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：XOR"><a href="#方法二：XOR" class="headerlink" title="方法二：XOR"></a>方法二：XOR</h3><p>first , we have to know the bitwise XOR in java:</p><ul><li><strong>0 ^ N = N</strong></li><li><strong>N ^ N = 0</strong></li></ul><p>So….. if N is the single number:</p><p>N1 ^ N1 ^ N2 ^ N2 ^…………..^ Nx ^ Nx ^ N= (N1^N1) ^ (N2^N2) ^…………..^ (Nx^Nx) ^ N= 0 ^ 0 ^ ……….^ 0 ^ N</p><p>= N</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans =<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;i++)</span><br><span class="line">        ans ^= nums[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>采用XOR（异或）的方式，相同的数字都相互抵消了，最后留下单一的不同的数字。也就是方法二的精髓。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度简单-136）&quot;&gt;&lt;a href=&quot;#问题描述（难度简单-136）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度简单-136）&quot;&gt;&lt;/a&gt;问题描述（难度简单-136）&lt;/h3&gt;&lt;p&gt;Given a &lt;strong&gt;non-em
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java中的阻塞队列</title>
    <link href="http://jianghao.wang/2019/%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/Java%E4%B8%AD%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>http://jianghao.wang/2019/并发学习/Java中的阻塞队列/</id>
    <published>2019-07-30T05:00:06.328Z</published>
    <updated>2019-08-02T07:30:28.628Z</updated>
    
    <content type="html"><![CDATA[<p>Java中的阻塞队列，可以基于BlockingQueue接口自定义实现多种自定义阻塞队列。阻塞队列最经典的应用主要是帮助线程池管理任务，是一个经典的等待/通知（生产者/消费者）模型。这里根据源码主要介绍几种比较经典的实现，并提炼出一些经典范式。</p><table><br><tr><br>    <th>add</th><br>    <th>remove</th><br>    <th>抛出异常</th><br></tr><br><tr><br>    <th>put</th><br>    <th>take</th><br>    <th>等待直到中断</th><br></tr><br><tr><br>    <th>offer</th><br>    <th>poll</th><br>    <th>直接返回</th><br></tr><br><tr><br>    <th>offer(time)</th><br>    <th>poll(time)</th><br>    <th>设定等待时间</th><br></tr><br></table><h3 id="LinkedBlockingQueue（基于链表的有界阻塞队列）"><a href="#LinkedBlockingQueue（基于链表的有界阻塞队列）" class="headerlink" title="LinkedBlockingQueue（基于链表的有界阻塞队列）"></a>LinkedBlockingQueue（基于链表的有界阻塞队列）</h3><p>Executors.newFixedThreadPool（根据需要可重用部分消费者线程数）和Executors.newSingledThreadPool（单个消费者线程）都使用了LinkedBlockingQueue无界队列来管理任务。</p><h4 id="put-take（double-lock-wait-notify）"><a href="#put-take（double-lock-wait-notify）" class="headerlink" title="put/take（double lock+wait/notify）"></a>put/take（double lock+wait/notify）</h4><p>通过双锁来增加队列的并发度，通过wait/notify进行等待/通知。因为通常无界队列默认可以容下Integer.MAX_VALUE的任务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java中的阻塞队列，可以基于BlockingQueue接口自定义实现多种自定义阻塞队列。阻塞队列最经典的应用主要是帮助线程池管理任务，是一个经典的等待/通知（生产者/消费者）模型。这里根据源码主要介绍几种比较经典的实现，并提炼出一些经典范式。&lt;/p&gt;
&lt;table&gt;&lt;br
      
    
    </summary>
    
    
      <category term="源码解析" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://jianghao.wang/2019/%E7%AE%80%E5%8E%86/"/>
    <id>http://jianghao.wang/2019/简历/</id>
    <published>2019-07-22T08:13:50.299Z</published>
    <updated>2019-09-23T15:11:15.993Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本资料"><a href="#基本资料" class="headerlink" title="基本资料"></a>基本资料</h3><p>姓名 : 叶乔柱                                                       联系电话：18668486087   </p><p>电子邮箱： <a href="mailto:yqz_zjut@aliyun.com" target="_blank" rel="noopener">yqz_zjut@aliyun.com</a>                           毕业院校：浙江工业大学计算机学院</p><p>出生年月：1993年8月                                         专业：计算机科学与技术</p><p>求职意向：Java/全栈                                          技术博客：<a href="http://arthornye.github.io" target="_blank" rel="noopener">http://arthornye.github.io</a> </p><h3 id="职业技能"><a href="#职业技能" class="headerlink" title="职业技能"></a>职业技能</h3><ul><li>专业技能 综合能力： 演讲能力 | 责任心 | 团队精神 | 英语 | 数据库软件 。</li><li>熟悉基于 Mysql 的数据库设计，Sql 性能调优，对数据库引擎有一定的了解。</li><li>熟悉 Spring, Mybatis 框架的使用，且对其原理有一定的理解。</li><li>熟悉 Java 编程基础，熟悉多线程并发，反射，集合等高级特性，并且对 Jvm 有一定的理解。</li><li>了解分布式消息服务，分布式存储缓存，分布式服务框架。 </li><li>熟悉 ReactJS，Jquery，AngularJS，Jsx，Html 标准语法，具备一定的前端开发能力。 </li><li>熟悉 Git 管理代码，Maven 项目管理。  </li></ul><h3 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h3><p><strong>杭州大搜车汽车服务有限公司（新车新零售）</strong>    2017.07 - 2019.09</p><p>先后独立负责线上 App 和 PC 签署汽车销售合同模块搭建，对接公司内部基础服务和支付宝开放平台。参与和阿里天猫共同合作的汽车新零售项目，对接公司内部支付网关和外部天猫平台。负责公司后台运营系统 Web 页面以及后台搭建。对小组内部已有业务做 Sql 性能优化改造。运用 Dubbo，MQ 支付消息，通过 Swagger 为前端提供文档。  </p><p><strong>浙江远图互联科技股份有限公司（互联网医疗）</strong>    2016.06 - 2017.06 </p><p>搭建医院系统 His，Lis 以及 Pacs 适配器，为公司自助终端和移动终端服务提供统一医院内部系统入口，包括挂号，缴费，充值，医保等服务。系统采用 Springmvc+Ibatis+Mysql 实现，通过 Socket，Websevice，存储过程，视图以及 Http 等多种方式与医院内部系统交互，实现复杂的医疗服务逻辑。对接公司内部支付系统和结算系统，实现医院内部的各种支付以及对账。 </p><p><strong>杭州博克软件有限公司（外企实习）</strong>    2015.03 – 2016.01</p><p>任职于公司研发部门，设计实现内部提名系统，全程采用scrum敏捷开发方式和英文汇报交流工作，供内部人员使用。整套系统通过Html+Bootstrap+Jquery+AngularJS框架搭建前端页面，Mysql做数据存储。</p><h3 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h3><h4 id="订单交易模块"><a href="#订单交易模块" class="headerlink" title="订单交易模块"></a>订单交易模块</h4><p>功能： 新车交易采购和零售，为4s店和二网等B端提供订单交易Api服务，对接天猫券中心C端购买优惠券后线下进行核销，客户在天猫上签署合同支付尾款。                </p><p>技术： Dubbo 、Redis 、RocketMQ 、Spring 、Mysql         </p><p>简述： </p><ul><li><p>交易模块主要基于Mysql和Redis集群做数据存储，使用RocketMQ做消息队列，通过Dubbo微服务化， 基于ZK集群搭建高可用系统。                   </p></li><li><p>前期我们整个交易前台模块的设计面向过程编程，服务耦合性较高，后期对部分业务引入基于观察者模式的 Spring状态机和事件监听机制。                          </p></li><li><p>前期订单管理分页基于Sql优化分页查询，后期引入ESSearch。            </p></li></ul><h4 id="运营后台管理系统"><a href="#运营后台管理系统" class="headerlink" title="运营后台管理系统"></a>运营后台管理系统</h4><p>功能： 运营订单管理，订单搜索，详情页展示，报表导出，针对部门各个业务线。 </p><p>技术： React 、Ant Design、Webpack、 Dubbo 、 ESSearch、Mysql </p><p>简述：</p><ul><li><p>通过 React+Antd Design搭建订单管理、详情、审核以及导出页面。              </p></li><li><p>基于简单工厂和策略模式改善运营后台订单导出功能，便于扩展各个业务。                                              </p></li><li><p>前期基于Sql优化分页查询，后期引入ESSearch。 </p></li><li><p>链接： <a href="http://arthornye.github.io/2019/ShowPages/" target="_blank" rel="noopener">http://arthornye.github.io/2019/ShowPages/</a> </p></li></ul><h4 id="网关适配系统"><a href="#网关适配系统" class="headerlink" title="网关适配系统"></a>网关适配系统</h4><p>功能： 适配医院内部复杂系统，为客户端提供统一Api入口。</p><p>技术： WebService、SpringMVC、Mysql、Ibatis、Nginx </p><p>简述： </p><ul><li>系统主要部署在医院内部，Nginx做负载均衡，Mysql做数据存储，通过令牌进行高峰限流。           </li><li>后期通过简单工厂和策略模式针对不同的医院逻辑提供不同实现，支持WebService，Socket，存储过程等多种 适配方式。  </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本资料&quot;&gt;&lt;a href=&quot;#基本资料&quot; class=&quot;headerlink&quot; title=&quot;基本资料&quot;&gt;&lt;/a&gt;基本资料&lt;/h3&gt;&lt;p&gt;姓名 : 叶乔柱                                                      
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Show Pages</title>
    <link href="http://jianghao.wang/2019/ShowPages/"/>
    <id>http://jianghao.wang/2019/ShowPages/</id>
    <published>2019-07-22T04:52:17.228Z</published>
    <updated>2019-07-22T05:06:36.804Z</updated>
    
    <content type="html"><![CDATA[<h3 id="订单详情"><a href="#订单详情" class="headerlink" title="订单详情"></a>订单详情</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="http://arthornye.github.io/images/detail.png" alt="cmd-markdown-logo"></h3><h3 id="订单列表"><a href="#订单列表" class="headerlink" title="订单列表"></a>订单列表</h3><p><img src="http://arthornye.github.io/images/manager.png" alt="cmd-markdown-logo"></p><h3 id="订单导出"><a href="#订单导出" class="headerlink" title="订单导出"></a>订单导出</h3><p><img src="http://arthornye.github.io/images/export.png" alt="cmd-markdown-logo"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;订单详情&quot;&gt;&lt;a href=&quot;#订单详情&quot; class=&quot;headerlink&quot; title=&quot;订单详情&quot;&gt;&lt;/a&gt;订单详情&lt;/h3&gt;&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;img src=&quot;h
      
    
    </summary>
    
    
      <category term="大搜车的点滴记录" scheme="http://jianghao.wang/tags/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%9A%84%E7%82%B9%E6%BB%B4%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>CopyOnWriteArrayList</title>
    <link href="http://jianghao.wang/2019/CopyOnWriteArrayList%E4%BB%8B%E7%BB%8D/"/>
    <id>http://jianghao.wang/2019/CopyOnWriteArrayList介绍/</id>
    <published>2019-07-01T07:56:26.260Z</published>
    <updated>2019-07-01T12:39:19.744Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要介绍juc内部针对数组提供的并发容器<strong>CopyOnWriteArrayList</strong>，主要的思想是针对增删改等修改操作都将原数组拷贝一份新数组，然后做完修改操作后，通过原子的方式写入到原数组的引用，通知到其他线程。</p><h3 id="CopyOnWriteArrayList实现"><a href="#CopyOnWriteArrayList实现" class="headerlink" title="CopyOnWriteArrayList实现"></a>CopyOnWriteArrayList实现</h3><p>设计一个线程安全的容器主要针对改（增删改）和查操作，<strong>CopyOnWriteArrayList</strong>对put操作通过RetrantLock加锁，将数组定义为volatile类型，再通过加锁完成新数组的生成之后，将新数组赋值给volatile数组，通知到其他线程。这里的lock同样我们可以用synchronized关键字或者cas来实现。put操作源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Object[] elements = getArray();</span><br><span class="line">           <span class="keyword">int</span> len = elements.length;</span><br><span class="line">           Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">           newElements[len] = e;</span><br><span class="line">           setArray(newElements);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="Iterating过程中不允许修改"><a href="#Iterating过程中不允许修改" class="headerlink" title="Iterating过程中不允许修改"></a>Iterating过程中不允许修改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.study.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayListTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] integers=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        DefinedCopyOnWirteArrayList list=<span class="keyword">new</span> DefinedCopyOnWirteArrayList(integers);</span><br><span class="line"></span><br><span class="line">        Iterator iterator=list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            <span class="comment">//不允许操作，抛出异常</span></span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器浅拷贝，不允许修改，只能查询而且是临时快照</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"remove"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过CAS改写CopyOnWriteArrayList"><a href="#通过CAS改写CopyOnWriteArrayList" class="headerlink" title="通过CAS改写CopyOnWriteArrayList"></a>通过CAS改写CopyOnWriteArrayList</h3><p>继承CopyOnWriteArrayList进行方法的重写，重新实现的add方法供参考：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.study.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义CopyOnWriteArrayList的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefinedCopyOnWirteArrayList</span> <span class="keyword">extends</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Integer[]&gt; atomicIntegers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefinedCopyOnWirteArrayList</span><span class="params">(Integer[] integers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.atomicIntegers = <span class="keyword">new</span> AtomicReference&lt;&gt;(integers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">(Integer index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;atomicIntegers.get().length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"数组越界"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> atomicIntegers.get()[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Integer insertData)</span></span>&#123;</span><br><span class="line">        <span class="comment">//step 1:拷贝一份数组</span></span><br><span class="line">        Integer[] integers=atomicIntegers.get();</span><br><span class="line">        <span class="keyword">int</span> length=integers.length;</span><br><span class="line">        Integer[] newIntegers=Arrays.copyOf(integers,length+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//step 2:将新值添加到新的数组中</span></span><br><span class="line">        newIntegers[length]=insertData;</span><br><span class="line">        <span class="comment">//step 3:采用cas替换引用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.atomicIntegers.compareAndSet(integers,newIntegers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CopyOnWriteArrayList设计-vs-RetrantWriteReadLock"><a href="#CopyOnWriteArrayList设计-vs-RetrantWriteReadLock" class="headerlink" title="CopyOnWriteArrayList设计 vs RetrantWriteReadLock"></a>CopyOnWriteArrayList设计 vs RetrantWriteReadLock</h3><p>对比一下<strong>CopyOnWriteArrayList设计</strong>和<strong>RetrantWriteReadLock</strong>的实现。</p><ul><li><strong>CopyOnWriteArrayList设计读不加锁，写加锁。RetrantWriteReadLock读和写都加锁。</strong></li><li><strong>CopyOnWriteArrayList设计针对读多写少场景表现优。RetrantWriteReadLock虽然针对读锁做了共享，读多写少依旧阻塞。</strong></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>感觉CopyOnWriteArrayList的设计还是蛮巧妙的，之前在了解读写锁的这种设计时还是蛮质疑这个设计的实际意义的。类比innodb的MDL表锁（如果一个写操作（修改表结构）获取到写锁前面有一个长事务获取读锁，那么所有的ddl操作（读锁）都有被阻塞），inndb因此设计了更小粒度的行锁。行锁同时设计了写锁，但是取消了读锁，用MVCC多版本并发控制取代，类比CopyOnWriteArrayList保留了写锁，通过线程通信的方式取消了读锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇主要介绍juc内部针对数组提供的并发容器&lt;strong&gt;CopyOnWriteArrayList&lt;/strong&gt;，主要的思想是针对增删改等修改操作都将原数组拷贝一份新数组，然后做完修改操作后，通过原子的方式写入到原数组的引用，通知到其他线程。&lt;/p&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
    
      <category term="juc源码学习" scheme="http://jianghao.wang/tags/juc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Find All Numbers Disappeared in an Array</title>
    <link href="http://jianghao.wang/2019/Find%20All%20Numbers%20Disappeared/"/>
    <id>http://jianghao.wang/2019/Find All Numbers Disappeared/</id>
    <published>2019-06-06T01:29:54.700Z</published>
    <updated>2019-06-06T02:02:07.232Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述-难度简单-448"><a href="#问题描述-难度简单-448" class="headerlink" title="问题描述 (难度简单-448)"></a>问题描述 (难度简单-448)</h3><p>Given an array of integers where 1 ≤ a[i] ≤ <em>n</em> (<em>n</em> = size of array), some elements appear twice and others appear once.</p><p>Find all the elements of [1, <em>n</em>] inclusive that do not appear in this array.</p><p>Could you do it without extra space and in O(<em>n</em>) runtime? You may assume the returned list does not count as extra space.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure><h3 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h3><p>需要在一次遍历的过程中标记已经出现过的数字，进而找出未出现的数字，只能通过自身的数组进行标记。按照上面的示例，索引位置为0的位置值为4，我们需要将4标记一下已经出现过，索性用索引位置为3的地方做标记，将对应的值取反，标记为负值。<strong><em>这样1-8的数组可以对应0-7的索引位置进行标记，最后未被标记为负值的元素的index加上1即为未出现过的数字</em></strong>。迭代的流程如下图：</p><p><img src="https://arthornye.github.io/images/disappear-first.jpg" alt="cmd-markdown-logo"></p><p><img src="https://arthornye.github.io/images/disappear-second.jpg" alt="cmd-markdown-logo"></p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><p>实践代码的过程中需要注意，遍历到的节点value值可能已经是负，已经被标记，但是还是需要根据其绝对值找到该value需要标记的index位置，这也是为什么将其标记为反数而不是其他任意负数的原因。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="comment">//数组index对应的数值为value，将index=value的位置标记为-value，表示出现过，并且value取正可以持续标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//已经被标记</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[-nums[i]-<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    nums[-nums[i]-<span class="number">1</span>]=-nums[-nums[i]-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//未被标记</span></span><br><span class="line">                <span class="keyword">if</span>(nums[nums[i]-<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    nums[nums[i] - <span class="number">1</span>] = -nums[nums[i] - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历出未被标记的index，index+1即为未出现过的数值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                arrayList.add(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arrayList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实际上第一个循环的处理可以更加简单清晰，用下面的循环体内容替换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> value=Math.abs(nums[i])-<span class="number">1</span>;<span class="comment">//直接取当前index位置value的绝对值</span></span><br><span class="line">    <span class="keyword">if</span>(nums[value] &gt;<span class="number">0</span>)&#123;</span><br><span class="line">        nums[value]=-nums[value];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题比较难想到这个思路，并且在编码过程中思考也需要更加缜密，想清楚了再进行书写。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述-难度简单-448&quot;&gt;&lt;a href=&quot;#问题描述-难度简单-448&quot; class=&quot;headerlink&quot; title=&quot;问题描述 (难度简单-448)&quot;&gt;&lt;/a&gt;问题描述 (难度简单-448)&lt;/h3&gt;&lt;p&gt;Given an array of inte
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Pow(x, n)</title>
    <link href="http://jianghao.wang/2019/Pow(x,%20n)/"/>
    <id>http://jianghao.wang/2019/Pow(x, n)/</id>
    <published>2019-05-16T11:44:47.616Z</published>
    <updated>2019-05-16T15:00:35.892Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度中等）"><a href="#问题描述（难度中等）" class="headerlink" title="问题描述（难度中等）"></a>问题描述（难度中等）</h3><p>Implement <a href="http://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(<em>x</em>, <em>n</em>)</a>, which calculates <em>x</em> raised to the power <em>n</em> (xn).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.00000, 10</span><br><span class="line">Output: 1024.00000</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.10000, 3</span><br><span class="line">Output: 9.26100</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.00000, -2</span><br><span class="line">Output: 0.25000</span><br><span class="line">Explanation: 2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>-100.0 &lt; <em>x</em> &lt; 100.0</li><li><em>n</em> is a 32-bit signed integer, within the range [−231, 231 − 1]</li></ul><h3 id="递归经典范式"><a href="#递归经典范式" class="headerlink" title="递归经典范式"></a>递归经典范式</h3><p>递归的写法主要包括四个部分，第一个<strong>recursion terminater终止条件</strong>，第二个<strong>process logic in current level当前level需要执行的逻辑</strong>，第三个<strong>drill down进入到下一层</strong>，第四个<strong>reverse the current level status if needed内层结束后继续执行。</strong></p><p><img src="https://arthornye.github.io/images/recursion.jpg" alt="cmd-markdown-logo"></p><h3 id="方法一：递归方式一"><a href="#方法一：递归方式一" class="headerlink" title="方法一：递归方式一"></a>方法一：递归方式一</h3><p>通过递归的方式将n次方的问题拆分成n/2的子问题，时间复杂度减少到logn。<strong>x的n次转换为x^2的n/2次子问题。</strong></p><h3 id="方法一代码"><a href="#方法一代码" class="headerlink" title="方法一代码"></a>方法一代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//偶数直接转化为子问题</span></span><br><span class="line">            <span class="keyword">if</span>((n &amp; <span class="number">1</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> myPow(x*x,n/<span class="number">2</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> n&lt;<span class="number">0</span>?<span class="number">1</span>/x*myPow(<span class="number">1</span>/x*<span class="number">1</span>/x,n/<span class="number">2</span>):x*myPow(x*x,n/<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：递归方式二"><a href="#方法二：递归方式二" class="headerlink" title="方法二：递归方式二"></a>方法二：递归方式二</h3><p>利用递归范式的第四步，<strong>子问题返回的结果乘以自身。</strong></p><h3 id="方法二代码"><a href="#方法二代码" class="headerlink" title="方法二代码"></a>方法二代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow1</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> temp=myPow(x,n/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//偶数直接转化为子问题</span></span><br><span class="line">            <span class="keyword">if</span>((n &amp; <span class="number">1</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> temp*temp;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> n&lt;<span class="number">0</span>?<span class="number">1</span>/x*temp*temp:x*temp*temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="方法三：非递归方式"><a href="#方法三：非递归方式" class="headerlink" title="方法三：非递归方式"></a>方法三：非递归方式</h3><p>不采用递归的方式。</p><h3 id="方法三代码"><a href="#方法三代码" class="headerlink" title="方法三代码"></a>方法三代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        n = -n;</span><br><span class="line">        x = <span class="number">1</span>/x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans *= x;</span><br><span class="line">        x *= x;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题主要是理解递归的范式，递归虽然简洁还是需要灵活运用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度中等）&quot;&gt;&lt;a href=&quot;#问题描述（难度中等）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度中等）&quot;&gt;&lt;/a&gt;问题描述（难度中等）&lt;/h3&gt;&lt;p&gt;Implement &lt;a href=&quot;http://www.cplusplu
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Median of Two Sorted Arrays</title>
    <link href="http://jianghao.wang/2019/Median%20of%20Two%20Sorted%20Arrays/"/>
    <id>http://jianghao.wang/2019/Median of Two Sorted Arrays/</id>
    <published>2019-05-14T03:22:24.489Z</published>
    <updated>2019-05-14T08:48:37.018Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度困难）"><a href="#问题描述（难度困难）" class="headerlink" title="问题描述（难度困难）"></a>问题描述（难度困难）</h3><p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p>You may assume <strong>nums1</strong> and <strong>nums2</strong> cannot be both empty.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">The median is 2.0</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">The median is (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure><h3 id="方法一：归并排序思想"><a href="#方法一：归并排序思想" class="headerlink" title="方法一：归并排序思想"></a>方法一：归并排序思想</h3><p>归并排序在merge之后会将各个有序的子数组合并为一个数组，这里采用归并排序sort的思想，时间和空间复杂度为<strong>O(m+n)</strong>。<strong>用两个index去遍历，每次将最小的整合到一个新的list中，直到整个都遍历完成，需要注意当一个列表遍历完成之后的极端情况。</strong>整合的流程如下：</p><p><img src="https://arthornye.github.io/images/sortIndex.jpg" alt="cmd-markdown-logo"></p><h3 id="方法一代码"><a href="#方法一代码" class="headerlink" title="方法一代码"></a>方法一代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> length = nums1.length + nums2.length;</span><br><span class="line">       ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">       <span class="keyword">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (index1 &gt; nums1.length - <span class="number">1</span>) &#123;</span><br><span class="line">               arrayList.add(nums2[index2]);</span><br><span class="line">               index2++;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index2 &gt; nums2.length - <span class="number">1</span>) &#123;</span><br><span class="line">               arrayList.add(nums1[index1]);</span><br><span class="line">               index1++;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (nums1[index1] &lt; nums2[index2]) &#123;</span><br><span class="line">                   arrayList.add(nums1[index1]);</span><br><span class="line">                   index1++;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   arrayList.add(nums2[index2]);</span><br><span class="line">                   index2++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> mid = length / <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">if</span> ((length &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> (arrayList.get(mid) + arrayList.get(mid - <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> arrayList.get(mid);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：固定和双指针遍历"><a href="#方法二：固定和双指针遍历" class="headerlink" title="方法二：固定和双指针遍历"></a>方法二：固定和双指针遍历</h3><p>方法一中我们其实是把问题转换为了归并排序归并问题，但是实际上并不需要扫描全部的记录，并且也不需要存储整合之后排序的所有的结果，时间复杂度为<strong>O(min(m,n)/2，leetcode上大部分说是O(log(min(m,n)))，可能理解还不够到位，先记录下吧</strong>，空间复杂度为<strong>1</strong>。这里介绍另一种方式：</p><p><img src="https://arthornye.github.io/images/median.jpg" alt="cmd-markdown-logo"></p><p>大概的思路就是两个数组都维持一个索引位置，两个索引位置需要满足<strong>index_first+index_second=(length1+length2-1)/2-1，只有当first_left小于second_right并且second_left小于first_right的时候表示找到了中位数的位置，不然改变其中一个的位置。</strong>感觉这个公式还是蛮难理解的，可以理解为在两个数组之间画一条分割线，分割在中间就需要满足<strong>index=(length-1)/2</strong>。</p><p>这里还需要注意一种情况就是当<strong>index_first==-1和index_second==-1时first_left和second_left用Integer.MIN_VALUE代替，index_first == length1-1和index_second=length2-1时first_right和second_right用Integer.MAX_VALUE代替。</strong></p><h3 id="方法二代码"><a href="#方法二代码" class="headerlink" title="方法二代码"></a>方法二代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.记录当前划分位置的前后节点</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; tempArray=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length1 = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> length2 = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> length = length1 + length2;</span><br><span class="line">        <span class="keyword">if</span> (length1 == <span class="number">0</span> &amp;&amp; length2 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (nums2[length2 / <span class="number">2</span>] + nums2[(length2 - <span class="number">1</span>) / <span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (length2 == <span class="number">0</span> &amp;&amp; length1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (nums1[length1 / <span class="number">2</span>] + nums1[(length1 - <span class="number">1</span>) / <span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//2.若数组的长度为length1，那么分割数组的index位置为(length-1)/2,那么这里整个数组的分割位置为(length-1)/2,减去numsIndex1，但是因为数组是分成了两个，这里需要额外减去1</span></span><br><span class="line">            <span class="keyword">int</span> numIndex1 = (length1 - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> numIndex2 = (length - <span class="number">1</span>) / <span class="number">2</span> - numIndex1 - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//3.边界值，最左边==-1的边界值left设置为Integer.MIN_VALUE，最右边的边界值right==length-1设置为Integer.MAX_VALUE</span></span><br><span class="line">                setLeftAndRight(numIndex1,nums1);</span><br><span class="line">                setLeftAndRight(numIndex2,nums2);</span><br><span class="line">                <span class="comment">//4.比较更加直观</span></span><br><span class="line">                Integer nums1Left=tempArray.get(<span class="number">0</span>),nums1Right=tempArray.get(<span class="number">1</span>),nums2Left=tempArray.get(<span class="number">2</span>),nums2Right=tempArray.get(<span class="number">3</span>);</span><br><span class="line">                <span class="comment">//5.满足截取的位置条件，数组一分割位置左边的元素小于数组二分割位置右边的元素，数组二分割位置左边的元素小于数组一分割位置右边的元素。</span></span><br><span class="line">                <span class="keyword">if</span> (nums1Left &lt;= nums2Right &amp;&amp; nums2Left &lt;= nums1Right) &#123;</span><br><span class="line">                    <span class="comment">//6.判断整个length的长度是否为偶数</span></span><br><span class="line">                    <span class="keyword">int</span> temp = length &amp; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (temp == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> findMax(nums1Left, nums2Left) / <span class="number">1.0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> (findMax(nums1Left, nums2Left) + findMin(nums1Right, nums2Right)) / <span class="number">2.0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1Left &gt; nums2Right) &#123;</span><br><span class="line">                    numIndex1--;</span><br><span class="line">                    numIndex2++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    numIndex1++;</span><br><span class="line">                    numIndex2--;</span><br><span class="line">                &#125;</span><br><span class="line">                tempArray.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setLeftAndRight</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left,right;</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            left = Integer.MIN_VALUE;</span><br><span class="line">            right = nums[index + <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == nums.length- <span class="number">1</span>) &#123;</span><br><span class="line">            left = nums[index];</span><br><span class="line">            right = Integer.MAX_VALUE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = nums[index];</span><br><span class="line">            right = nums[index + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        tempArray.add(left);</span><br><span class="line">        tempArray.add(right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMax</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? b : a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>两种方式感觉还是第一种理解和书写上更加简单明了，第二种方式在理解和书写上相对困难，而且实际表现出的性能优化也没有特别夸张，可能在非常大的数据量上会表现更加好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度困难）&quot;&gt;&lt;a href=&quot;#问题描述（难度困难）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度困难）&quot;&gt;&lt;/a&gt;问题描述（难度困难）&lt;/h3&gt;&lt;p&gt;There are two sorted arrays &lt;strong&gt;nu
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linked List Cycle II</title>
    <link href="http://jianghao.wang/2019/Linked%20List%20Cycle%20II/"/>
    <id>http://jianghao.wang/2019/Linked List Cycle II/</id>
    <published>2019-05-13T03:17:13.356Z</published>
    <updated>2019-05-13T06:14:45.502Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度中等）"><a href="#问题描述（难度中等）" class="headerlink" title="问题描述（难度中等）"></a>问题描述（难度中等）</h3><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p><p>To represent a cycle in the given linked list, we use an integer <code>pos</code>which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p><p><strong>Note:</strong> Do not modify the linked list.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [3,2,0,-4], pos = 1</span><br><span class="line">Output: tail connects to node index 1</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2], pos = 0</span><br><span class="line">Output: tail connects to node index 0</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the first node.</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1], pos = -1</span><br><span class="line">Output: no cycle</span><br><span class="line">Explanation: There is no cycle in the linked list.</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><h3 id="方法一：用HashSet检查重复"><a href="#方法一：用HashSet检查重复" class="headerlink" title="方法一：用HashSet检查重复"></a>方法一：用HashSet检查重复</h3><p>这里将每个节点看作独立的对象，<strong><em>散列到HashSet中</em></strong>，如果出现了重复节点，就直接返回当前的节点，那么该节点就是环的起点。这种方法比较直观，当然需要消耗n的空间复杂度。穿插记录下这里的每个节点都会根据hashCode去散列到数组不同的位置，我们没有重写hashCode和equals方法，那么默认每个object都有不同的hashCode，并且eqauls方法也只返回引用的比较结果。<strong>Effective Java中对对象重写equal方法有个规范，需要同时重写hashCode方法，主要为了避免用当前类对象作为Hash这种数据结构的key的时候会导致不一致，equals相等但是hashCode不想等，导致逻辑上认为相等的一个对象被散列到两个链表上。</strong></p><h3 id="方法一代码"><a href="#方法一代码" class="headerlink" title="方法一代码"></a>方法一代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> HashSet&lt;ListNode&gt; hashSet=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (head!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashSet.contains(head))&#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                hashSet.add(head);</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看起来逻辑是非常清晰的，实现非常的简单。</p><h3 id="方法二：快慢指针遍历"><a href="#方法二：快慢指针遍历" class="headerlink" title="方法二：快慢指针遍历"></a>方法二：快慢指针遍历</h3><p>方法一虽然实现比较简单但是需要n的空间复杂度，在判断链表是否有环的练习题我们同样可以用快慢指针，返回相遇点，但是这里<strong>需要寻找环的起点</strong>，这个自己没有想到好的solution，从disscuss中发现了一些宝藏男孩。这里我们简单推理重现一下。</p><p><img src="https://arthornye.github.io/images/circle.jpg" alt="cmd-markdown-logo"></p><p>这里假设我们慢指针以一步的步长往前走，快指针两步走，最终相遇在<strong>Meet Pointer</strong>的位置，慢指针走了<strong>S</strong>的距离，快指针走了<strong>2S</strong>距离，根据图中可以推导出<strong>A=C+(N-1)*loop</strong>，也就是说设置两个起点一个从链表头部开始，一个从<strong>Meet Pointer</strong>开始，分别往下遍历，最终会在<strong>Circle Start Pointer</strong>相遇。整个算法的过程是第一次循环找到<strong>Meet Pointer</strong>,第二次循环找到<strong>Circle Start Pointer</strong>。</p><h3 id="方法二代码"><a href="#方法二代码" class="headerlink" title="方法二代码"></a>方法二代码</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycleUsingPointer</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head ==<span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next ==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pointer1=head.next;</span><br><span class="line">        ListNode pointer2=head.next.next;</span><br><span class="line">        <span class="comment">//step1:找出环的位置</span></span><br><span class="line">        <span class="keyword">while</span> (pointer1!=pointer2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pointer2 ==<span class="keyword">null</span> || pointer2.next ==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pointer2 =pointer2.next.next;</span><br><span class="line">            pointer1 = pointer1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//step2:重新开始一遍扫描环</span></span><br><span class="line">        <span class="keyword">while</span>(head != pointer1)&#123;</span><br><span class="line">            head=head.next;</span><br><span class="line">            pointer1=pointer1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>第一种方式较为直观，实现上较为简单，但是需要占用n的空间复杂度。第二种时间空间效率更高，但是实现上一开始比较难想到。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度中等）&quot;&gt;&lt;a href=&quot;#问题描述（难度中等）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度中等）&quot;&gt;&lt;/a&gt;问题描述（难度中等）&lt;/h3&gt;&lt;p&gt;Given a linked list, return the node w
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Kth Largest Element in a Stream</title>
    <link href="http://jianghao.wang/2019/Kth%20Largest%20Element%20in%20a%20Stream/"/>
    <id>http://jianghao.wang/2019/Kth Largest Element in a Stream/</id>
    <published>2019-05-10T01:50:51.499Z</published>
    <updated>2019-05-10T02:05:15.124Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度简单）"><a href="#问题描述（难度简单）" class="headerlink" title="问题描述（难度简单）"></a>问题描述（难度简单）</h3><p>Design a class to find the <strong>k</strong>th largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p>Your <code>KthLargest</code> class will have a constructor which accepts an integer <code>k</code> and an integer array <code>nums</code>, which contains initial elements from the stream. For each call to the method <code>KthLargest.add</code>, return the element representing the kth largest element in the stream.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int k = 3;</span><br><span class="line">int[] arr = [4,5,8,2];</span><br><span class="line">KthLargest kthLargest = new KthLargest(3, arr);</span><br><span class="line">kthLargest.add(3);   // returns 4</span><br><span class="line">kthLargest.add(5);   // returns 5</span><br><span class="line">kthLargest.add(10);  // returns 5</span><br><span class="line">kthLargest.add(9);   // returns 8</span><br><span class="line">kthLargest.add(4);   // returns 8</span><br></pre></td></tr></table></figure><p><strong>Note:</strong><br>You may assume that <code>nums</code>‘ length ≥ <code>k-1</code> and <code>k</code> ≥ 1.</p><h3 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h3><p>维护一个k大小的数组，排序时间复杂度klogk，每次进入新元素判断当前k个有序数组中最小值，小于最小值不进入，大于最小值进入。<strong>整体时间复杂度nklogk。</strong></p><h3 id="方法一代码"><a href="#方法一代码" class="headerlink" title="方法一代码"></a>方法一代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> FindKLargestNumber;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KthLargestTwo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KthLargestTwo</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        <span class="keyword">int</span> numsLength = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsLength; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; k-<span class="number">1</span>) &#123;</span><br><span class="line">                Collections.sort(array);</span><br><span class="line">                add(nums[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                array.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.size() &lt; k) &#123;</span><br><span class="line">            array.add(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; array.get(<span class="number">0</span>)) &#123;</span><br><span class="line">            array.set(<span class="number">0</span>, val);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(array);</span><br><span class="line">        <span class="keyword">return</span> array.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：优先队列"><a href="#方法二：优先队列" class="headerlink" title="方法二：优先队列"></a>方法二：优先队列</h3><p>单纯排序的算法klogk的时间复杂度还有优化的空间，如果是最小堆的话搜素插入的时间只需要logk的复杂度，这里我们增加一个优先级队列的版本。<strong>优先级队列默认是一个堆的数据结构，堆这种数据结构是一个完全二叉树，满足每个子节点都要比父节点要小（小顶堆）或者大（大顶堆）。所以堆顶永远是k个数当中最小的，只需要比较堆顶的元素即可。同样的搜索插入的复杂度是logk。</strong></p><h3 id="方法二代码"><a href="#方法二代码" class="headerlink" title="方法二代码"></a>方法二代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> FindKLargestNumber;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Method 1:采用优先级队列（最小堆）的方式实现，nlogk时间复杂度，k的空间复杂度</span></span><br><span class="line"><span class="comment"> * Method 2:采用排序的方式，nklogk时间复杂度，k的空间复杂度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;Integer&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建一个有k个元素的堆</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KthLargest</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        Arrays.stream(nums).forEach(integer -&gt;</span><br><span class="line">                add(integer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果优先级队列中数量小于k，直接往最小堆中追加</span></span><br><span class="line">        <span class="keyword">if</span> (priorityQueue.size() &lt; k) &#123;</span><br><span class="line">            priorityQueue.offer(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (priorityQueue.peek() &lt; val) &#123;<span class="comment">//如果当前追加元素大于堆顶的元素，将堆顶的元素poll滚出，然后将当前的值offer进入堆</span></span><br><span class="line">            priorityQueue.poll();</span><br><span class="line">            priorityQueue.offer(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> priorityQueue.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        KthLargest kthLargest = <span class="keyword">new</span> KthLargest(<span class="number">3</span>, arr);</span><br><span class="line">        System.out.println(kthLargest.add(<span class="number">3</span>));   <span class="comment">// returns 4</span></span><br><span class="line">        System.out.println(kthLargest.add(<span class="number">5</span>));   <span class="comment">// returns 5</span></span><br><span class="line">        System.out.println(kthLargest.add(<span class="number">10</span>));  <span class="comment">// returns 5</span></span><br><span class="line">        System.out.println(kthLargest.add(<span class="number">9</span>));   <span class="comment">// returns 8</span></span><br><span class="line">        System.out.println(kthLargest.add(<span class="number">4</span>));   <span class="comment">// returns 8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本质上两种方式都是维护一个k大小的数据结构，优先级队列在搜索插入的时间复杂度上具备优势，只需要logk的时间复杂度，优先级队列本质上是一个小顶堆。我们可以利用优先级队列去优化方法一。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度简单）&quot;&gt;&lt;a href=&quot;#问题描述（难度简单）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度简单）&quot;&gt;&lt;/a&gt;问题描述（难度简单）&lt;/h3&gt;&lt;p&gt;Design a class to find the &lt;strong&gt;k&lt;/
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Reverse Linked List</title>
    <link href="http://jianghao.wang/2019/Reverse%20Linked%20List/"/>
    <id>http://jianghao.wang/2019/Reverse Linked List/</id>
    <published>2019-05-08T07:18:20.669Z</published>
    <updated>2019-05-16T14:42:28.027Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述（难度简单）"><a href="#题目描述（难度简单）" class="headerlink" title="题目描述（难度简单）"></a>题目描述（难度简单）</h3><p>Reverse a singly linked list.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong></p><p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p><h3 id="方法一：一遍遍历"><a href="#方法一：一遍遍历" class="headerlink" title="方法一：一遍遍历"></a>方法一：一遍遍历</h3><p>一遍遍历，定义一个初始值为null的pre节点，一个current为head的当前节点，nextTemp为current的下一个节点。</p><p><strong>首先定义好pre和current两个节点，中间虚线表示原来链表存在的指向，红色表示当前pre节点位置，绿色表示已经被倒转的节点，蓝色为待倒转节点：</strong></p><p><img src="https://arthornye.github.io/images/reverseone.jpg" alt="cmd-markdown-logo"></p><p><img src="https://arthornye.github.io/images/reversetwo.jpg" alt="cmd-markdown-logo"></p><p><img src="https://arthornye.github.io/images/reversethree.jpg" alt="cmd-markdown-logo"></p><p><strong>最后只需要pre返回也就完成了一次遍历。返回的链表也就是倒转之后的链表。</strong></p><h3 id="方法一代码："><a href="#方法一代码：" class="headerlink" title="方法一代码："></a>方法一代码：</h3><p>在自己写的过程中发现代码并没有这么简洁，算法设计上没有这么完善，针对链表的题目还是需要画出来指向关系，写出优雅。这里循环结束的条件我们可以看到是current=null，然后直接返回pre。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseListOneScanMoreClear</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode nextTemp = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h3><p>递归的版本理解上较为复杂，因为如果递归到尾节点的时候，直接将尾节点返回作为倒转链表的头节点返回，这样的逻辑会有问题，我们总是需要在一次递归中寻找倒转链表的尾节点。<strong>当然我们可以通过记录链表最尾巴的节点作为头节点，然后每次递归返回当前倒转链表的尾节点，缺点就是丧失了递归的美感。</strong>这样的方式写出来的版本会是下面这样的，也比较好理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录倒转链表首节点</span></span><br><span class="line"><span class="keyword">private</span> ListNode newHead;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* method 1 : 利用递归进行反转</span></span><br><span class="line"><span class="comment">* 递归返回的节点每次都是尾节点可以直接追加</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    reverseToTail(head);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.newHead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseToTail</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span> || node.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.newHead=node;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        ListNode tempListNode=reverseToTail(node.next);</span><br><span class="line">        tempListNode.next=node;</span><br><span class="line">        node.next =<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们想能不能每次都返回倒转链表的头部然后不需要遍历到尾节点还能进行追加？我们假设在第三次递归返回的程序体中，后两个节点已经具备了倒转结构并且返回了头节点，也就是<strong>n1-&gt;n2-&gt;n3…n(k)-&gt;n(k+1)&lt;-n(k+2)需要把n(k)节点在第三次递归中追加到倒转链表中。</strong></p><p><img src="https://arthornye.github.io/images/recursive.jpg" alt="cmd-markdown-logo"></p><h3 id="方法二代码："><a href="#方法二代码：" class="headerlink" title="方法二代码："></a>方法二代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.recursion terminater</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//2.drill down</span></span><br><span class="line">    ListNode p = reverseList(head.next);</span><br><span class="line">    <span class="comment">//3.reverse the current level status if needed</span></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归确实还是简洁，根据递归的范式写出来即可。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>链表倒转，主要可以通过一遍遍历和递归的方式来进行实现，实现的过程主要需要关注指针的指向，在指针的操作过程中写出来演示效果会更好，搞清楚指向关系很重要，否则很容易造成逻辑错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述（难度简单）&quot;&gt;&lt;a href=&quot;#题目描述（难度简单）&quot; class=&quot;headerlink&quot; title=&quot;题目描述（难度简单）&quot;&gt;&lt;/a&gt;题目描述（难度简单）&lt;/h3&gt;&lt;p&gt;Reverse a singly linked list.&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Swap Nodes In Pairs</title>
    <link href="http://jianghao.wang/2019/Swap%20Nodes%20In%20Pairs/"/>
    <id>http://jianghao.wang/2019/Swap Nodes In Pairs/</id>
    <published>2019-05-08T01:27:49.890Z</published>
    <updated>2019-05-08T10:23:08.087Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述（难度中等）"><a href="#题目描述（难度中等）" class="headerlink" title="题目描述（难度中等）"></a>题目描述（难度中等）</h3><p>Given a linked list, swap every two adjacent nodes and return its head.</p><p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure><h3 id="方法一：遍历一遍链表"><a href="#方法一：遍历一遍链表" class="headerlink" title="方法一：遍历一遍链表"></a>方法一：遍历一遍链表</h3><p>链表改变顺序的题目，通用的方法论是先找出一次需要改变指向的节点数量。交换相邻节点需要改变<strong>current（相邻节点前节点的前节点），first（相邻节点前节点），second（相邻节点后节点）。</strong>current在链表头部自定义一个初始值为0的节点。</p><p><img src="https://arthornye.github.io/images/swappingone.jpg" alt="cmd-markdown-logo"></p><p><img src="https://arthornye.github.io/images/swappingoneone.jpg" alt="cmd-markdown-logo"></p><p><strong>上图中展示了链表指向的过程，三个节点都需要进行重定向，一次循环后的结果：</strong></p><p><img src="https://arthornye.github.io/images/swappingtwo.jpg" alt="cmd-markdown-logo"></p><p><strong>第二次循环继续将current往后平移两个单位，继续执行循环赋值：</strong></p><p><img src="https://arthornye.github.io/images/swappingthree.jpg" alt="cmd-markdown-logo"></p><p><strong>得到循环赋值结果：</strong></p><p><img src="https://arthornye.github.io/images/swappingtwicefinished.jpg" alt="cmd-markdown-logo"></p><h3 id="方法一代码"><a href="#方法一代码" class="headerlink" title="方法一代码"></a>方法一代码</h3><p>分析了上图之后，代码实现较为简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairsMoreClear</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode current = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        current.next = head;</span><br><span class="line">        ListNode newHead = current;</span><br><span class="line">        <span class="keyword">while</span> (current.next !=<span class="keyword">null</span> &amp;&amp; current.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode first = current.next;</span><br><span class="line">            ListNode second = current.next.next;</span><br><span class="line"></span><br><span class="line">            current.next = second;</span><br><span class="line">            first.next= second.next;</span><br><span class="line">            second.next=first;</span><br><span class="line"></span><br><span class="line">            current = first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述（难度中等）&quot;&gt;&lt;a href=&quot;#题目描述（难度中等）&quot; class=&quot;headerlink&quot; title=&quot;题目描述（难度中等）&quot;&gt;&lt;/a&gt;题目描述（难度中等）&lt;/h3&gt;&lt;p&gt;Given a linked list, swap every two ad
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MapStruct使用</title>
    <link href="http://jianghao.wang/2019/MapStruct%E4%BD%BF%E7%94%A8/"/>
    <id>http://jianghao.wang/2019/MapStruct使用/</id>
    <published>2019-04-19T06:37:19.028Z</published>
    <updated>2019-04-19T10:47:43.878Z</updated>
    
    <content type="html"><![CDATA[<p>我们在实际开发过程中会出现很多bean之间的拷贝动作，这样的动作需要不停的去进行set操作。容易造成代码的耦合和维护困难。通过MapStruct我们只需要定义一个接口，这个工具包会帮我们自动生成一个实现类，并且这个类是不可编辑的，代码自动生成帮我们省去了开发维护成本同时做了一定的解耦。</p><h3 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h3><p>使用MapStruct我们需要通过maven导入相关的依赖：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mapstruct-jdk8&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.0.Beta2&lt;/version&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>同时我们需要添加<strong><em>maven-compiler-plugin</em></strong>，其中<strong><em>mapstruct-processor</em></strong>用于构建mapper实现类的生成器。</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.1&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">        &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">        &lt;annotationProcessorPaths&gt;</span><br><span class="line">            &lt;path&gt;</span><br><span class="line">                &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;1.3.0.Beta2&lt;/version&gt;</span><br><span class="line">            &lt;/path&gt;</span><br><span class="line">        &lt;/annotationProcessorPaths&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><h3 id="基本的Mapping用法"><a href="#基本的Mapping用法" class="headerlink" title="基本的Mapping用法"></a>基本的Mapping用法</h3><p>定义一个Java的POJO类和Mapper Interface:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDestination</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SimpleSourceDestinationMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">SimpleDestination <span class="title">sourceToDestination</span><span class="params">(SimpleSource source)</span></span>;</span><br><span class="line">    <span class="function">SimpleSource <span class="title">destinationToSource</span><span class="params">(SimpleDestination destination)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到我们这里并没有去实现这个接口，但是<strong>MapStruct帮我们生成了一个实现类</strong>。我们可以通过调用<strong><em>mvn compile</em></strong>或者通过<strong><em>mvn clean install</em></strong>调用MapStruct，它会帮我们生成一个Mapper的实现类在<strong><em>/target/generated-sources/annotations/</em></strong>目录下。这里贴上一段，<strong>注意这个类是不可编辑的，如果编辑这个类，再重新执行编译之后也会被替换掉</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSourceDestinationMapperImpl</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">SimpleSourceDestinationMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleDestination <span class="title">sourceToDestination</span><span class="params">(SimpleSource source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( source == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SimpleDestination simpleDestination = <span class="keyword">new</span> SimpleDestination();</span><br><span class="line">        simpleDestination.setName( source.getName() );</span><br><span class="line">        simpleDestination.setDescription( source.getDescription() );</span><br><span class="line">        <span class="keyword">return</span> simpleDestination;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleSource <span class="title">destinationToSource</span><span class="params">(SimpleDestination destination)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( destination == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SimpleSource simpleSource = <span class="keyword">new</span> SimpleSource();</span><br><span class="line">        simpleSource.setName( destination.getName() );</span><br><span class="line">        simpleSource.setDescription( destination.getDescription() );</span><br><span class="line">        <span class="keyword">return</span> simpleSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行一个测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSourceDestinationMapperTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SimpleSourceDestinationMapper mapper</span><br><span class="line">      = Mappers.getMapper(SimpleSourceDestinationMapper.class);</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenSourceToDestination_whenMaps_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleSource simpleSource = <span class="keyword">new</span> SimpleSource();</span><br><span class="line">        simpleSource.setName(<span class="string">"SourceName"</span>);</span><br><span class="line">        simpleSource.setDescription(<span class="string">"SourceDescription"</span>);</span><br><span class="line">        SimpleDestination destination = mapper.sourceToDestination(simpleSource);</span><br><span class="line">  </span><br><span class="line">        assertEquals(simpleSource.getName(), destination.getName());</span><br><span class="line">        assertEquals(simpleSource.getDescription(), </span><br><span class="line">          destination.getDescription());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenDestinationToSource_whenMaps_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleDestination destination = <span class="keyword">new</span> SimpleDestination();</span><br><span class="line">        destination.setName(<span class="string">"DestinationName"</span>);</span><br><span class="line">        destination.setDescription(<span class="string">"DestinationDescription"</span>);</span><br><span class="line">        SimpleSource source = mapper.destinationToSource(destination);</span><br><span class="line">        assertEquals(destination.getName(), source.getName());</span><br><span class="line">        assertEquals(destination.getDescription(),</span><br><span class="line">          source.getDescription());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过依赖注入的方式获取Mapper服务"><a href="#通过依赖注入的方式获取Mapper服务" class="headerlink" title="通过依赖注入的方式获取Mapper服务"></a>通过依赖注入的方式获取Mapper服务</h3><p>我们一般情况下可以通过<strong><em>Mappers.getMapper(YourClass.class)</em></strong>的方式获取到一个Mapper实例，然后调用到具体的mapper方法，我们也可以注入的方式获取到我们的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span>(componentModel = <span class="string">"spring"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SimpleSourceDestinationMapper</span></span></span><br></pre></td></tr></table></figure><p>在interface上加了这个属性之后，我们可以通过<strong><em>@Autowire</em></strong>的方式在任何地方引用这个实例。</p><h3 id="映射不同的字段名"><a href="#映射不同的字段名" class="headerlink" title="映射不同的字段名"></a>映射不同的字段名</h3><p>针对下面的POJOs我们可以定义另一个Mapper:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDTO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> employeeId;</span><br><span class="line">    <span class="keyword">private</span> String employeeName;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Mappings</span>(&#123;</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"employeeId"</span>, source=<span class="string">"entity.id"</span>),</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"employeeName"</span>, source=<span class="string">"entity.name"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">EmployeeDTO <span class="title">employeeToEmployeeDTO</span><span class="params">(Employee entity)</span></span>;</span><br><span class="line">    <span class="meta">@Mappings</span>(&#123;</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"id"</span>, source=<span class="string">"dto.employeeId"</span>),</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"name"</span>, source=<span class="string">"dto.employeeName"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">Employee <span class="title">employeeDTOtoEmployee</span><span class="params">(EmployeeDTO dto)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="映射对象字段"><a href="#映射对象字段" class="headerlink" title="映射对象字段"></a>映射对象字段</h3><p>如果这边两个类之间的映射中还有嵌套的对象，我们在同一个Mapper的接口中定义这两个嵌套对象的转换规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDTO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> employeeId;</span><br><span class="line">    <span class="keyword">private</span> String employeeName;</span><br><span class="line">    <span class="keyword">private</span> DivisionDTO division;</span><br><span class="line">    <span class="comment">// getters and setters omitted</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Division division;</span><br><span class="line">    <span class="comment">// getters and setters omitted</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Division</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// default constructor, getters and setters omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改之后的Mapper接口为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DivisionDTO <span class="title">divisionToDivisionDTO</span><span class="params">(Division entity)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">Division <span class="title">divisionDTOtoDivision</span><span class="params">(DivisionDTO dto)</span></span>;</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenEmpDTONestedMappingToEmp_whenMaps_thenCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EmployeeDTO dto = <span class="keyword">new</span> EmployeeDTO();</span><br><span class="line">    dto.setDivision(<span class="keyword">new</span> DivisionDTO(<span class="number">1</span>, <span class="string">"Division1"</span>));</span><br><span class="line">    Employee entity = mapper.employeeDTOtoEmployee(dto);</span><br><span class="line">    assertEquals(dto.getDivision().getId(), </span><br><span class="line">      entity.getDivision().getId());</span><br><span class="line">    assertEquals(dto.getDivision().getName(), </span><br><span class="line">      entity.getDivision().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字段类型转换"><a href="#字段类型转换" class="headerlink" title="字段类型转换"></a>字段类型转换</h3><p>如果我们需要将一个String类型映射为Date类型的字段，定义一个dateFormat，同时还提供了expression等属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mappings</span>(&#123;</span><br><span class="line">  <span class="meta">@Mapping</span>(target=<span class="string">"employeeId"</span>, source = <span class="string">"entity.id"</span>),</span><br><span class="line">  <span class="meta">@Mapping</span>(target=<span class="string">"employeeName"</span>, source = <span class="string">"entity.name"</span>),</span><br><span class="line">  <span class="meta">@Mapping</span>(target=<span class="string">"employeeStartDt"</span>, source = <span class="string">"entity.startDt"</span>,</span><br><span class="line">           dateFormat = <span class="string">"dd-MM-yyyy HH:mm:ss"</span>)&#125;)</span><br><span class="line"><span class="function">EmployeeDTO <span class="title">employeeToEmployeeDTO</span><span class="params">(Employee entity)</span></span>;</span><br><span class="line"><span class="meta">@Mappings</span>(&#123;</span><br><span class="line">  <span class="meta">@Mapping</span>(target=<span class="string">"id"</span>, source=<span class="string">"dto.employeeId"</span>),</span><br><span class="line">  <span class="meta">@Mapping</span>(target=<span class="string">"name"</span>, source=<span class="string">"dto.employeeName"</span>),</span><br><span class="line">  <span class="meta">@Mapping</span>(target=<span class="string">"startDt"</span>, source=<span class="string">"dto.employeeStartDt"</span>,</span><br><span class="line">           dateFormat=<span class="string">"dd-MM-yyyy HH:mm:ss"</span>)&#125;)</span><br><span class="line"><span class="function">Employee <span class="title">employeeDTOtoEmployee</span><span class="params">(EmployeeDTO dto)</span></span>;</span><br></pre></td></tr></table></figure><p><strong><em>@Mappping的注解我们还可以定义一些属性</em></strong>，defaultExpression和expression可以定义一些简单的表达式，直接传递给实现方法，<strong>但是不可能引用一些工具类，只要import的方法都没办法自动导入，这个比较鸡肋</strong>。这里贴一些简单的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个会将java.util.UUID.randomUUID().toString()这个方法直接引用在目标字段上。</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonMapper</span> </span>&#123;</span><br><span class="line">    PersonMapper INSTANCE = Mappers.getMapper(PersonMapper.class);</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Mapping</span>(target = <span class="string">"id"</span>, source = <span class="string">"person.id"</span>, </span><br><span class="line">      defaultExpression = <span class="string">"java(java.util.UUID.randomUUID().toString())"</span>)</span><br><span class="line">    <span class="function">PersonDTO <span class="title">personToPersonDTO</span><span class="params">(Person person)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时我们可能也可以这样用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span>(componentModel = <span class="string">"spring"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeMapper</span> </span>&#123;</span><br><span class="line">    EmployeeMapper INSTANCE= Mappers.getMapper(EmployeeMapper.class);</span><br><span class="line">    <span class="meta">@Mappings</span>(&#123;</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"employeeId"</span>, source=<span class="string">"entity.id"</span>),</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"employeeName"</span>, source=<span class="string">"entity.name"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(target = <span class="string">"testString"</span>,expression = <span class="string">"java((priceFen/100) + \"元\")"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">EmployeeDTO <span class="title">employeeToEmployeeDTO</span><span class="params">(Employee entity,Long priceFen)</span></span>;</span><br><span class="line">    <span class="meta">@Mappings</span>(&#123;</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"id"</span>, source=<span class="string">"dto.employeeId"</span>),</span><br><span class="line">      <span class="meta">@Mapping</span>(target=<span class="string">"name"</span>, source=<span class="string">"dto.employeeName"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">Employee <span class="title">employeeDTOtoEmployee</span><span class="params">(EmployeeDTO dto)</span></span>;</span><br><span class="line">    <span class="meta">@Mappings</span>(&#123;</span><br><span class="line">            <span class="meta">@Mapping</span>(target = <span class="string">"idDTO"</span>,source = <span class="string">"division.id"</span>),</span><br><span class="line">            <span class="meta">@Mapping</span>(target = <span class="string">"nameDTO"</span>,source = <span class="string">"division.name"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">DivisionDTO <span class="title">divisionToDivisionDTO</span><span class="params">(Division division)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个感觉还是比较鸡肋的，如果可以支持比较复杂的一些转换实际场景可能更受用。</p><h3 id="进行复杂转换"><a href="#进行复杂转换" class="headerlink" title="进行复杂转换"></a>进行复杂转换</h3><p>主要在实际的应用场景中，需要输入转换的参数可能是多个，同时我们还需要一些自定义的部分，通过加<strong><em>@BeforeMapping等注解</em></strong>可以将自定义的部分嵌入到实现类中，这里也可以支持lambok，有些版本可能会报错，maven的版本需要在3.6.0以上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个POJOs</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionDTO</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String uuid;</span><br><span class="line">    <span class="keyword">private</span> Long totalInCents;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// standard getters and setters</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String uuid = UUID.randomUUID().toString();</span><br><span class="line">    <span class="keyword">private</span> BigDecimal total;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//standard getters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要定义为抽象类，这里的寓意是限制性第一个方法，在执行第二个方法，第一个方法中可以加一些复杂的参数转换，第二个方法做一些通用的处理，同时需要使用<strong><em>@MappingTarget</em></strong>注解保证输出对象的唯一引用，不加默认会帮你重新new一个出来并且return：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span>(componentModel = <span class="string">"spring"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@BeforeMapping</span>()</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toTransactionDTO</span><span class="params">(Transaction transaction,@MappingTarget TransactionDTO transactionDTO)</span> </span>&#123;</span><br><span class="line">        transactionDTO.setTotalInCents(transaction.getTotal()</span><br><span class="line">          .multiply(<span class="keyword">new</span> BigDecimal(<span class="string">"100"</span>)).longValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Mapping</span>(source = <span class="string">"transaction.uuid"</span>,target = <span class="string">"uuid"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">transactionToTransactionDTO</span><span class="params">(Transaction transaction , @MappingTarget TransactionDTO transactionDTO)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里为什么要介绍MapStruct这个工具包，实际上在我们的项目中确实有太多的拷贝动作，导致了方法都是在set，get方法过长，较难进行维护，非常不清晰。之后可以尝试通过MapStruct改造一些有类似问题的接口，通过定义一个抽象类的Mapper，将复杂操作维护一个自定义方法，简单的映射直接通过@Mapping，开发者只需要关心对应的抽象接口定义。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在实际开发过程中会出现很多bean之间的拷贝动作，这样的动作需要不停的去进行set操作。容易造成代码的耦合和维护困难。通过MapStruct我们只需要定义一个接口，这个工具包会帮我们自动生成一个实现类，并且这个类是不可编辑的，代码自动生成帮我们省去了开发维护成本同时做了
      
    
    </summary>
    
    
      <category term="大搜车的点滴记录" scheme="http://jianghao.wang/tags/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%9A%84%E7%82%B9%E6%BB%B4%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal介绍</title>
    <link href="http://jianghao.wang/2019/ThreadLocal%E4%BB%8B%E7%BB%8D/"/>
    <id>http://jianghao.wang/2019/ThreadLocal介绍/</id>
    <published>2019-04-12T03:11:54.515Z</published>
    <updated>2019-05-06T01:39:27.012Z</updated>
    
    <content type="html"><![CDATA[<p>ThreadLocal变量可以理解为线程内部私有的共享变量。在Java的内存模型中每个线程拥有自己的工作线程，这个变量是一个map结构的专门用于线程私有变量的存储，方便于解耦+防止并发。StackOverFlow上有段解释较为通俗。<strong><em>When and how can we use ThreadLocal variable?</em></strong>：</p><ul><li><strong>When an object is not thread-safe, instead of synchronization</strong> which hampers the scalability, give one object to every thread and keep it thread scope, which is ThreadLocal. One of most often used but not thread-safe objects are database Connection and JMSConnection.</li><li>One example is <strong>Spring framework uses ThreadLocal heavily for managing transactions behind the scenes by keeping these connection objects in ThreadLocal variables</strong>. At high level, when a transaction is started it gets the connection ( and disables the auto commit ) and keeps it in ThreadLocal. on further db calls it uses same connection to communicate with db. At the end, it takes the connection from ThreadLocal and commits ( or rollback ) the transaction and releases the connection.I think <strong>log4j also uses ThreadLocal for maintaining MDC</strong>.</li></ul><p>通常线程池这种并发的资源模型会面临多线程竞争，可以将线程的每个连接初始化到每个线程中避免竞争。这时候会将这个连接放置到ThreadLocal变量中。</p><h3 id="ThreadLocal-API"><a href="#ThreadLocal-API" class="headerlink" title="ThreadLocal API"></a>ThreadLocal API</h3><p>ThreadLocal变量实际上是以当前线程为key，可以指定一个value的map对象，只能容放一个kv键值对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.study.TreadLocal;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.ThreadLocal变量一般定义为private static。</span></span><br><span class="line"><span class="comment"> * 2.可以通过无参构造函数初始化or函数式初始化。</span></span><br><span class="line"><span class="comment"> * 3.ThreadLocal以当前线程为key，value可以指定类型，只能存储一个值。</span></span><br><span class="line"><span class="comment"> * 4.ThreadLocal初始化之后的值不能被remove掉。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//类加载的时候直接初始化，并且初始值不会被remove</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal=ThreadLocal.withInitial(()-&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//类加载的时候未被初始化，只提供无参构造函数，只有默认值null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal1=<span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"get有初始化ThreadLocal："</span>+threadLocal.get());</span><br><span class="line">        threadLocal.remove();</span><br><span class="line">        System.out.println(<span class="string">"remove初始化的ThreadLocal："</span>+threadLocal.get());</span><br><span class="line"></span><br><span class="line">        threadLocal.set(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"get重新赋值的ThreadLocal："</span>+threadLocal.get());</span><br><span class="line"></span><br><span class="line">        threadLocal.remove();</span><br><span class="line">        System.out.println(<span class="string">"remove重新赋值的ThreadLocal："</span>+threadLocal.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//threadLocal1</span></span><br><span class="line">        System.out.println(<span class="string">"get无初始化ThreadLocal1："</span>+threadLocal1.get());</span><br><span class="line">        threadLocal1.set(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"get重新赋值的ThreadLocal1："</span>+threadLocal1.get());</span><br><span class="line"></span><br><span class="line">        threadLocal1.remove();</span><br><span class="line">        System.out.println(<span class="string">"remove重新赋值的ThreadLocal1："</span>+threadLocal1.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">get初始化ThreadLocal：<span class="number">1</span></span><br><span class="line">remove初始化的ThreadLocal：<span class="number">1</span></span><br><span class="line">get重新赋值的ThreadLocal：<span class="number">2</span></span><br><span class="line">remove重新赋值的ThreadLocal：<span class="number">1</span></span><br><span class="line">get初始化ThreadLocal1：<span class="keyword">null</span></span><br><span class="line">get重新赋值的ThreadLocal1：<span class="number">2</span></span><br><span class="line">remove重新赋值的ThreadLocal1：<span class="keyword">null</span></span><br></pre></td></tr></table></figure><h3 id="Storing-User-Data-in-a-Map"><a href="#Storing-User-Data-in-a-Map" class="headerlink" title="Storing User Data in a Map"></a>Storing User Data in a Map</h3><p>我们假定每个线程都需要存储它的登录信息，这里给定一个用户信息类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们要实现每个userId对应一个context就需要将这个userId作为key存储在map中，同时需要时concurrentHashMap满足多线程并发的线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedMapWithUserContext</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Integer, Context&gt; userContextPerUserId</span><br><span class="line">      = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository = <span class="keyword">new</span> UserRepository();</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String userName = userRepository.getUserNameForUserId(userId);</span><br><span class="line">        userContextPerUserId.put(userId, <span class="keyword">new</span> Context(userName));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// standard constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们通过测试类去测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SharedMapWithUserContext firstUser = <span class="keyword">new</span> SharedMapWithUserContext(<span class="number">1</span>);</span><br><span class="line">SharedMapWithUserContext secondUser = <span class="keyword">new</span> SharedMapWithUserContext(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(firstUser).start();</span><br><span class="line"><span class="keyword">new</span> Thread(secondUser).start();</span><br><span class="line"> </span><br><span class="line">assertEquals(SharedMapWithUserContext.userContextPerUserId.size(), <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>这种方式也是可以的，相对来说需要去做一个线程安全的东西成本比较大。</p><h3 id="Storing-User-Data-in-ThreadLocal"><a href="#Storing-User-Data-in-ThreadLocal" class="headerlink" title="Storing User Data in ThreadLocal"></a>Storing User Data in ThreadLocal</h3><p>向上面这种情况我们可以将这个context存在每个线程自有的ThreadLocal变量中，不用考虑线程安全的问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalWithUserContext</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Context&gt; userContext </span><br><span class="line">      = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository = <span class="keyword">new</span> UserRepository();</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String userName = userRepository.getUserNameForUserId(userId);</span><br><span class="line">        userContext.set(<span class="keyword">new</span> Context(userName));</span><br><span class="line">        System.out.println(<span class="string">"thread context for given userId: "</span></span><br><span class="line">          + userId + <span class="string">" is: "</span> + userContext.get());</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// standard constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，我们可以进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalWithUserContext firstUser </span><br><span class="line">  = <span class="keyword">new</span> ThreadLocalWithUserContext(<span class="number">1</span>);</span><br><span class="line">ThreadLocalWithUserContext secondUser </span><br><span class="line">  = <span class="keyword">new</span> ThreadLocalWithUserContext(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(firstUser).start();</span><br><span class="line"><span class="keyword">new</span> Thread(secondUser).start();</span><br></pre></td></tr></table></figure><p>可以得到一个结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread context <span class="keyword">for</span> given userId: <span class="number">1</span> is: Context&#123;userNameSecret=<span class="string">'18a78f8e-24d2-4abf-91d6-79eaa198123f'</span>&#125;</span><br><span class="line">thread context <span class="keyword">for</span> given userId: <span class="number">2</span> is: Context&#123;userNameSecret=<span class="string">'e19f6a0a-253e-423e-8b2b-bca1f471ae5c'</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal如何实现"><a href="#ThreadLocal如何实现" class="headerlink" title="ThreadLocal如何实现"></a>ThreadLocal如何实现</h3><p>很多blog都介绍了ThreadLocal主要作用是解耦+防止并发。实际上我自己将其理解为一个<strong><em>全局map变量，全局变量的存在减少了不必要的参数传递，也就是解耦</em></strong>，这个全局变量我们一般通过定义变量为private static实现，需要通过类直接访问可以定义为public static。通过<strong><em>维护当前线程id作为map的key，保证了只有当前key的value对当前线程可见，其他线程无法访问到这个value的资源</em></strong>，那么这个value便可以理解为线程的私有资源，实际上这些对象都还是放在堆中，只不过用key标示了每个资源的归属 ，也就是每个工作线程都有自己的私有空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the current thread's copy of this thread-local variable</span></span><br><span class="line"><span class="comment">     * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment">     * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment">     * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</span></span><br><span class="line"><span class="comment">     *        this thread-local.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一般我们的框架在处理了登录之后，例如单点登录，一个请求进入到tomcat，分配线程资源，进入到后台，通过拦截器分发的对应的sso服务。服务返回登录信息，这个时候会<strong><em>写一个ThreadLocal变量（AuthNHolder）以当前线程id为key，保存用户信息到value里面</em></strong>，之后线程在任何地方想获取这个用户信息可以直接从ThreadLocal中拿到，<strong><em>线程请求完成之后回到拦截器会将这个value清空</em></strong>。这里应该可以体会到解耦+防止并发。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实我们在使用这个变量的时候，通常也要防止在线程池的情况下，可能会导致某一个线程同时消费很多任务，如果在一个任务结束之后没有将线程的工作空间进行清除，那么这个工作空间会存储两个任务的信息，这可能会产生问题。我们可以通过登录保存用户信息这个案例更好的了解ThreadLocal的应用。<strong><em>详细可以参考optimus中AuthHolder的实现</em></strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ThreadLocal变量可以理解为线程内部私有的共享变量。在Java的内存模型中每个线程拥有自己的工作线程，这个变量是一个map结构的专门用于线程私有变量的存储，方便于解耦+防止并发。StackOverFlow上有段解释较为通俗。&lt;strong&gt;&lt;em&gt;When and 
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>杭城四少面试题</title>
    <link href="http://jianghao.wang/2019/%E6%9D%AD%E5%9F%8E%E5%9B%9B%E5%B0%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://jianghao.wang/2019/杭城四少面试题/</id>
    <published>2019-04-08T14:30:53.864Z</published>
    <updated>2019-04-08T14:42:43.405Z</updated>
    
    <content type="html"><![CDATA[<h3 id="江董"><a href="#江董" class="headerlink" title="江董"></a>江董</h3><p>江董上海面试题，30分钟写不出，现场代码至少一个小时(实际情况肯定要结合测试用例)，这里实现一个O(N)的版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有两个字符串，开始字符串：startStr，结束字符串：endStr。</span></span><br><span class="line"><span class="comment"> * startStr=LRXRLLXR</span></span><br><span class="line"><span class="comment"> * endStr=XRRLXXLR</span></span><br><span class="line"><span class="comment"> * LR可转换成RL</span></span><br><span class="line"><span class="comment"> * RX可转换成XR</span></span><br><span class="line"><span class="comment"> * 实现一个方法，判断startStr是否可转换成endStr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*ThreadPoolExecutor executor =</span></span><br><span class="line"><span class="comment">                (ThreadPoolExecutor) Executors.newFixedThreadPool(5);</span></span><br><span class="line"><span class="comment">        ExecutorService executorService =</span></span><br><span class="line"><span class="comment">                MoreExecutors.getExitingExecutorService(executor,</span></span><br><span class="line"><span class="comment">                        10000, TimeUnit.MILLISECONDS);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        executorService.submit(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">            while (true) &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(1);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//start from here</span></span><br><span class="line">        StringEqual stringEqualA = <span class="keyword">new</span> StringEqual(<span class="string">"LRRXX"</span>);</span><br><span class="line">        StringEqual stringEqualB = <span class="keyword">new</span> StringEqual(<span class="string">"RRLXR"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(stringEqualA.equals(stringEqualB));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringEqual</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringEqual</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.string = string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        StringEqual stringEqualB = (StringEqual) obj;</span><br><span class="line">        <span class="keyword">char</span>[] charsA = string.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] charsB = stringEqualB.string.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charsB.length; i++) &#123;</span><br><span class="line">            <span class="comment">//如果不想等&amp;&amp;未到末尾字符，尝试走转换器</span></span><br><span class="line">            <span class="keyword">if</span> ((charsA[i] != charsB[i]) &amp;&amp; (i &lt; (charsB.length - <span class="number">1</span>))) &#123;</span><br><span class="line">                String a = <span class="keyword">new</span> Character(charsA[i]).toString() +</span><br><span class="line">                    <span class="keyword">new</span> Character(charsA[i + <span class="number">1</span>]).toString();</span><br><span class="line">                String b = <span class="keyword">new</span> Character(charsB[i]).toString() +</span><br><span class="line">                    <span class="keyword">new</span> Character(charsB[i + <span class="number">1</span>]).toString();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (defineEquals(a, b, charsA, charsB, i)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//print一下pop的结果 转换器无法进行转换</span></span><br><span class="line">                    System.out.println(charsA);</span><br><span class="line">                    System.out.println(charsB);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == (charsB.length - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//print一下最终的结果，最后一个字符特殊处理不用往后走转换器</span></span><br><span class="line">                System.out.println(charsA);</span><br><span class="line">                System.out.println(charsB);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> charsB[i] == charsA[i];</span><br><span class="line">            &#125; <span class="comment">//相等继续往下走</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//print一下最终的转换结果</span></span><br><span class="line">        System.out.println(charsA);</span><br><span class="line">        System.out.println(charsB);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义规则（自定义一个转换器）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">defineEquals</span><span class="params">(String a, String b, <span class="keyword">char</span>[] charsA,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">char</span>[] charsB, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//两字符串在TR组合中</span></span><br><span class="line">        <span class="keyword">if</span> (a.equals(<span class="string">"LR"</span>) &amp;&amp; b.startsWith(<span class="string">"R"</span>)) &#123;</span><br><span class="line">            charsA[index] = <span class="string">'R'</span>;</span><br><span class="line">            charsA[index + <span class="number">1</span>] = <span class="string">'L'</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.startsWith(<span class="string">"R"</span>) &amp;&amp; b.equals(<span class="string">"LR"</span>)) &#123;</span><br><span class="line">            charsB[index] = <span class="string">'R'</span>;</span><br><span class="line">            charsB[index + <span class="number">1</span>] = <span class="string">'L'</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="comment">//两字符串在RX组合中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a.equals(<span class="string">"RX"</span>) &amp;&amp; b.startsWith(<span class="string">"X"</span>)) &#123;</span><br><span class="line">            charsA[index] = <span class="string">'X'</span>;</span><br><span class="line">            charsA[index + <span class="number">1</span>] = <span class="string">'R'</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.startsWith(<span class="string">"X"</span>) &amp;&amp; b.equals(<span class="string">"RX"</span>)) &#123;</span><br><span class="line">            charsB[index] = <span class="string">'X'</span>;</span><br><span class="line">            charsB[index + <span class="number">1</span>] = <span class="string">'R'</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="坤宝"><a href="#坤宝" class="headerlink" title="坤宝"></a>坤宝</h3><p><strong>题目：一个字符串含有空格，求非空格最长子串长度，要求时间和空间最优。例如：”aa aa aaaa aaa a a a aa aa a”；</strong></p><p>想不出更好的，直接放弃。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;江董&quot;&gt;&lt;a href=&quot;#江董&quot; class=&quot;headerlink&quot; title=&quot;江董&quot;&gt;&lt;/a&gt;江董&lt;/h3&gt;&lt;p&gt;江董上海面试题，30分钟写不出，现场代码至少一个小时(实际情况肯定要结合测试用例)，这里实现一个O(N)的版本。&lt;/p&gt;
&lt;figure c
      
    
    </summary>
    
    
      <category term="面试记录" scheme="http://jianghao.wang/tags/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池介绍</title>
    <link href="http://jianghao.wang/2019/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%8B%E7%BB%8D/"/>
    <id>http://jianghao.wang/2019/Java线程池介绍/</id>
    <published>2019-04-02T03:12:54.652Z</published>
    <updated>2019-07-30T11:01:13.099Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池主要用于管理线程资源，在Java中，线程资源映射到操作系统层面，占用的是操作提供层面的资源。如果不进行良好的管理，可能会快速耗尽系统的线程资源。你可以编写多线程并行的代码，将任务提交给线程池的实例执行。线程池会管理线程的生命周期，以及会将任务维护在一个内部的队列中，完成任务的调度。</p><p><img src="https://arthornye.github.io/images/threadpool.png" alt="cmd-markdown-logo"></p><h3 id="Java中的线程池"><a href="#Java中的线程池" class="headerlink" title="Java中的线程池"></a>Java中的线程池</h3><h4 id="Executor-Executors-ExecutorService"><a href="#Executor-Executors-ExecutorService" class="headerlink" title="Executor+Executors+ExecutorService"></a>Executor+Executors+ExecutorService</h4><p>我们通常会用到这几个类，其中<strong><em>Executors</em></strong>这个类可以获取到很多初始化的线程池实例，这些实例拥有不同的预配置。如果你不需要自定义一个线程池，这个类的使用会非常方便。</p><p><strong><em>Executor和ExecutorService</em></strong>提供了一些接口方法可以让开发者自定义去实现，通过这种方式将提交任务也就是上图中的左边部分和线程池的具体实现分离开来。这里我们通过一段代码查看如果通过<strong><em>Executors</em></strong>这个线程池工具类获取一个<strong><em>Executor</em></strong>实例，然后通过这个实力去提交一个task：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Executor executor = Executors.newSingleThreadExecutor();</span><br><span class="line">executor.execute(() -&gt; System.out.println(<span class="string">"Hello World"</span>));</span><br></pre></td></tr></table></figure><p><strong><em>Executor</em></strong>提供的方法较为简单，我们可以利用<strong><em>ExecutorService</em></strong>的一些更为丰富的api去开发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">Future&lt;String&gt; future = executorService.submit(() -&gt; <span class="string">"Hello World"</span>);</span><br><span class="line"><span class="comment">// some operations</span></span><br><span class="line">String result = future.get();</span><br></pre></td></tr></table></figure><p>我们可以通过返回的Feature来等待这个异步线程任务完成。这里延伸出Java8中CompletableFeature,这个类提供的异步操作api更为丰富之后可以对比介绍，同时可以深入了解<strong><em>ExecutorService</em></strong>。</p><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p><strong><em>ThreadPoolExecutor</em></strong>是一种可扩展的提供很多参数调整的线程池，这里主要介绍几个参数，<strong><em>corePoolSize(核心线程数)，maximumPoolSize(最大线程数)，keepAliveTime(超出线程生命周期)</em></strong>。队列类型留到下次进行补充。</p><p><strong><em>corePoolSize</em></strong>是线程池的核心线程数，会从队列中不断拉取任务进行执行，如果队列中有任务到来会new一个核心线程进行执行，同时如果执行队列执行完了，对应的核心线程也不会进行回收。当我们通过submit提交任务时，会首先往任务队列里面追加，直到超出队列的大小之后，会创建新的线程进行执行。<strong><em>maximumPoolSize</em></strong>指定了当任务队列存满时，可以独立创建的最大线程数，下面的例子任务队列长度为3，最大线程数为10，所以当线程数量超过5时，会生成新的线程。另外当额外需要的线程超过<strong><em>maximumPoolSize-corePoolSize</em></strong>时，那么会队列会抛出<strong><em>RejectedExecutionHandler</em></strong>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor executor=<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">10</span>, <span class="number">0</span>,</span><br><span class="line">                TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">13</span>;i++)&#123;</span><br><span class="line">            executor.submit(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"当前线程池核心线程数:"</span>+executor.getCorePoolSize());</span><br><span class="line">        System.out.println(<span class="string">"当前线程池最大线程数"</span> + executor.getMaximumPoolSize());</span><br><span class="line">        System.out.println(<span class="string">"当前线程池工作线程数："</span>+executor.getPoolSize());</span><br><span class="line">        System.out.println(<span class="string">"当前线程池队列中等待的任务数："</span>+executor.getQueue().size());</span><br><span class="line"><span class="comment">//再添加一个任务，抛出异常</span></span><br><span class="line">        executor.submit(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我定义了14个任务，并且每个任务都休眠10s，首先会被<strong>核心线程参数拿走2个任务</strong>，然后往<strong>LinkedBlockingDeque追加3个任务</strong>，然后<strong>最大线程参数独立生成8个线程</strong>，总共消化了13个线程，最后一个线程被队列拒绝，抛出异常，这段代码的执行结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">当前线程池核心线程数:2</span><br><span class="line">当前线程池最大线程数10</span><br><span class="line">当前线程池工作线程数：10</span><br><span class="line">当前线程池队列中等待的任务数：3</span><br><span class="line"></span><br><span class="line">Exception in thread "main" java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@3d494fbf rejected from java.util.concurrent.ThreadPoolExecutor@1ddc4ec2[Running, pool size = 10, active threads = 10, queued tasks = 3, completed tasks = 0]</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor<span class="formula">$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047)</span></span><br><span class="line"><span class="formula">at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823)</span></span><br><span class="line"><span class="formula">at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369)</span></span><br><span class="line"><span class="formula">at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:112)</span></span><br><span class="line"><span class="formula">at com.souche.TreadPoolExecutorTest.main(TreadPoolExecutorTest.java:26)</span></span><br></pre></td></tr></table></figure><p>其中Executors类提供了两种默认可以获取ThreadExecutorPool实例的方法，可以看下一些默认的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**只传入一个参数线程数</span></span><br><span class="line"><span class="comment"> * corePoolSize === maximumPoolSize</span></span><br><span class="line"><span class="comment"> * keepAliveTime === 0</span></span><br><span class="line"><span class="comment"> * LinkedBlockingDeque === 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**不传入参数</span></span><br><span class="line"><span class="comment"> * corePoolSize === 0</span></span><br><span class="line"><span class="comment"> * maxmumPoolSize === Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment"> * keepAliveTime === 60s</span></span><br><span class="line"><span class="comment"> * SynchronousQueue === 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ExecutorService executorService1 = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**不传参数</span></span><br><span class="line"><span class="comment"> * 不能被转换为ThreadExecutorPool类型</span></span><br><span class="line"><span class="comment"> * corePoolSize === maximumPoolSize === 1</span></span><br><span class="line"><span class="comment"> * keepAliveTime === 0s</span></span><br><span class="line"><span class="comment"> * LinkedBlockingDeque === 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ExecutorService executorService2=Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure><p>缓存的线程池也就是第二种，其实就是为了<strong>支持线程无限量的增长，以适应无限数量任务的添加</strong>。当时他们会被回收当空闲的时间超过了60s，这种线程池的一种很明显的应用场景就是<strong>有很多短期的任务</strong>。第三种<strong>单线程池实际上更加适合做事件的循环</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger counter = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"> </span><br><span class="line">ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    counter.set(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    counter.compareAndSet(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里补充一下<strong><em>队列类型queueWork</em></strong>吧，看了下源码中的注释，搬运一下：</p><ul><li><strong>SynchronousQueue直传队列</strong>。中间不允许任何task缓存，所有的任务直接提交给核心线程，核心线程不够直接交给最大线程新起线程。通常直传队列需要无限的最大线程大小。因为每个任务过来都需要直接被线程消费。<strong><em>可能导致新线程不断增长超出系统负荷</em></strong>。</li><li><strong>LinkedBlockingQueue无界队列</strong>。这个队列如果不指定队列大小，将会容纳无限制的task任务，那么实际上最大线程数的参数便没有效果了，keepAlive时间也没有必要，因为不会有新的线程被开辟。这种情况可能适用于请求某一瞬间爆发，相当于消息队列缓存，但是也有可能太多完全处理不过来。<strong><em>可能导致队列无限增长超出内存负荷</em></strong>。</li><li><strong>ArrayBlockingQueue有界队列</strong>。这个队列可以指定大小，<strong><em>防止资源耗尽的情况</em></strong>，队列大小和最大池大小之间应该有一种平衡。使用大队列小池可以最小化cpu使用，os资源以及上下文切换，使用小队列大池可能导致cpu过于繁忙。</li></ul><p>通过Executors.newCachedThreadPool()获取的线程池就是通过SynchronousQueue直传队列，零队列无限池，通常适用于很多的短期任务。通过Executors.newFixedThreadPool()获取的线程池是LinkedBlockingQueue无界队列，也就是零最大池无限队列，只能指定核心线程数，也可以通过Executors.newSingleThreadPool()获取到无界队列，但是只有一个消费者线程，而且不能被强制转换为ThreadPoolExecutor类型。</p><h4 id="核心线程数什么时候被回收？"><a href="#核心线程数什么时候被回收？" class="headerlink" title="核心线程数什么时候被回收？"></a>核心线程数什么时候被回收？</h4><p>当消费者线程一直从任务队列里拿任务进行消费，最后队列为空的时候，会循环等待线程池的参数keepAliveTime时间，如果在这段时间内还是没有新的任务可以获取，线程会被销毁。当然这个默认情况下不包括核心线程数。那么核心线程什么时候进行回收？</p><ul><li><strong>通过函数allowCoreThreadTimeOut设置核心线程数在keepAliveTime时间内进行回收，不然核心线程只有在线程池被关闭的时候被回收。</strong></li></ul><h4 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h4><p>线程池的拒绝策略主要通过实现<strong>RejectedExecutionHandler中的rejectedExecution函数。</strong>下面主要介绍下几种拒绝策略：</p><ul><li><strong>ThreadPoolExecutor.AbortPolicy，退出策略，直接抛出一个运行时异常（RejectedExecutionException）。业务有损，响应较快，保护服务器资源。</strong></li><li><strong>ThreadPoolExecutor.CallerRunsPolicy，调用者运行策略，只要当前线程池不处于shutdown的状态，都将这个任务交给当前调用的线程去执行。业务无损，响应较快，服务器资源无保护。</strong></li><li><p><strong>ThreadPoolExecutor.DiscardPolicy，丢弃策略，什么都不执行，直接不管这个任务。业务有损，响应较快，保护服务器资源。</strong></p></li><li><p><strong>ThreadPoolExecutor.DiscardOldestPolicy，淘汰策略，淘汰任务队列中头部的一个任务，然后提交到线程池中，当然有可能再次失败再次就行重试。业务无损，响应较慢，服务器资源无保护（线程一直重试）。</strong></p></li></ul><p>其中，线程池默认的策略是退出策略，直接抛出异常的方式可以保护服务器资源，当然这样的处理方式始终是不够优雅的，我们可以通过set方法根据实际场景去选择对应的拒绝策略。值得注意的是我们可以重写<strong>RejectExecutionHandler接口</strong>自定义拒绝策略，一种更可行的方式是<strong>记录日志或者持久化到磁盘</strong>。可以自定义拒绝策略初始化线程池。</p><h4 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h4><p><strong><em>Executors.newScheduledThreadPool</em></strong>可以获取到一个<strong><em>ScheduledThreadPoolExecutor</em></strong>继承了<strong><em>ThreadPoolExecutor</em></strong>实现了<strong><em>ScheduledExecutorService</em></strong>接口，提供了一些控制调用时间的方法：</p><ul><li><em>schedule</em> 方法允许在指定的延迟后执行一次任务。</li><li>scheduleAtFixedRate方法允许在指定的初始延迟后执行任务，然后在一定时间内重复执行。period参数是在<strong>开始时间之后的每个任务的间隔时间</strong>。所以执行速率是固定的。</li><li>scheduleWithFixedDelay方法类似于scheduleAtFixedRate，因为它重复执行给定的任务。但是<strong>执行速率可能会有所不同</strong>，具体取决于执行任何给定任务所需的时间。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">executor.schedule(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">&#125;, <span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><p>上面初始化了一个核心线程为5，最大线程为5，并且超出线程生命周期为0s的线程池，等待500ms之后执行任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch lock = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">ScheduledFuture&lt;?&gt; future = executor.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    lock.countDown();</span><br><span class="line">&#125;, <span class="number">500</span>, <span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"> </span><br><span class="line">lock.await(<span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">future.cancel(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>上面等待500ms后开始执行任务，并且没100ms执行一次任务，知道所有的任务都执行完成，再执行主线程。</p><p><strong><em>注意点：维护了等待队列会出现线程复用的情况，如果是直传队列也会出现线程复用的情况。</em></strong></p><h4 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h4><p>主要用于在递归算法（分治）中，多个子任务可能产生过多的线程，造成系统资源耗尽，fork / join框架的好处是它不会为每个任务或子任务创建一个新线程。这里贴一个简单的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Set&lt;TreeNode&gt; children;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> value, TreeNode... children) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.children = Sets.newHashSet(children);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeNode node;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountingTask</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.node = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.value + node.children.stream()</span><br><span class="line">          .map(childNode -&gt; <span class="keyword">new</span> CountingTask(childNode).fork())</span><br><span class="line">          .collect(Collectors.summingInt(ForkJoinTask::join));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeNode tree = <span class="keyword">new</span> TreeNode(<span class="number">5</span>,</span><br><span class="line">  <span class="keyword">new</span> TreeNode(<span class="number">3</span>), <span class="keyword">new</span> TreeNode(<span class="number">2</span>,</span><br><span class="line">    <span class="keyword">new</span> TreeNode(<span class="number">2</span>), <span class="keyword">new</span> TreeNode(<span class="number">8</span>)));</span><br><span class="line"> </span><br><span class="line">ForkJoinPool forkJoinPool = ForkJoinPool.commonPool();</span><br><span class="line"><span class="keyword">int</span> sum = forkJoinPool.invoke(<span class="keyword">new</span> CountingTask(tree));</span><br></pre></td></tr></table></figure><h3 id="Guava中的线程池实现"><a href="#Guava中的线程池实现" class="headerlink" title="Guava中的线程池实现"></a>Guava中的线程池实现</h3><p>Guava是一个受欢迎的Google公用类库。它有许多有用的并发类，包括几个方便的ExecutorService实现。它提供了一个<strong><em>MoreExecutors</em></strong>这个工具类去获取它实现的一些线程池实例。我们可以添加Guava的maven依赖：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;19.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="Direct-Executor-and-Direct-Executor-Service"><a href="#Direct-Executor-and-Direct-Executor-Service" class="headerlink" title="Direct Executor and Direct Executor Service"></a>Direct Executor and Direct Executor Service</h4><p>通常我们有些情况需要当前的线程去等待另一线程执行完之后再继续执行。我们可以通过countLatchDown的方式去控制，但是还是需要自己去写代码，Guava为我们提供了线程的工具：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche;</span><br><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.MoreExecutors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> junit.framework.TestCase.assertTrue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Executor executor = MoreExecutors.directExecutor();</span><br><span class="line">        AtomicBoolean executed = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            executed.set(<span class="keyword">true</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(executed.get());</span><br><span class="line">        assertTrue(executed.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，当前的主线程会等待线程池中的线程完成之后再继续执行主线程。</p><h3 id="Runnable和Callable的区别"><a href="#Runnable和Callable的区别" class="headerlink" title="Runnable和Callable的区别"></a>Runnable和Callable的区别</h3><p>从api上看一个Runnable没有返回值，Callable定义了返回值，主要区别一个能在Future的get方法中捕获到异常和获取结果信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A task that returns a result and may throw an exception.</span></span><br><span class="line"><span class="comment"> * Implementors define a single method with no arguments called</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> call&#125;.</span></span><br><span class="line"><span class="comment"> * Callable接口跟Runnable接口非常相似，都是可以被实现并且启动一个线程。但是Runnable</span></span><br><span class="line"><span class="comment"> * 不能获得线程的执行结果也不能捕获线程的异常。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The &#123;<span class="doctag">@code</span> Callable&#125; interface is similar to &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * java.lang.Runnable&#125;, in that both are designed for classes whose</span></span><br><span class="line"><span class="comment"> * instances are potentially executed by another thread.  A</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Runnable&#125;, however, does not return a result and cannot</span></span><br><span class="line"><span class="comment"> * throw a checked exception.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The &#123;<span class="doctag">@link</span> Executors&#125; class contains utility methods to</span></span><br><span class="line"><span class="comment"> * convert from other common forms to &#123;<span class="doctag">@code</span> Callable&#125; classes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Executor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; the result type of method &#123;<span class="doctag">@code</span> call&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><div contenteditable="plaintext-only"><table></table></div></p><tr><br>    <th>方法名</th><br>    <th>Runnable</th><br>    <th>Callable</th><br></tr><br><tr><br>    <th>ExecutorService的执行方法 </th><br>    <th>execute和submit</th><br>    <th>只能是submit</th><br></tr><br><tr><br>    <th>ExecutorService.submit()返回值</th><br>    <th>Future</th><br>    <th>Future</th><br></tr><br><tr><br>    <th>返回的Future调用get()方法</th><br>    <th>null</th><br>    <th>Future定义的泛型，可捕获异常</th><br></tr><br><tr><br>    <th>取消执行</th><br>    <th>不能</th><br>    <th>Future.cancel可以取消执行</th><br></tr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本文中，我们讨论了线程池模式及其在标准Java库和Google的Guava库中的实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h3&gt;&lt;p&gt;线程池主要用于管理线程资源，在Java中，线程资源映射到操作系统层面，占用的是操作提供层面的资源。如果不进行良好的管理，可能会快速耗
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Spring事件监听机制和状态机</title>
    <link href="http://jianghao.wang/2019/Spring%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6%E5%92%8C%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    <id>http://jianghao.wang/2019/Spring事件监听机制和状态机/</id>
    <published>2019-04-01T06:17:24.630Z</published>
    <updated>2019-04-09T04:59:21.897Z</updated>
    
    <content type="html"><![CDATA[<p>Spring事件监听机制和Spring StateMachine都是基于观察者模式实现的，帮助业务代码进行解耦合。</p><h4 id="Spring事件监听实现"><a href="#Spring事件监听实现" class="headerlink" title="Spring事件监听实现"></a>Spring事件监听实现</h4><p>Spring可以帮助开发者自己实现事件监听，开发者通过实现<strong><em>ApplicationListener（观察者Observer）</em></strong>接口定义一个监听器，同时通过实现<strong><em>ApplicationEvent（主题Subject）</em></strong>接口定义一个事件。实现<strong><em>ApplicationContextAware（发布器）</em></strong>通过发布器发布时间到ApplicationContext中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.observer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationEvent;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个事件（主题 subject）</span></span><br><span class="line"><span class="comment"> * define an event</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTestEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getSource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建另一个事件监听器</span></span><br><span class="line"><span class="comment"> * 对于继承了 ApplicationEvent的事件所有入参对应的监听器都会监听到，执行onApplicationEvent方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"myTestApplictionListener"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MyTestEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyTestEvent applicationEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(applicationEvent.getClass());</span><br><span class="line">        <span class="keyword">if</span>(applicationEvent <span class="keyword">instanceof</span> MyTestEvent)&#123;</span><br><span class="line">            System.out.println(<span class="string">"get to MyTestApplicationListener..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个事件监听器（观察者 observer）</span></span><br><span class="line"><span class="comment"> * listener defination</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"myApplicationListener"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MyTestEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyTestEvent applicationEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(applicationEvent.getClass());</span><br><span class="line">        <span class="keyword">if</span>(applicationEvent <span class="keyword">instanceof</span>  MyTestEvent)&#123;</span><br><span class="line">            System.out.println(<span class="string">"get to MyApplicationListener"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationEvent;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个事件发布器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"myPublisher"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPubisher</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext=applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"into My Publisher's method to add event"</span>);</span><br><span class="line">        applicationContext.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ConfigurableApplicationContext configurableApplicationContext=SpringApplication.run(ObserverApplication.class, args);</span><br><span class="line">MyPubisher myPubisher=(MyPubisher) configurableApplicationContext.getBean(<span class="string">"myPublisher"</span>);</span><br><span class="line">myPubisher.publishEvent(<span class="keyword">new</span> MyTestEvent(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">into My Publisher<span class="string">'s method to add event</span></span><br><span class="line"><span class="string">class com.souche.observer.MyTestEvent</span></span><br><span class="line"><span class="string">get to MyApplicationListener</span></span><br><span class="line"><span class="string">class com.souche.observer.MyTestEvent</span></span><br><span class="line"><span class="string">get to MyTestApplicationListener...</span></span><br></pre></td></tr></table></figure><p><strong>可以通过@Order注解指定监听者的执行顺序。</strong>改善代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建另一个事件监听器</span></span><br><span class="line"><span class="comment"> * 对于继承了 ApplicationEvent的事件所有入参对应的监听器都会监听到，执行onApplicationEvent方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"myTestApplictionListener"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MyTestEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyTestEvent applicationEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(applicationEvent.getClass());</span><br><span class="line">        <span class="keyword">if</span>(applicationEvent <span class="keyword">instanceof</span> MyTestEvent)&#123;</span><br><span class="line">            System.out.println(<span class="string">"get to MyTestApplicationListener..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个事件监听器（观察者 observer）</span></span><br><span class="line"><span class="comment"> * listener defination</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">2</span>)</span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"myApplicationListener"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MyTestEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyTestEvent applicationEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(applicationEvent.getClass());</span><br><span class="line">        <span class="keyword">if</span>(applicationEvent <span class="keyword">instanceof</span>  MyTestEvent)&#123;</span><br><span class="line">            System.out.println(<span class="string">"get to MyApplicationListener"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">into My Publisher<span class="string">'s method to add event</span></span><br><span class="line"><span class="string">class com.souche.observer.MyTestEvent</span></span><br><span class="line"><span class="string">get to MyTestApplicationListener...</span></span><br><span class="line"><span class="string">class com.souche.observer.MyTestEvent</span></span><br><span class="line"><span class="string">get to MyApplicationListener</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring事件监听机制和Spring StateMachine都是基于观察者模式实现的，帮助业务代码进行解耦合。&lt;/p&gt;
&lt;h4 id=&quot;Spring事件监听实现&quot;&gt;&lt;a href=&quot;#Spring事件监听实现&quot; class=&quot;headerlink&quot; title=&quot;Spr
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://jianghao.wang/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>dubbo简单介绍</title>
    <link href="http://jianghao.wang/2019/%E4%BA%86%E8%A7%A3dubbo%E6%A8%A1%E5%9D%97/"/>
    <id>http://jianghao.wang/2019/了解dubbo模块/</id>
    <published>2019-03-25T05:54:57.696Z</published>
    <updated>2019-03-25T06:24:58.612Z</updated>
    
    <content type="html"><![CDATA[<h4 id="dubbo基本概念"><a href="#dubbo基本概念" class="headerlink" title="dubbo基本概念"></a>dubbo基本概念</h4><p>现代的分布式架构基本都是基于Remote Method Invocation（远程调用），通过interface暴露服务接口，客户端调用代理类实现远程通信，dubbo的分布式架构中主要有几个角色：</p><ul><li>1.服务提供者-服务启动时在指定的端口上暴露服务，并同步调用注册中心将服务的地址和端口注册到注册中心。</li><li>2.服务消费者-服务启动时从注册中心pull提供者暴露的服务，缓存到本地，并保持长连接监听注册中心的服务推送。</li><li>3.注册中心-提供者将服务暴露到zookeeper注册中心，负责保存服务提供方上报的地址信息，并向服务消费方推送。</li><li>4.监控中心-服务提供者和消费者异步更新调用信息到监控中心，监控中心监控服务的调用次数，延迟等参数。</li><li>5.运行容器-管理提供者暴露服务对象的加载，初始化以及生命周期。</li></ul><p><img src="http://arthornye.github.io/images/dubbo.png" alt="cmd-markdown-logo"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;dubbo基本概念&quot;&gt;&lt;a href=&quot;#dubbo基本概念&quot; class=&quot;headerlink&quot; title=&quot;dubbo基本概念&quot;&gt;&lt;/a&gt;dubbo基本概念&lt;/h4&gt;&lt;p&gt;现代的分布式架构基本都是基于Remote Method Invocation（远程调
      
    
    </summary>
    
    
      <category term="dubbo" scheme="http://jianghao.wang/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Redis缓存</title>
    <link href="http://jianghao.wang/2019/Redis%E7%BC%93%E5%AD%98/"/>
    <id>http://jianghao.wang/2019/Redis缓存/</id>
    <published>2019-03-05T03:28:29.309Z</published>
    <updated>2019-03-21T10:22:58.749Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Redis和Memcache的主要区别"><a href="#Redis和Memcache的主要区别" class="headerlink" title="Redis和Memcache的主要区别"></a>Redis和Memcache的主要区别</h4><ul><li>1.数据结构方面，Redis的key-value存储，value支持string，list，set，sorted set，hash等多种数据结构。Memcache只支持简单的数据类型value为string类型。</li><li>2.数据安全方面，Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而Memecache把数据全部存在内存之中。</li><li>3.Redis是非阻塞单线程IO复用模型，Memcache是非阻塞多线程IO复用模型。</li></ul><h4 id="Redis数据结构主要的使用场景"><a href="#Redis数据结构主要的使用场景" class="headerlink" title="Redis数据结构主要的使用场景"></a>Redis数据结构主要的使用场景</h4><ul><li>list，存储一个先入先出的value列表，一个<strong>Map&lt;String,List<object>&gt;</object></strong>结构，list先进先出，可以做类似队列这种结构，另外还可以提供无序的简单分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。</li><li>map,存储一个value kv列表，双层map结构<strong>Map&lt;String,Map&lt;String,List<object>&gt;&gt;</object></strong>结构，存储的结构较为丰富。</li><li>set，一个无序的去重value列表，不允许重复 ，<strong>Map&lt;String,Set<object>&gt;</object></strong>结构，可以在分布式系统下做交集，并集，差集等操作，比如可以看两个微博博主的共同粉丝，可以放在redis里面做。</li><li>sorted set，一个有序的去重value了列表，<strong>Map&lt;String,SortedSet<object>&gt;</object></strong>结构，根据object某个字段排序，也可以做有序的分页操作。</li></ul><h4 id="Redis的过期策略和内存淘汰机制"><a href="#Redis的过期策略和内存淘汰机制" class="headerlink" title="Redis的过期策略和内存淘汰机制"></a>Redis的过期策略和内存淘汰机制</h4><p><strong>Redis过期策略：</strong>定期删除+惰性删除</p><p>实际应用场景中，如果redis缓存中存在大量的数据，超过了过期时间之后，如果遍历每个key去判断过期时间删除，会造成cpu负载过大。redis采用<strong>定期删除+惰性删除</strong>过期策略，定期删除只是随机的扫描一些过期的k-v进行删除，惰性删除是指在redis中进行get某个key的时候，判断是否过期，如果过期了，直接删除，并且不返回给客户端返回任何内容。</p><ul><li>获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。</li></ul><p><strong>Redis内存淘汰机制：</strong></p><p>基于redis的定期删除和惰性删除的过期策略，删除的速度可能并没有redis缓存增加速度快，这个时候redis需要进行内存淘汰，基本基于LRU（最近最少使用原则），最近最少使用的数据被删除：</p><ul><li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在<strong>键空间</strong>中，移除最近最少使用的 key（这个是<strong>最常用</strong>的）。</li></ul><ul><li><strong>volatile-random：当内存不足以容纳新写入数据时，在</strong>设置了过期时间的键空间<strong>中，</strong>随机移除某个 key。</li></ul><p>可以基于LinkedHashMap实现一个最近最少使用原则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传递进来最多能缓存多少数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cacheSize 缓存大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> cacheSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// true 表示让 linkedHashMap 按照访问顺序来进行排序，最近访问的放在头部，最老访问的放在尾部。</span></span><br><span class="line">        <span class="keyword">super</span>((<span class="keyword">int</span>) Math.ceil(cacheSize / <span class="number">0.75</span>) + <span class="number">1</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        CACHE_SIZE = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当 map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据。</span></span><br><span class="line">        <span class="keyword">return</span> size() &gt; CACHE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>场景：对于某个系统，高峰时间有5000个请求，原本都可以打到缓存上，但是缓存意外宕机，这时所有的缓存查询打到数据库上，导致数据库雪崩。通常我们称之为<strong>缓存雪崩。</strong>缓存雪崩如何应对：</p><ul><li>事前：redis高可用，主从+哨兵，防止全盘崩溃。</li><li>事中：mysql限流+降级。</li><li>事后：redis数据持久化，宕机之后立即重启恢复数据。</li></ul><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>黑客恶意攻击，查询缓存key永远不命中，将大量请求打到数据库，通过每次缓存查询不到时，对当前查询的key增加一个空的值。</p><h4 id="缓存和数据库双写不一致"><a href="#缓存和数据库双写不一致" class="headerlink" title="缓存和数据库双写不一致"></a>缓存和数据库双写不一致</h4><p>缓存和数据库需要保持一致，否则引起脏读。数据库更新和缓存更新的先后顺序。</p><h4 id="为什么是删除缓存而不是更新缓存"><a href="#为什么是删除缓存而不是更新缓存" class="headerlink" title="为什么是删除缓存而不是更新缓存"></a>为什么是删除缓存而不是更新缓存</h4><p>更新缓存的动作可能非常频繁，但是缓存还是要以命中率为指标。可能更新动作频繁的数据实际上是一个读的冷数据，这样导致更新操作频繁浪费资源，可以用<strong>懒写的这种方式。</strong>也就是当你要更新缓存的时候，不更新，直接删除。读缓存命中失败之后从数据库磁盘读，顺便写进缓存。执行顺序：</p><ul><li>先删除缓存后更新数据库，默认第一步失败抛出异常，第一步必成功，第二步更新数据库即使失败，不影响一致性。</li><li>先更新数据库后删除缓存，第二步失败，会影响一致性。</li></ul><p><strong>极端情况下，即使是先删除缓存后更新数据库，这两个操作始终不是一个事务。可能新的值还没有写到数据库，但是旧值已经加载到缓存，导致了缓存不一致。</strong></p><h4 id="高并发下通过内存队列保持一致性"><a href="#高并发下通过内存队列保持一致性" class="headerlink" title="高并发下通过内存队列保持一致性"></a>高并发下通过内存队列保持一致性</h4><p>高并发下需要保证缓存不命中的时候读操作等待更新操作完成，这里保证缓存和数据库双写的一致性，可以通过维护一个更新操作的内存队列。这个内存队列保证分布式集群部署条件，可以考虑用redis：</p><ul><li>1.更新操作到达redis，先删除对应缓存。</li><li>2.根据更新数据的唯一标示，删除缓存通识增加一个更新队列到redis中。key为数据唯一标示。</li><li>3.读操作到达redis，查询缓存未命中，查询内存队列，有更新操作需要等待，超时时间内等待。</li><li>4.更新队列更新数据库操作完成，清空内存队列。</li><li>5.读操作循环检测内存队列，直到内存队列为空，开启查询，读操作设置超时时间，超时从数据库读取旧值。</li></ul><p><strong>实际上在高并发的场景下，我们保证了一致性就必定是不能保证高可用的。如果更新操作频繁，将会导致读操作超时阻塞等待时间比较久。实际场景也需要做大量的测试。</strong></p><h4 id="分布式寻址算法"><a href="#分布式寻址算法" class="headerlink" title="分布式寻址算法"></a>分布式寻址算法</h4><p>先介绍下分布式寻址一般采用的几种方式：</p><blockquote><p>分布式寻址算法主要针对将数据分成多片，适合<strong>海量数据+高并发+高可用</strong>这种场景。无法对key进行范围查找，单片对范围查找支持比较友好。</p></blockquote><p>针对这种场景可以采用hash算法，一致性hash算法或者hash slot算法。目前redis cluster采用的是hash slot算法。这里假设场景是，多个master，每个master上存储了部分元数据，同时每个master都有自己的slave集群，结合sentinel哨兵机制去做高可用。</p><h5 id="hash算法（导致缓存穿透）"><a href="#hash算法（导致缓存穿透）" class="headerlink" title="hash算法（导致缓存穿透）"></a>hash算法（导致缓存穿透）</h5><ul><li>1.根据数据的key值进行hash，得到唯一的hash值，再通过取模，得到具体要去哪个master寻数据。</li><li>2.如果出现宕机，取模的数量会减少一，导致大量的数据都是寻址到不对应的master上，缓存命中失败，缓存穿透。</li></ul><h5 id="一致性hash算法（虚拟节点负载均衡）"><a href="#一致性hash算法（虚拟节点负载均衡）" class="headerlink" title="一致性hash算法（虚拟节点负载均衡）"></a>一致性hash算法（虚拟节点负载均衡）</h5><p>一致性hash算法，针对上面的hash算法进行了处理：</p><ul><li>1.先定制一个hash环，hash值可能从0～2^32-1，所有的master节点都会被映射环的任意位置。</li><li>2.假设我们当前有八个master节点，每个节点开始在环上寻找自己的位置，根据主机ip+端口得到的hash值占据环上某个位置。</li><li>3.当查询或者更新的key进来时，同样根据key去做hash得到hash值落在环上某个点，顺时针找到第一个master节点。</li><li>4.节点数量很少的情况下可能导致节点过于分散，出现单个master节点负载过高，采用虚拟节点进行负载均衡，在step2对节点进行hash的时候，单个master进行多次hash产生多个虚拟节点，尽量均匀分散。</li></ul><h5 id="redis-cluster的hash-slot算法"><a href="#redis-cluster的hash-slot算法" class="headerlink" title="redis cluster的hash slot算法"></a>redis cluster的hash slot算法</h5><p>redis cluster提出了哈希槽的概念，没有采用一致性hash算法。一致性hash算法具备很好的数据容错性和扩展性，当某一个节点宕机时，只有宕机的节点历史数据会受到影响，新数据会容错到其他的节点上，而且如果需要增加和删除节点，也是非常方便的。</p><p>redis cluster采用的了<strong>2^14（16834）个</strong>hash slot，这些slot会根据节点自动分片，当删除节点和增加节点的时候会将节点的hash slot进行重新分配，动态增加和减少节点不影响整个集群的可用性。</p><p>redis高可用和主备切换，可以类比哨兵机制replication+sentinel，主要的步骤：</p><ul><li>1.判断master节点宕机，直接ping不过，主观宕机，多数节点ping master不过，客观宕机，认定master宕机。</li><li>2.slave节点过滤，通过slave的连接master时间失联的长短过滤掉失联过长的slave节点。</li><li>3.slave节点选举，选举出数据最多的某个slave作为新的master节点，进行故障转移。</li></ul><p>整个过程跟哨兵机制是高度一致的。</p><h4 id="redis分布式锁和zookeeper分布式锁"><a href="#redis分布式锁和zookeeper分布式锁" class="headerlink" title="redis分布式锁和zookeeper分布式锁"></a>redis分布式锁和zookeeper分布式锁</h4><p>redis分布式锁加锁在当前redis cluster的部署机制下，需要对某个master的节点遍历加锁才算加锁成功，并且其他的线程需要等待，底层是线上较zookeeper更为复杂。通常我们采用zookeeper做分布式锁实现较为简单。</p><ul><li>redis 分布式锁，其实<strong>需要自己不断去尝试获取锁</strong>，比较消耗性能。获取到锁的客户端挂了其他客户端需要等待锁释放。</li><li>zk 分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小。获取到锁的客户端挂了不需要等待，直接释放。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Redis和Memcache的主要区别&quot;&gt;&lt;a href=&quot;#Redis和Memcache的主要区别&quot; class=&quot;headerlink&quot; title=&quot;Redis和Memcache的主要区别&quot;&gt;&lt;/a&gt;Redis和Memcache的主要区别&lt;/h4&gt;&lt;ul&gt;

      
    
    </summary>
    
    
      <category term="缓存学习" scheme="http://jianghao.wang/tags/%E7%BC%93%E5%AD%98%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
