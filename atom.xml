<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TizzyT&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/9dde1b9d65b89035e235650923e5811e</icon>
  <subtitle>即使是拖后腿的，拼死努力的话，也是可以超越精英的。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jianghao.wang/"/>
  <updated>2018-04-04T06:59:44.000Z</updated>
  <id>http://jianghao.wang/</id>
  
  <author>
    <name>yeqiaozhu</name>
    <email>yqz_zjut@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CountDownLatch和CyclicBarrier</title>
    <link href="http://jianghao.wang/2018/CountDownLatch%E5%92%8CCyclicBarrier/"/>
    <id>http://jianghao.wang/2018/CountDownLatch和CyclicBarrier/</id>
    <published>2018-04-04T06:59:44.000Z</published>
    <updated>2018-04-04T06:59:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>CountDownLatch和CyclicBarrier都是给予AQS队列同步器实现的共享锁。</p><p>CountDownLatch是单纯通过维持一个state的计数数值，这个数值在线程调用countDownLatch.countDown()的时候会减1，当计数器的值为零的时候，等待的线程会向前执行。假如我们需要保证在主线程继续往前执行的时候，子任务都已经被启动，可以通过CountDownLatch来进行控制。实际上和ReetrantLock是基于同样的原理实现，不过是实现和覆盖了tryAccquireShare和tryReleaseShare的区别。</p><p>CyclicBarrier则和CountDownLatch以及ReetrantLock不相同，它是通过lock和等待／通知机制实现的，在CountDownLatch实现的多线程模型中，各个线程之间是没办法进行通信的，只能保证一个happens-before，但是CyclicBarrier通过lock+Condition来维持一个同步队列和等待队列（通常将等待在同步块外面的队列称之为同步队列，将等待在某个对象上的队列称之为等待队列），lock中的Condition对象可以有多个，也就是维护多个等待队列。我们观察CyclicBarrier的实现可以看到它的内部只维持了一个等待队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The lock for guarding barrier entry */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/** Condition to wait on until tripped */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();<span class="comment">//维持了一个等待队列，可以通过trip.signal唤醒等待队列中所有的节点加入到同步队列中。</span></span><br><span class="line">    <span class="comment">/** The number of parties */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line">    <span class="comment">/* The command to run when tripped */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line">    <span class="comment">/** The current generation */</span></span><br><span class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br></pre></td></tr></table></figure><h3 id="CountDownLatch的使用"><a href="#CountDownLatch的使用" class="headerlink" title="CountDownLatch的使用"></a>CountDownLatch的使用</h3><p>我们通过一段代码查看CountDownLatch的主要使用方式，我们定义一个woker线程，作为子任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 4/3/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String workerName;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(String workerName,CountDownLatch countDownLatch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.workerName=workerName;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch=countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doWorker();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWorker</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getWorkerName()+<span class="string">"释放一次共享锁"</span>);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWorkerName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> workerName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWorkerName</span><span class="params">(String workerName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.workerName = workerName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过main方法调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 4/3/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line">        ArrayList&lt;Thread&gt; arrayListWorker=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            arrayListWorker.add(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(<span class="string">"worker_"</span>+(i+<span class="number">1</span>),countDownLatch)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread worker:arrayListWorker)&#123;</span><br><span class="line">            worker.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"countDownLatch结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">worker_1释放一次共享锁</span><br><span class="line">worker_4释放一次共享锁</span><br><span class="line">worker_2释放一次共享锁</span><br><span class="line">worker_5释放一次共享锁</span><br><span class="line">worker_3释放一次共享锁</span><br><span class="line">countDownLatch结束</span><br></pre></td></tr></table></figure><p>这样的使用方式我们可以看到CountDownLatch实际上保证了当前主线程会等待所有的线程都启动，我们可以通过countDownLatch.countDown()这个方法去动态更改state的数值，主线程只有在state的数值变成0之后才会选择继续向前执行。这样的处理似乎很像thread.join这种等待当前线程执行结束在执行主线程的方式，不同的是使用CountDownLatch你不一定要保证线程已经执行结束进入死亡状态，你可以在线程执行栈中通过countDownLatch.countDown()手动更改这个state的数值，只要这个数值为0，主线程便可以开始运行。</p><h3 id="CountDownLatch源代码分析"><a href="#CountDownLatch源代码分析" class="headerlink" title="CountDownLatch源代码分析"></a>CountDownLatch源代码分析</h3><p>CountDownLatch实现的几个主要方法，通过内部的sync重写了AQS队列同步器中的获取和释放共享锁的方法。我们通过CountDownLatch的构造方法去设置state的数值。getCount可以获得当前的state值。通过countDown去循环cas减少state的数值，最后的await方法实现循环等待state的值，直到变为零。这里看下await方法的主要源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">  <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">      <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          setHeadAndPropagate(node, r);</span><br><span class="line">          p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">          failed = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">          parkAndCheckInterrupt())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">      cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CyclicBarrier的使用"><a href="#CyclicBarrier的使用" class="headerlink" title="CyclicBarrier的使用"></a>CyclicBarrier的使用</h3><p>对比CountDownLatch的使用我们可以发现CountDownLatch的缺陷是线程是完全互不干扰的，也就是没有相互的协同工作。CyclicBarrier通过lock维护一个同步队列，再通过locks.newCondition获取到的condition对象维护一个等待队列，形成等待／通知机制，conditon的await和signal类似于object的wait和notify。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 4/4/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    CyclicBarrier cyclicBarrier;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrierWorker</span><span class="params">(CyclicBarrier cyclicBarrier,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        <span class="keyword">this</span>.index=index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 用户开始抽奖，持续"</span>+(index+<span class="number">1</span>)+<span class="string">"秒"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((index+<span class="number">1</span>) * <span class="number">1000</span>);</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"所有用户抽奖完毕，颁发奖项。为用户"</span> + Thread.currentThread().getName() + <span class="string">"颁奖。"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数启动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 4/3/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"5个用户开始抽奖"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread(<span class="keyword">new</span> CyclicBarrierWorker(cyclicBarrier,index)), <span class="string">"Thread-"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>个用户开始抽奖Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">18</span> CST <span class="number">2018</span></span><br><span class="line">Thread-<span class="number">0</span> 用户开始抽奖，持续<span class="number">1</span>秒Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">19</span> CST <span class="number">2018</span></span><br><span class="line">Thread-<span class="number">1</span> 用户开始抽奖，持续<span class="number">2</span>秒Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">19</span> CST <span class="number">2018</span></span><br><span class="line">Thread-<span class="number">2</span> 用户开始抽奖，持续<span class="number">3</span>秒Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">19</span> CST <span class="number">2018</span></span><br><span class="line">Thread-<span class="number">3</span> 用户开始抽奖，持续<span class="number">4</span>秒Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">19</span> CST <span class="number">2018</span></span><br><span class="line">Thread-<span class="number">4</span> 用户开始抽奖，持续<span class="number">5</span>秒Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">19</span> CST <span class="number">2018</span></span><br><span class="line">所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">4</span>颁奖。Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">24</span> CST <span class="number">2018</span></span><br><span class="line">所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">0</span>颁奖。Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">24</span> CST <span class="number">2018</span></span><br><span class="line">所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">1</span>颁奖。Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">24</span> CST <span class="number">2018</span></span><br><span class="line">所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">2</span>颁奖。Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">24</span> CST <span class="number">2018</span></span><br><span class="line">所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">3</span>颁奖。Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">24</span> CST <span class="number">2018</span></span><br></pre></td></tr></table></figure><h3 id="CyclicBarrier源码分析"><a href="#CyclicBarrier源码分析" class="headerlink" title="CyclicBarrier源码分析"></a>CyclicBarrier源码分析</h3><p>这里主要分析cyclicBarrier.await方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Main barrier code, covering the various policies.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">TimeoutException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  lock.lock();<span class="comment">//所有进入同步队列获取锁</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g.broken)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">      breakBarrier();</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = --count;<span class="comment">//计数器的值减1</span></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped，如果计数值已经为零代表所有的线程都已经进入了condition对象的等待队列，可以开始通知等待队列进入同步队列。</span></span><br><span class="line">      <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">        <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">          command.run();</span><br><span class="line">        ranAction = <span class="keyword">true</span>;</span><br><span class="line">        nextGeneration();<span class="comment">//内部会调用signalAll方法通知等待队列。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ranAction)</span><br><span class="line">          breakBarrier();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timed)</span><br><span class="line">          trip.await(); <span class="comment">//放到Conditon的等待队列里，同时释放锁，让其他线程执行await方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">          nanos = trip.awaitNanos(nanos);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">          breakBarrier();</span><br><span class="line">          <span class="keyword">throw</span> ie;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">          <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">          <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">          Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (g.broken)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (g != generation)<span class="comment">//说明执行了nextGeneration方法，计数器到了0</span></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">        breakBarrier();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 唤醒Conditon等待队列上的所有线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// 计数器值变成原始值，重新开始</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// generation被重新构造</span></span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个执行的过程，线程在调用了await方法之后，会通过lock方式上锁，然后线程将计数器的值减1。如果计数器的值到达0，说明conditon维护的等待队列已满，调用nextGeneration唤醒condition等待队列上的所有线程。加入到同步队列中，然后返回index，释放锁，之后同步队列中的节点线程就可以被唤醒了。如果线程的计数器没有到达0，那更简单，这个时候其他线程会调用condition的await方法进入等待队列。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里总结下两者的主要区别：</p><ol><li>CountDownLatch用完之后就不能再次使用了，CyclicBarrier用完之后可以再次使用，CyclicBarrier还可以做reset操作</li><li>CountDownLatch底层使用的是共享锁，CyclicBarrier底层使用的是ReentrantLock和这个lock的条件对象Condition</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CountDownLatch和CyclicBarrier都是给予AQS队列同步器实现的共享锁。&lt;/p&gt;
&lt;p&gt;CountDownLatch是单纯通过维持一个state的计数数值，这个数值在线程调用countDownLatch.countDown()的时候会减1，当计数器的值
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>理解Java线程中断</title>
    <link href="http://jianghao.wang/2018/%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/"/>
    <id>http://jianghao.wang/2018/理解Java线程中断/</id>
    <published>2018-03-22T03:09:30.000Z</published>
    <updated>2018-03-22T08:19:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道lock和synchronized在同步运用上的显著区别之一就是lock支持可中断，而synchronized不支持可中断。那么可中断实际上是怎么实现的，或者说我们怎么去理解中断这个概念。在lock的实现ReetrantLock中其实我们可以看到很多中断的运用。我们都知道死锁，作为一种独占的互斥锁，通过中断我们可以保证线程在阻塞的过程中可以响应中断，也就是结束当前线程对cpu的占用，通过向上层抛出异常来结束当前线程。</p><h3 id="ReetrantLock中断的应用"><a href="#ReetrantLock中断的应用" class="headerlink" title="ReetrantLock中断的应用"></a>ReetrantLock中断的应用</h3><p>我们看到ReetrantLock是如何实现中断的，这里主要看到三种中断的运用：</p><h4 id="selfInterrupt"><a href="#selfInterrupt" class="headerlink" title="selfInterrupt()"></a>selfInterrupt()</h4><p>ReetrantLock提供了lock和lockIntteruptibly两种上锁方式，那么他们有什么本质的区别，我们看到lock的一段源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">      acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们分析这段代码，lock默认非公平锁的情况下在tryAcquire(arg)时并不会排队，如果获取不到会去 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)进行排队，如果该方法返回ture则进入线程自我中断。那么我们可以看下这段代码是如何实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())<span class="comment">//这里我们检验了中断标志是否被改变通过currentThread().isInterrupted(true)方法</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 这里的interrupted是我们定义的一个中断变量，可以看到这只是一个临时变量。当我们在队列中循环cas的时候，如果没有收到中断请求，那么最终会在第一组判断内进入并获取到锁，这是的中断标志为false，不中断，那么线程获取到锁之后开始执行同步代码块。但是如果在循环cas获取锁的过程中感知到了中断，中断的标志会被置为true，然后直接返回上层执行selfInterrupt()，我们再看下selfInterrupt()执行了什么操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Convenience method to interrupt current thread.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Thread.currentThread().interrupt();<span class="comment">//当前线程执行自我中断</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>总结：我们可以在获取锁的过程中记录一个临时变量，如果检测到当前执行线程被别的线程进行了某中断操作。将该临时变量置为true然后触发线程的自我中断。</p><h4 id="抛出InterruptedException-异常"><a href="#抛出InterruptedException-异常" class="headerlink" title="抛出InterruptedException()异常"></a>抛出InterruptedException()异常</h4><p>线程在检测到被中断的请求时，不会立即响应这个中断请求，因为它仅仅是改变了中断标示位，但是并不会直接触发中断，是否进行中断还是看当前线程什么时候去检测这个中断标示位。一般在阻塞锁的设计中，我们在循环等待的过程中会进行中断标志位的检测，从而进行InterruptedException()异常的抛出。这个中断异常的过程就好比，你妈妈会交代你好好吃饭，但是具体你是不是要好好吃饭，还是得由你自己决定，也就是我们在设计一个线程的run方法时，同样可以自定义一个volatile类型的中断标志位，来同步记录这个系统的标志位，然后在我们想要抛出异常的时候来检测这个标志位的变化，从而抛出相应的异常。这里看一段lockInterruptibly中的处理：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Acquires in exclusive interruptible mode.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">               <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                   setHead(node);</span><br><span class="line">                   p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                   failed = <span class="keyword">false</span>;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())<span class="comment">//检测到中断标示位被修改为true的时候直接向上层抛出异常。</span></span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="中断的相关方法"><a href="#中断的相关方法" class="headerlink" title="中断的相关方法"></a>中断的相关方法</h3><p>这里记录一下几个关键的调用中断的方法：</p><ul><li>public void interrupt()<br>将调用者线程的中断状态设为true。</li><li>public boolean isInterrupted()<br>判断调用者线程的中断状态。</li><li>public static boolean interrupted<br>只能通过Thread.interrupted()调用。<br>它会做两步操作：返回<strong>当前线程</strong>的中断状态同时将当前线程的中断状态设为false。</li></ul><p>线程通过检查自身是否被中断来进行响应，线程通过方法isInterrupted()来进行判断是否被中断，也可以通过调用静态方法Thread.interrupted()对当前线程的中断标示位进行复位。如果该线程已经处于终结状态，那么即使该线程被中断过，在调用该线程该线程对象的isInterrrupted()时会返回false。</p><p>我们查看java的api可以看到，很多会抛出中断异常的方法都会在抛出异常之前，java虚拟机首先将该线程的中断标示位清除。那么此时我们调用isInterrrupted()时会返回false。</p><h3 id="中断异常代码示例"><a href="#中断异常代码示例" class="headerlink" title="中断异常代码示例"></a>中断异常代码示例</h3><p>我们创建两个线程sleepThread和busyThread，第一个不停的执行休眠，第二个不停的执行循环代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Interrupted;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 3/22/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interrupted</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//新建一个睡眠线程</span></span><br><span class="line">        Thread sleepThread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"sleepThread"</span>);</span><br><span class="line">        <span class="comment">//新建一个忙碌的线程</span></span><br><span class="line">        Thread busyThread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"busyThread"</span>);</span><br><span class="line">        sleepThread.start();</span><br><span class="line">        busyThread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);<span class="comment">//线程休眠十秒</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        sleepThread.interrupt();</span><br><span class="line">        busyThread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"sleepThread的中断标志为："</span>+sleepThread.isInterrupted());</span><br><span class="line">        System.out.println(<span class="string">"busyThread的中断标志为："</span>+busyThread.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果为：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at Interrupted.Interrupted<span class="formula">$1.run(Interrupted.java:14)</span></span><br><span class="line"><span class="formula">at java.lang.Thread.run(Thread.java:745)</span></span><br><span class="line"><span class="formula">sleepThread的中断标志为：false</span></span><br><span class="line"><span class="formula">busyThread的中断标志为：true</span></span><br></pre></td></tr></table></figure><p>可以看到，抛出异常的线程的中断标示位被清除了，但是一直忙碌的线程因为并没有去判断中断标示位，所以即使中断标示位已经是true也不会执行中断操作。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>线程中断是一种是可以理解为一个线程对另一个线程做出了一个标示位的改变，通过触发线程中断会将中断标示位置为true，被中断的线程可以选择忽略这个标志，也可以选择在某个时刻校验标志位抛出异常，同时将标志位清除。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道lock和synchronized在同步运用上的显著区别之一就是lock支持可中断，而synchronized不支持可中断。那么可中断实际上是怎么实现的，或者说我们怎么去理解中断这个概念。在lock的实现ReetrantLock中其实我们可以看到很多中断的运用。我们
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>ReetrantLock实现源码</title>
    <link href="http://jianghao.wang/2018/ReetrantLock%E5%AE%9E%E7%8E%B0%E6%BA%90%E7%A0%81/"/>
    <id>http://jianghao.wang/2018/ReetrantLock实现源码/</id>
    <published>2018-03-19T12:52:17.000Z</published>
    <updated>2018-03-21T09:21:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>ReetrantLock是基于AQS（AbtractQueuedSynchronizer）实现的。本文将逐渐展开分析ReetrantLock的实现机制以及使用场景。</p><h3 id="AQS实现源码"><a href="#AQS实现源码" class="headerlink" title="AQS实现源码"></a>AQS实现源码</h3><p> AQS提供了一个框架，用于实现阻塞锁和相关的同步器(semaphores, events等)，它们依赖于先入先出(FIFO)等待队列。这个类被设计成大多数类型的同步器的基础，它们依赖于单个原子<strong>{@ code int}</strong>值来表示同步状态。子类必须定义更改此状态的受保护方法（重写相关的方法），并重新定义该状态值在实现类中的定义。考虑到这些，这个类中的其他方法需要控制所有队列的进出和阻塞机制。子类可以维护其他的状态字段，但是只有通过使用方法<strong>{@ link # get state}、{@ link # set state}和{@ link # compare和set state}</strong>的原子更新<strong>{@ code int}</strong>值，才会对同步进行跟踪。</p><p>AQS框架要么支持默认的独占模式，要么支持共享模式。当以独占模式获得时，试图通过其他线程获取的尝试无法成功。多个线程的共享模式可以(但不需要)成功。共享模式获得成功时，下一个等待线程(如果存在)还必须确定它是否也能获得。在不同模式中等待的线程共享相同的FIFO队列。通常，实现子类只支持其中一种模式，但都可以在<strong>{@ link Read Write Lock}</strong>中发挥作用。支持唯一或仅共享模式的子类不必定义支持未使用模式的方法。本文分析的ReetrantLock是一种独占模式的实现，同一时间只能有一个线程执行同步代码块，其它线程将被阻塞在队列中，等待state也就是锁释放之后从队列中释放出来执行代码块。</p><h4 id="AQS的使用"><a href="#AQS的使用" class="headerlink" title="AQS的使用"></a>AQS的使用</h4><p>使用这个类作为一个同步器的基础，通过state的暴露方法来同步修改状态，同时需要定义下列方法：</p><ul><li><strong>{@link #tryAcquire}</strong>，获取锁，cas修改state状态。</li><li><strong>{@link #tryRelease}</strong>，释放锁，修改state状态同时将线程移除队列。</li><li><strong>{@link #tryAcquireShared}</strong>，获取共享锁。</li><li><strong>{@link #tryReleaseShared}</strong>，释放共享锁。</li><li><strong>{@link #isHeldExclusively}</strong>，锁是否被独占。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> Acquire:</span><br><span class="line">     <span class="keyword">while</span> (!tryAcquire(arg)) &#123;</span><br><span class="line">        &lt;em&gt;enqueue thread if it is not already queued&lt;/em&gt;;</span><br><span class="line">        &lt;em&gt;possibly block current thread&lt;/em&gt;;</span><br><span class="line">     &#125;</span><br><span class="line"> Release:</span><br><span class="line">     <span class="keyword">if</span> (tryRelease(arg))</span><br><span class="line">        &lt;em&gt;unblock the first queued thread&lt;/em&gt;;</span><br><span class="line"> &lt;/pre&gt;</span><br><span class="line">(Shared mode is similar but may involve cascading signals.)</span><br></pre></td></tr></table></figure><p>这里给一个独占锁的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Our internal helper class</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Reports whether in locked state</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Acquires the lock if state is zero</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Releases the lock by setting state to zero</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">      <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">      setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">      setState(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Provides a Condition</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject(); &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Deserializes properly</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">      s.defaultReadObject();</span><br><span class="line">      setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// The sync object does all the hard work. We just forward to it.</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>                </span>&#123; sync.acquire(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>          </span>&#123; <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>              </span>&#123; sync.release(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> sync.newCondition(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span>         </span>&#123; <span class="keyword">return</span> sync.isHeldExclusively(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sync.hasQueuedThreads(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="AQS队列同步器提供的接口分析"><a href="#AQS队列同步器提供的接口分析" class="headerlink" title="AQS队列同步器提供的接口分析"></a>AQS队列同步器提供的接口分析</h4><p>同步器提供的可供重写的方法：</p><table><thead><tr><th style="text-align:center">方法名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">protected int tryAcquireShared(int arg)</td><td style="text-align:left">共享式获取同步状态，返回&gt;=0的值，表示获取成功，反之获取失败。</td></tr><tr><td style="text-align:center">protected boolean tryReleaseShared(int arg)</td><td style="text-align:left">共享式释放同步状态。</td></tr><tr><td style="text-align:center">protected boolean isHeldExclusively()</td><td style="text-align:left">当前同步器是否在独占模式下被线程占用，一般实现会判断当前线程是否独占锁。</td></tr><tr><td style="text-align:center">protected boolean tryAcquire(int arg)</td><td style="text-align:left">独占式获取锁，该方法为获取锁操作方法。公平锁和非公平锁有不同的实现，非公平锁直接调用同步器底层实现。公平锁会先判断当前队列是否有线程在等待锁。</td></tr><tr><td style="text-align:center">protected  boolean tryRelease(int arg)</td><td style="text-align:left">独占式释放同步锁，其它队列中等待的线程将有机会获取到锁。</td></tr></tbody></table><p>我们可以根据这些可以重写的方法去自定义同步组件，类似公平锁和非公平锁的定义，实际上是对FairSync和NonfairSync对Sync的tyAcquire方法进行了不同的实现。另外队列同步器还提供了一些模板方法：</p><table><thead><tr><th style="text-align:center">方法名称</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">void acquire(int arg)</td><td>独占式获取同步状态，如果获取同步状态成功，进入同步块否则进入等待队列，然后开始循环等待当前线在等待队列中获取到锁，只会记录中断状态不会触发中断。这个方法会调用到tryAcquire方法，可以被自定义同步器重写。</td></tr><tr><td style="text-align:center">boolean tryAccquireNano(int arg,long nanos)</td><td>增加了超时时间限制，如果当前线程在限制的时间内没有获取到锁的话就返回false,否则返回true。</td></tr><tr><td style="text-align:center">void accqureInrruptibly(int arg)</td><td>支持中断模式，当前在，相较于acquire方法该方法同样会进行循环等待队列中获取到锁。但是当它可以响应中断，当其他线程中断当前线程的时候，会抛出InterruptException异常。</td></tr><tr><td style="text-align:center">Collection<thread> getQueuedThreads()</thread></td><td>获取等待在同步队列上的线程集合。</td></tr><tr><td style="text-align:center">boolean tryAccquireSharedNano(int arg,long nanos)</td><td>同样的，我们为该方法在共享锁的前提下增加了超时时间。</td></tr><tr><td style="text-align:center">void acquireShared(int arg)</td><td>共享式获取同步状态，主要区别于独占式获取同步状态，这种方式的特别之处在于同一时间可以有多个线程获得同步状态。</td></tr><tr><td style="text-align:center">void accqureSharedInrruptibly(int arg)</td><td>该方法响应中断。</td></tr><tr><td style="text-align:center">void releasShared(int arg)</td><td>共享锁释放同步状态。</td></tr></tbody></table><p>队列同步器的方法主要分为三类：</p><ul><li><strong>独占式获取与释放同步状态</strong></li><li><strong>共享式获取与释放同步状态</strong></li><li><strong>查询同步队列中线程的等待情况</strong></li></ul><p>同样的，我们提供一个共享锁的实例，类似java.util.concurrent.CountDownLatch CountDownLatch的一种实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSignalled</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> getState() != <span class="number">0</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> ignore)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> isSignalled() ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> ignore)</span> </span>&#123;</span><br><span class="line">      setState(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSignalled</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sync.isSignalled(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span>         </span>&#123; sync.releaseShared(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="ReetrantLock主要方法"><a href="#ReetrantLock主要方法" class="headerlink" title="ReetrantLock主要方法"></a>ReetrantLock主要方法</h3><p>我们通常会用定义一个ReetrantLock，通过调用lock方法和unlock方法来对同步代码块进行加锁和释放锁。我们先来看一下lock方法的调用栈。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment">    * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment">    * given fairness policy.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">       sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看到ReetrantLock提供了两种构造方法，一种会默认初始化一个非公平锁，另一个可以指定公平锁或者非公平锁。公平锁和非公平锁中都有对应的加锁和释放锁实现。观察调用栈可以看到两者的区别。</p><h4 id="lock方法调用公平锁和非公平锁"><a href="#lock方法调用公平锁和非公平锁" class="headerlink" title="lock方法调用公平锁和非公平锁"></a>lock方法调用公平锁和非公平锁</h4><p>我们可以通过源代码看到公平锁和非公平锁的实现都继承了Sync类，实际上这个类是对AQS类的一种独占锁的实现。所以我们最终实现的ReetrantLock是独占的，可重入的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Sync object for non-fair locks</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">        * acquire on failure.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))<span class="comment">//非公平锁调用时就会给一次竞争的机会，如果后来的线程刚好在锁释放的时候去获取锁，那么即使等待队列中还有其它的线程也会被直接忽略，这样的话对队列中等待的线程是不公平的。</span></span><br><span class="line">               setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               acquire(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> nonfairTryAcquire(acquires);<span class="comment">//实际上是直接调用了AQS中的nonfairTryAcquire(acquires)方法。这个方法是不会维持一个等待竞争锁的线程队列的。</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>再看下公平锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sync object for fair locks</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            acquire(<span class="number">1</span>);<span class="comment">//公平锁线程在获取锁的时候直接加入队列，等待前面的线程被执行完之后顺序调用。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">         * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们在进入acquire方法，可以看到非公平锁实际上是直接调用的Sync中nonfairTryAcquire的实现，源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<span class="comment">//ReetrantLock是可重入锁，同一个线程可以再次进入，但是会将state作累加。</span></span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>而公平锁调用的是自己实现的tryAcquire(int acquires)方法，上面关于公平锁的静态类中可以看到。对比之后发现公平锁在判断的时候多了一句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<span class="comment">//这个增加的判断也是保证公平</span></span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;<span class="comment">//这里是通过cas去写state的状态也就是去占用锁</span></span><br><span class="line">                    setExclusiveOwnerThread(current);<span class="comment">//成功获取锁之后记录独占锁线程为当前线程</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>hasQueuedPredecessors()的实现如下，如果当前线程在队列中还有前置线程返回true，不获得准入条件。如果当前线程处于队列的头部，或者队列为空，则返回false，获得准入条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @return &#123;@code true&#125; if there is a queued thread preceding the</span></span><br><span class="line"><span class="comment">     *         current thread, and &#123;@code false&#125; if the current thread</span></span><br><span class="line"><span class="comment">     *         is at the head of the queue or the queue is empty</span></span><br><span class="line"><span class="comment">     * @since 1.7</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">        <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">        <span class="comment">// thread is first in queue.</span></span><br><span class="line">        Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结一下，公平锁和非公平锁相比，保证了FIFO的原则，但是代价是进行了大量的线程切换。而非公平锁虽然可能造成线程 “饥饿”，但是极少的线程切换，同样也保证了更大的吞吐量。</p><h3 id="tryLock-方法和lock方法"><a href="#tryLock-方法和lock方法" class="headerlink" title="tryLock()方法和lock方法"></a>tryLock()方法和lock方法</h3><p>看一下tryLock()方法，实际上调用Sync的nonfairTryAcquire方法，该方法相较于lock方法精简了一些。对比，一下，少了一段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<span class="comment">//这里如果获取失败会尝试将线程加入等待队列</span></span><br><span class="line">         selfInterrupt();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>tryLock()方法默认是非公平方式去调用的，只是一次简单的cas加锁尝试。如果失败了线程不会再被执行，拥有再次竞争锁的机会。</li><li>lock()方法的非公平方式如果获取锁失败会将当前线程加入等待队列。如果失败了线程等待之后还有再次获得锁的机会。</li></ul><p>这样public boolean tryLock(long timeout, TimeUnit unit)，这个方法也就更容易理解了，增加了一个timeout时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));<span class="comment">//默认unit.toNanos(timeout)时间内超时，首先会将这个线程加入队列，然后进行循环自旋，如果时间内线程没有排到队首，会返回一个false。</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>sync.tryAcquireNanos(1, unit.toNanos(timeout))，该方法具体实现如下，咋一看代码很容易将其误认为是在时间段内不断cas自旋去获取锁，如果时间内失败返回false。实际上是会将当前的线程加入等待队列的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);<span class="comment">//会将该线程作为一个node加入到等待队列。Node.EXCLUSIVE定义为独占模式。</span></span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;<span class="comment">//这里开始循环等待加入的线程排到队首，可能会在时间段内排到也可能排不到。</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面是addWaiter(Node mode)，就是生成一个独占的线程节点加入到等待队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">       Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">       <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">       Node pred = tail;</span><br><span class="line">       <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">           node.prev = pred;</span><br><span class="line">           <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">               pred.next = node;</span><br><span class="line">               <span class="keyword">return</span> node;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       enq(node);</span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="unlock方法释放锁"><a href="#unlock方法释放锁" class="headerlink" title="unlock方法释放锁"></a>unlock方法释放锁</h4><p>调用unlock方法，实际上调用的是AQS中的release(1)方法，这个只会把state的值-1，源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中tryRelease(arg)方法执行如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">  <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">  <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//如果当前state保留的值已经变为零，锁释放成功</span></span><br><span class="line">    free = <span class="keyword">true</span>;</span><br><span class="line">    setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  setState(c);</span><br><span class="line">  <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="InterruptedException可中断获取锁"><a href="#InterruptedException可中断获取锁" class="headerlink" title="InterruptedException可中断获取锁"></a>InterruptedException可中断获取锁</h4><p>ReetrantLock提供了一种可中断获取锁的方式，也是实现了定义在lock中的接口，该方法很容易理解，在获取锁的过程中会响应中断，那么这种方式和普通的lock方式有什么本质区别。我们看一下这种方式的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Acquires in exclusive interruptible mode.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">      <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">              <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                  setHead(node);</span><br><span class="line">                  p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                  failed = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                  parkAndCheckInterrupt())</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();<span class="comment">//这里会响应中断，会直接抛异常给上层，在lock中只是维护了一个状态值，进行了状态值的修改，并不会跑出异常到上层。最终回返回false</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (failed)</span><br><span class="line">              cancelAcquire(node);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>结论：ReentrantLock的中断和非中断加锁模式的区别在于：线程尝试获取锁操作失败后，在等待过程中，如果该线程被其他线程中断了，它是如何响应中断请求的。lock方法会忽略中断请求，继续获取锁直到成功；而lockInterruptibly则直接抛出中断异常来立即dsa响应中断，由上层调用者处理中断。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要对ReetrantLock的源码进行了一些分析，ReetrantLock是基于AQS实现的一种独占，可重入的锁，可以自己的定义公平锁或者非公平锁。ReetrantLock通过维护AQS类内部的一个volatile state变量来记录锁的状态，通过cas去竞争，同时记录当前持有锁的线程。支持可重入，当当前持有该锁的线程尝试再次进入的时候会通过准入条件，并将state增加1。实际上公平锁和非公平锁主要是当前线程是否会进入线程等待的队列，AQS在底层维护了一个线程的等待队列，基于先进先出的原则去调度这些等待获取锁的队列。如果非公平锁的话直接调用lock去加锁，可能面临失败的情况，如果失败了，就是一次cas自旋失败，同步代码块并不会被执行。如果用trylock方法的话可以尝试增加一个超时时间，会将当前的线程加入到等待队列中然后在超市时间内等待被调度，这种场景在某些情况下还是很适用的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ReetrantLock是基于AQS（AbtractQueuedSynchronizer）实现的。本文将逐渐展开分析ReetrantLock的实现机制以及使用场景。&lt;/p&gt;
&lt;h3 id=&quot;AQS实现源码&quot;&gt;&lt;a href=&quot;#AQS实现源码&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>AtomicInteger源码分析</title>
    <link href="http://jianghao.wang/2018/AtomicInteger%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://jianghao.wang/2018/AtomicInteger源码分析/</id>
    <published>2018-03-16T10:23:32.000Z</published>
    <updated>2018-03-16T10:23:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>在阅读ConcurrentHashMap源码的过程中，频繁使用了volatile+无锁的方式来处理并发，需要对AtomicInteger源码有更深的了解。将这个模块独立抽离出来形成更深刻的理解。</p><h3 id="AutomicInteger变量"><a href="#AutomicInteger变量" class="headerlink" title="AutomicInteger变量"></a>AutomicInteger变量</h3><p>AutomicInteger作为一个原子操作类，定义了一些变量：</p><ul><li><p>private static final Unsafe unsafe = Unsafe.getUnsafe()，定义了一个usafe类对象，主要对native方法进行调用。</p></li><li><p>private static final long valueOffset，这个值可能会被误以为是默认值，查看部分源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>了解过java虚拟机类加载机制的，类加载触发的其中一个条件是getstatic，这样其他方法在每次访问到这个值的时候都会执行一下静态代码块获取到内存中最新的值。这个值是作为内存中的值，我们在编写程序的时候会存一份拷贝在栈中，通过对比这个值和拷贝值是否一致来决定是否更新新值到内存，也就是这次操作是否成功。</p></li><li><p>private volatile int value，上面通过静态代码块儿去加载的就是内存中value的最新值。</p></li></ul><h3 id="AutomicInteger原子操作"><a href="#AutomicInteger原子操作" class="headerlink" title="AutomicInteger原子操作"></a>AutomicInteger原子操作</h3><p>这里我们通过自己写复杂操作count++对比通过调用AutomicInteger的api，可以对比结果是否保证了正确的输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CasNoLock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 3/16/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger atomicInteger=<span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Thread&gt; threadArrayList=<span class="keyword">new</span> ArrayList&lt;Thread&gt;(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5000</span>;i++)&#123;</span><br><span class="line">                        count();</span><br><span class="line">                        countAtomicInteger();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threadArrayList.add(thread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Thread t:threadArrayList)&#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Thread t:threadArrayList)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"非原子操作累加结果："</span>+count);</span><br><span class="line">        System.out.println(<span class="string">"原子操作累加结果："</span>+atomicInteger.intValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非原子类操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原子类操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countAtomicInteger</span><span class="params">()</span></span>&#123;</span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">非原子操作累加结果：461539</span><br><span class="line">原子操作累加结果：50000</span><br></pre></td></tr></table></figure><h3 id="AutomicInteger-API分析"><a href="#AutomicInteger-API分析" class="headerlink" title="AutomicInteger API分析"></a>AutomicInteger API分析</h3><p>我们查看下atomicInteger.getAndIncrement()在usafe中的实现，实际上它是调用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 查看getAndAddInt方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>compareAndSwapInt(var1, var2, var5, var5 + var4)</strong>换成<strong>compareAndSwapInt(obj, offset, expect, update)</strong>比较清楚，意思就是如果<code>obj</code>内的<code>value</code>和<code>expect</code>相等，就证明没有其他线程改变过这个变量，那么就更新它为<code>update</code>，如果这一步的<code>CAS</code>没有成功，那就采用自旋的方式继续进行<code>CAS</code>操作，取出乍一看这也是两个步骤了啊，其实在<code>JNI</code>里是借助于一个<code>CPU</code>指令完成的。所以还是原子操作。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>AutomicInteger源码最终是通过<strong>usafe.compareAndSwapInt(obj, offset, expect, update)</strong>函数实现cas原子操作的。cas中最重要的三个值，volatile value（内存中最新值），expect（拷贝值）和update（更新值），在函数中分别对应offset，expect，和update入参。对这个关键方法的了解可以帮助深入阅读ConcurrentHashMap源码，jdk1.8中大量运用cas+synchronized关键字来实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在阅读ConcurrentHashMap源码的过程中，频繁使用了volatile+无锁的方式来处理并发，需要对AtomicInteger源码有更深的了解。将这个模块独立抽离出来形成更深刻的理解。&lt;/p&gt;
&lt;h3 id=&quot;AutomicInteger变量&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap实现源码</title>
    <link href="http://jianghao.wang/2018/ConcurrentHashMap%E5%AE%9E%E7%8E%B0%E6%BA%90%E7%A0%81/"/>
    <id>http://jianghao.wang/2018/ConcurrentHashMap实现源码/</id>
    <published>2018-03-16T07:24:07.000Z</published>
    <updated>2018-06-20T02:29:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>在阅读源码的过程中，推荐一个idea的翻译插件<a href="https://github.com/YiiGuxing/TranslationPlugin" target="_blank" rel="noopener">TranslationPlugin</a>，方便阅读源码的注释。本篇主要介绍ConcurrentHashMap在JDK1.8中的实现。</p><h3 id="ConcurrentHashMap静态常量"><a href="#ConcurrentHashMap静态常量" class="headerlink" title="ConcurrentHashMap静态常量"></a>ConcurrentHashMap静态常量</h3><p>ConcurrentHashMap在设计的过程中涉及到扩容和容器收缩等策略，在静态常量中定义了一些比较关键的阈值，这里介绍几个主要的：</p><ul><li><p>private static final int DEFAULT_CAPACITY=16，默认表大小，默认初始化的时候没有传递capacity和concurrentlevel会提供16个hash桶进行映射。否则会根据capacity或者concurrentlevel来确定size的值。</p></li><li><p>private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30，最大表容量，扩容时会判断最大容量。</p></li><li><p>static final int MIN_TREEIFY_CAPACITY = 64，链表树化时的最小表（数组）容量。在列表树化的时候会检测当前的表（数组）容量，如果小于这个数值会首先进行扩容，扩容之后再进行树化。n为表（数组）长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">              tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>private static final float LOAD_FACTOR = 0.75f，装载因子，当数组中已经映射的hash桶已经达到百分之75以上时会自动扩容。代码中可以用 <strong>{@code n - (n &gt;&gt;&gt; 2)}</strong>代替运算，n为表（数组）的长度。</p></li><li><p>static final int TREEIFY_THRESHOLD = 8，链表调整为tree阈值。当链表中的节点数量超过这个数值的时候会调整为树结构。这个数量至少为2最好是大于8。</p></li><li><p>static final int UNTREEIFY_THRESHOLD = 6，当链表的长度小于这个值的时候自动调节树结构为列表结构。</p></li></ul><h3 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h3><p>分析一下数组的扩容方法tryPresize，源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tries to presize table to accommodate the given number of elements.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> size number of elements (doesn't need to be perfectly accurate)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">     <span class="comment">//判断是否为最大超过最大容量的八倍，超过了直接扩容到最大容量。最大容量为1&lt;&lt;30</span></span><br><span class="line">           tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">     <span class="comment">//这里只需要提供一个大概的size，tableSizeFor函数会根据当前的size值匹配一个最近的表大小值，因为我们规定表的大小只能是2的倍数（为了保证在取模进行hash运算的时候可以用（hashcode &amp; n-1） ）</span></span><br><span class="line">       <span class="keyword">int</span> sc;</span><br><span class="line">       <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;</span><br><span class="line">           <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="comment">//如果当前table并没有被初始化，例如在putAll方法中传入一个map，首先进行table的初始化tab</span></span><br><span class="line">               n = (sc &gt; c) ? sc : c;</span><br><span class="line">               <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                 <span class="comment">//这里采用了循环cas来替换sc的值，最后将sizeCtl赋值为sc的值</span></span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                           <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                           Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                           table = nt;</span><br><span class="line">                           sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                       sizeCtl = sc;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">               <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">               <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                   Node&lt;K,V&gt;[] nt;</span><br><span class="line">                   <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                       sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                       transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                       transfer(tab, nt);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                   transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>再看一下主要的putVal方法，源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">int</span> hash = spread(key.hashCode());<span class="comment">//获取hash映射桶，对hashcode做了扰动保证散列的均匀度</span></span><br><span class="line">       <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">           Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">           <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">               tab = initTable();<span class="comment">//如果当前未被初始化过，进行初始化。</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                            <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                   <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin,采用无锁的方式，如果无锁置换成功就直接break出循环，代表成功插入。如果失败，表明有竞争发生，继续执行后续代码，会进行插入。</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)<span class="comment">//表明当前表正在进行扩容。检测到当前映射节点正在进行扩容的时候，当前线程加入帮忙进行扩容工作。</span></span><br><span class="line">               tab = helpTransfer(tab, f);</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               V oldVal = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">synchronized</span> (f) &#123;<span class="comment">//相当于锁住一条链表，这里有一个偏向锁到轻量级锁到重量级锁的升级过程</span></span><br><span class="line">                   <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                           binCount = <span class="number">1</span>;</span><br><span class="line">                           <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                               K ek;</span><br><span class="line">                               <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                   ((ek = e.key) == key ||</span><br><span class="line">                                    (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                   oldVal = e.val;</span><br><span class="line">                                   <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                       e.val = value;</span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                               Node&lt;K,V&gt; pred = e;</span><br><span class="line">                               <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                   pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                             value, <span class="keyword">null</span>);</span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) <span class="comment">//如果已经被树化，以红黑树的方式增加一个节点。</span></span><br><span class="line">                           Node&lt;K,V&gt; p;</span><br><span class="line">                           binCount = <span class="number">2</span>;</span><br><span class="line">                           <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                          value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                               oldVal = p.val;</span><br><span class="line">                               <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                   p.val = value;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<span class="comment">//如果达到树化的阈值，将链表进行树化。</span></span><br><span class="line">                       treeifyBin(tab, i);</span><br><span class="line">                   <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                       <span class="keyword">return</span> oldVal;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    从ConcurrentHashMap的多个版本演变中，最终java9采用了synchronized和cas来实现，之后会抽写一篇对几种版本迭代过程中性能的优异比较。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在阅读源码的过程中，推荐一个idea的翻译插件&lt;a href=&quot;https://github.com/YiiGuxing/TranslationPlugin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TranslationPlugin&lt;/a&gt;，方便阅读
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>面试记录</title>
    <link href="http://jianghao.wang/2018/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <id>http://jianghao.wang/2018/面试记录/</id>
    <published>2018-03-14T10:24:15.000Z</published>
    <updated>2018-03-14T10:25:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>面试需要手写一段死锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SynchronizedLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 3/14/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MythreadA</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    Object a;</span><br><span class="line">    Object b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MythreadA</span><span class="params">(Object a,Object b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a=a;</span><br><span class="line">        <span class="keyword">this</span>.b=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (a)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程A正在等待获取下个对象的锁，已经获取到对象锁："</span>+a);</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (b)&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程A同时获取到对象A和B的锁"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>触发线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SynchronizedLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 3/14/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedLockMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object a=<span class="keyword">new</span> Object();</span><br><span class="line">        Object b=<span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MythreadA(a,b)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MythreadA(b,a)).start();<span class="comment">//调换一下ab顺序保证死锁发生的条件，否则不会发生死锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面试需要手写一段死锁：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/sp
      
    
    </summary>
    
    
      <category term="面试记录" scheme="http://jianghao.wang/tags/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Java位操作</title>
    <link href="http://jianghao.wang/2018/Java%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    <id>http://jianghao.wang/2018/Java位操作/</id>
    <published>2018-03-13T11:56:58.000Z</published>
    <updated>2018-03-14T01:56:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>在阅读源码的过程中，发现很多地方会使用到位操作来提高计算的效率。我们很常见的取模操作，在源码中都会通过与操作来完成。了解和灵活运用位运算可以帮助我们快速理解源码，写出较为简洁的代码。</p><h3 id="位操作运算符"><a href="#位操作运算符" class="headerlink" title="位操作运算符"></a>位操作运算符</h3><p>针对二进制位操作运算符主要包括：</p><ul><li>与操作（&amp;），1&amp;1才为1，其它都为0.</li><li>非操作（～），简单取反.</li><li>或操作（|），当两边操作数的位有一边为1时,结果为1,否则为0.</li><li>异或操作（^），参与运算的两个值,如果两个相应位相同,则结果为0,否则为1.</li></ul><p>二进制位移动运算符：</p><ul><li>有符号的右移位运算符（&gt;&gt;），使指定值的所有位都向右移规定的次数.正数在高位插入0,负数则在高位插入1. 右移一位相当于除2, 右移n位相当于除以2的n次方.</li><li>有符号的左移动运算符（&lt;&lt;），使指定值的所有位都向左移规定的次数, 丢弃最高位, 在低位补0. 在数字没有溢出的前提下,对于正数和负数, 左移一位都相当于乘以2的1次方, 左移n位就相当于乘以2的n次方.</li><li>无符号的右移位运算符（&gt;&gt;&gt;），忽略了符号位扩展,无论正负,都在高位插入0.</li></ul><h3 id="位操作的应用"><a href="#位操作的应用" class="headerlink" title="位操作的应用"></a>位操作的应用</h3><h4 id="取模操作"><a href="#取模操作" class="headerlink" title="取模操作"></a>取模操作</h4><p>这里截取一段hash算法根据hashcode得到映射桶的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)<span class="comment">//这里的判断先映射到了table的某个桶</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>hashmap在插入元素的时候会首先根据hashcode确定映射到某个桶，注释处采用的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure><p>相当于操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash % (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这里需要注意的是，hash在扩容的都是以2的整数倍进行扩容，也就是为什么hashmap的数组长度要取2的整数次幂。因为这样（数组长度减1）正好相当于一个”低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值。以初始长度16为例，16-1=15。二进制表示为00000000 00000000 00001111。这样和某散列值进行与操作的结果如下，截取了最低的四位值，完成了取模的操作：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10100101 11000100 00100101</span><br><span class="line">&amp;  00000000 00000000 00001111</span><br><span class="line">-----------------------------------</span><br><span class="line">        00000000 00000000 00000101 //高位全部归零，只保留最后四位</span><br></pre></td></tr></table></figure><p>当然二进制&amp;的计算效率是要远远大于十进制%的计算效率。</p><h4 id="交换数字"><a href="#交换数字" class="headerlink" title="交换数字"></a>交换数字</h4><p>一般进行数字交换的操作我们会定义一个中间变量，作为交换的中转站。如果通过异或操作来进行可以省略中间变量的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 数a两次异或同一个数b(a=a^b^b)仍然为原值.*/</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">666</span>;</span><br><span class="line"></span><br><span class="line">        a = a ^ b;</span><br><span class="line">        b = b ^ a;</span><br><span class="line">        a = a ^ b;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"a: "</span> + a + <span class="string">" b "</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a: 666 b 100</span><br></pre></td></tr></table></figure><p><strong>数a两次异或同一个数b(a=a^b^b)仍然为原值.</strong></p><h3 id="HashMap扰动函数"><a href="#HashMap扰动函数" class="headerlink" title="HashMap扰动函数"></a>HashMap扰动函数</h3><p>这里我们分析一段HashMap的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class="line"><span class="comment">     * to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class="line"><span class="comment">     * hashes that vary only in bits above the current mask will</span></span><br><span class="line"><span class="comment">     * always collide. (Among known examples are sets of Float keys</span></span><br><span class="line"><span class="comment">     * holding consecutive whole numbers in small tables.)  So we</span></span><br><span class="line"><span class="comment">     * apply a transform that spreads the impact of higher bits</span></span><br><span class="line"><span class="comment">     * downward. There is a tradeoff between speed, utility, and</span></span><br><span class="line"><span class="comment">     * quality of bit-spreading. Because many common sets of hashes</span></span><br><span class="line"><span class="comment">     * are already reasonably distributed (so don't benefit from</span></span><br><span class="line"><span class="comment">     * spreading), and because we use trees to handle large sets of</span></span><br><span class="line"><span class="comment">     * collisions in bins, we just XOR some shifted bits in the</span></span><br><span class="line"><span class="comment">     * cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class="line"><span class="comment">     * to incorporate impact of the highest bits that would otherwise</span></span><br><span class="line"><span class="comment">     * never be used in index calculations because of table bounds.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里是桶映射的方法函数，针对上面取模操作的介绍，为什么还要对hashcode进行一个这样操作，为什么不直接进行散列？</p><p>这里想象一下hashcode是一个32位数，只保留最后几位的取模操作，碰撞是会相当严重的。而且我们在设计hashcode的时候不能保证是规律分布，很有可能在呈四位的跳跃状，那么很有可能会造成严重的碰撞。这样的话就很蛋疼了，这样的散列是没有任何价值的。那么我们就需要进行高低位的扰动：</p><p><img src="http://arthornye.github.io/images/raoluan.png" alt="cmd-markdown-logo"></p><p>右移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始hash码的高位和低位这样来加大低位的随机性。从而减少碰撞的概率。实验显示，当hashmap数组的长度为512的时候好，也就是用掩码取低9位的时候，在没有扰动函数的情况下发生了103次碰撞，接近百分之三十。在使用了扰动函数之后只有92次碰撞。碰撞减少了将近百分之十。</p><p>Java8只做了一次扰动，一般也可以考虑做多次的扰动，但是可能考虑到效率原因改成了一次。</p><h3 id="INT十进制转换为二进制"><a href="#INT十进制转换为二进制" class="headerlink" title="INT十进制转换为二进制"></a>INT十进制转换为二进制</h3><p>做一段测试代码的小记录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 3/13/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapStudy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">char</span>[] digits=&#123;<span class="string">'0'</span>,<span class="string">'1'</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map=<span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        String testString=<span class="string">"t3"</span>;</span><br><span class="line">        System.out.println(<span class="string">"t3的hashCode为："</span>+testString.hashCode());</span><br><span class="line">        System.out.println(testString.hashCode() ^ testString.hashCode()&gt;&gt;&gt;<span class="number">16</span>);</span><br><span class="line">        System.out.println(<span class="number">173412366</span> ^ <span class="number">8</span>);</span><br><span class="line">        System.out.println(<span class="number">12</span> &amp; <span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="number">12</span> % <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(convertIntToBinary(-<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将int类型转换为二进制字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">convertIntToBinary</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] buf=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">32</span>];<span class="comment">//int为4个Byte，32bit</span></span><br><span class="line">        <span class="keyword">int</span> pos=<span class="number">32</span>;</span><br><span class="line">        <span class="keyword">int</span> mask=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            buf[--pos]= digits[i &amp; mask];</span><br><span class="line">            i &gt;&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pos&gt;<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> String(buf,pos,<span class="number">32</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要解决自己在阅读HashMap源码过程中碰到的一些疑惑，进行记录，接下来将会介绍HashMap相关的源码实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在阅读源码的过程中，发现很多地方会使用到位操作来提高计算的效率。我们很常见的取模操作，在源码中都会通过与操作来完成。了解和灵活运用位运算可以帮助我们快速理解源码，写出较为简洁的代码。&lt;/p&gt;
&lt;h3 id=&quot;位操作运算符&quot;&gt;&lt;a href=&quot;#位操作运算符&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OpenClover提高ut覆盖率</title>
    <link href="http://jianghao.wang/2018/OpenClover%E6%8F%90%E9%AB%98ut%E8%A6%86%E7%9B%96%E7%8E%87/"/>
    <id>http://jianghao.wang/2018/OpenClover提高ut覆盖率/</id>
    <published>2018-03-09T08:59:15.000Z</published>
    <updated>2018-03-09T10:14:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>代码的单元测试覆盖率是衡量代码质量的标准之一，保证一定的ut覆盖率可以帮助提高开发人员的项目提测质量。本文将介绍如何在idea下利用openclover插件提高ut覆盖率。</p><h3 id="安装idea插件"><a href="#安装idea插件" class="headerlink" title="安装idea插件"></a>安装idea插件</h3><h4 id="Atlassian-Clover-for-IDEA"><a href="#Atlassian-Clover-for-IDEA" class="headerlink" title="Atlassian Clover for IDEA"></a>Atlassian Clover for IDEA</h4><p>从ItelliJ IDEA —&gt;Preference—&gt;plugins，idea中有自带的插件可供安装，我们可以搜索到该插件。点击安装之后成功之后我们发现该插件需要舒服注册码license。并且我们根据引导无法从Atlassian获取到对应的注册码。感谢国际友人，在一个论坛上发现该插件已经开源，我们可以通过导入插件的方式安装。</p><p><img src="http://arthornye.github.io/images/OpenClover/cloverage.png" alt="cmd-markdown-logo"></p><h4 id="OpenClover-for-IDEA"><a href="#OpenClover-for-IDEA" class="headerlink" title="OpenClover for IDEA"></a>OpenClover for IDEA</h4><p>1.进入OpenClover官网，根据<a href="http://openclover.org/doc/manual/4.2.0/idea--installation-guide.html" target="_blank" rel="noopener">快速开始OpenClover for IDEA</a>我们将下载到的jar包直接导入到idea下，ItelliJ IDEA —&gt;Preference—&gt;plugins—&gt;Install plugin from disk，如下图：</p><p>​        <img src="http://arthornye.github.io/images/OpenClover/openclover.png" alt="cmd-markdown-logo"></p><p>2.点击View -&gt; Toolbar显示插件按钮，如下图：</p><p><img src="http://arthornye.github.io/images/OpenClover/toolbar.png" alt="cmd-markdown-logo"></p><p>3.通过Preference—&gt;Build,Execution,Deployment—&gt;Clover setting(global settings)—&gt;Clover setting(project setting)我们可以进行一些插件的设置，如下图：</p><p><img src="http://arthornye.github.io/images/OpenClover/view.png" alt="cmd-markdown-logo"></p><h3 id="单元测试覆盖"><a href="#单元测试覆盖" class="headerlink" title="单元测试覆盖"></a>单元测试覆盖</h3><p>一般在开发过程中，开发会对dao层和service层进行基本的单元测试回归保证代码的交付质量，当然单元测试可能并没有覆盖到代码的全部情况。单元测试覆盖需要尽可能覆盖到我们的代码。在使用插件的过程中我们可以看到一张覆盖率的图表：</p><p>​        <img src="http://arthornye.github.io/images/OpenClover/pic.png" alt="cmd-markdown-logo"></p><p>这里主要做了service层的单元测试覆盖，覆盖率平均到了80以上，但是整个项目的覆盖率只有30不到。这里是因为插件统计项目中每个类进行的每个方法以及代码的覆盖率，包括控制层代码。代码中会显示绿色的为覆盖到的代码，红色的未覆盖的代码，包括一些异常，未被执行到的判断。判断如果是多个参数的，需要考虑到所有的情况才算是百分之100通过，可以看到覆盖代码如图：</p><p>​      <img src="http://arthornye.github.io/images/OpenClover/color.png" alt="cmd-markdown-logo"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本次单元测试覆盖率是鉴于部门对代码质量的要求，延续之前增加了sonar自定义检测代码规则。提升代码覆盖率的过程中发现其实是个体力活，这样的覆盖也许在后续补充为了达到指标也许并没有意义。这也许是为了我们可以在项目开发的过程中来补充单元测试用例保证代码交付质量，如果放到后面再来补，也就本末倒置了。希望今后的代码都能在开发过程中做到充分的单元测试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代码的单元测试覆盖率是衡量代码质量的标准之一，保证一定的ut覆盖率可以帮助提高开发人员的项目提测质量。本文将介绍如何在idea下利用openclover插件提高ut覆盖率。&lt;/p&gt;
&lt;h3 id=&quot;安装idea插件&quot;&gt;&lt;a href=&quot;#安装idea插件&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="大搜车的点滴记录" scheme="http://jianghao.wang/tags/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%9A%84%E7%82%B9%E6%BB%B4%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>git如何回滚远程仓库</title>
    <link href="http://jianghao.wang/2018/git%E5%A6%82%E4%BD%95%E5%9B%9E%E6%BB%9A%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <id>http://jianghao.wang/2018/git如何回滚远程仓库/</id>
    <published>2018-02-07T07:45:54.000Z</published>
    <updated>2018-02-07T07:45:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是个浮躁的日子，好像一整天也没有集中注意力看点东西。听到了群里在讨论一个线上的问题，进行了版本回退。响应很及时，想到如果自己的代码需要回退，应该如何操作更为合理。</p><h3 id="git-revert和git-reset的区别"><a href="#git-revert和git-reset的区别" class="headerlink" title="git revert和git reset的区别"></a>git revert和git reset的区别</h3><p>git revert和git reset是两种版本回退操作，revert需要提交信息，会生成一条新的提交，这条提交记录会将指定版本后的提交记录抵消掉，而且以前的历史记录都会保留。但是reset是进行HEAD的位置切换，不会出现新的提交记录。</p><h4 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h4><p>我尝试提交了提交了四次，可以看到我在尝试revert的时候遇到了冲突，git应该是将暂存区关于冲突的文件删除，我需要在处理完冲突之后git add将文件添加到暂存区，然后新建一个提交git commit -m “本次版本回退的commit信息”。</p><p><img src="http://arthornye.github.io/images/git/revert.png" alt="cmd-markdown-logo"></p><p>我们可以看到之前的历史提交记录都没有被改变，只是在之前的基础上添加了一次提交记录：</p><p><img src="http://arthornye.github.io/images/git/log.png" alt="cmd-markdown-logo"></p><h4 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h4><p>git reset的理解相对简单一些，它只是单纯做一个HEAD指针的切换并不会新增一个提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commitid</span><br></pre></td></tr></table></figure><p>通过commitid可以切换到指定的提交。也可以通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD~数值</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>这些形式都可以回退到指定的历史版本。在刚才的git log基础之上git reset —hard HEAD~2：</p><p><img src="http://arthornye.github.io/images/git/reset2.png" alt="cmd-markdown-logo"></p><h3 id="如何进行远程仓库版本回退"><a href="#如何进行远程仓库版本回退" class="headerlink" title="如何进行远程仓库版本回退"></a>如何进行远程仓库版本回退</h3><p>如何进行版本回退，方法一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git revert commitid //可能需要进行merge操作</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commitid</span><br><span class="line">git push -f    //强制提交更改，远程分支的head会被强制更改</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天是个浮躁的日子，好像一整天也没有集中注意力看点东西。听到了群里在讨论一个线上的问题，进行了版本回退。响应很及时，想到如果自己的代码需要回退，应该如何操作更为合理。&lt;/p&gt;
&lt;h3 id=&quot;git-revert和git-reset的区别&quot;&gt;&lt;a href=&quot;#git-re
      
    
    </summary>
    
    
      <category term="大搜车的点滴记录" scheme="http://jianghao.wang/tags/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%9A%84%E7%82%B9%E6%BB%B4%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>搭建本地SonarQube服务</title>
    <link href="http://jianghao.wang/2018/%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0SonarQube%E6%9C%8D%E5%8A%A1/"/>
    <id>http://jianghao.wang/2018/搭建本地SonarQube服务/</id>
    <published>2018-02-05T15:10:19.000Z</published>
    <updated>2018-02-06T09:04:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>部门需要对代码质量和风格进行统一，提高开发效率和质量。本篇主要对搭建sonar服务过程中碰到的问题做一个简单的复习记录。</p><h3 id="SonarQube介绍"><a href="#SonarQube介绍" class="headerlink" title="SonarQube介绍"></a>SonarQube介绍</h3><p>SonarQube是基于docker搭建的一个代码检测工具，内置了包括js，xml，java，c#等主流编程语言的代码检测规则。我们也可以通过sonarqube去添加自定义的检测规则。给予阿里巴巴开发手册尝试添加一个自定义的规则。</p><p>​    <img src="http://arthornye.github.io/images/sonar/sonarqube.png" alt="cmd-markdown-logo"></p><h3 id="搭建本地SonarQube服务"><a href="#搭建本地SonarQube服务" class="headerlink" title="搭建本地SonarQube服务"></a>搭建本地SonarQube服务</h3><p>可以通过<a href="http://sonarqube.com" target="_blank" rel="noopener">sonarqube官网</a>下载一个sonarqube。我本地安装的版本是6.7.1。下载之后直接解压就行，我们可以将这个理解为tomcat类似的服务器。下面会分析这个项目的结构。</p><h4 id="sonarqube目录结构"><a href="#sonarqube目录结构" class="headerlink" title="sonarqube目录结构"></a>sonarqube目录结构</h4><p>​    <img src="http://arthornye.github.io/images/sonar/directory.png" alt="cmd-markdown-logo"></p><p>我们进入到目录下，可以通过extensions目录增加自定义规则，后续会介绍，我们可以将自定义的代码规则打包这个目录下。</p><p>bin目录可以启动sonarqube服务，找到对应macos的版本我们可以尝试启动，注意这边启动的时候有个很诡异的地方，我们输入./sonar.sh status</p><p>可能会弹出提示，sonarqube is running，但是可能实际上服务可能是stopped未启动的状态，我们可以进入到日志文件tail -f logs/sonar.log查看具体的服务器启动状态。</p><p>conf目录下sonar.properties记录sonarqube的配置。我们可以配置访问端口以及本地数据库配置，sonarqube默认会链接到一个临时数据库，数据库主要记录扫描检测代码的结果。</p><h4 id="配置本地数据库"><a href="#配置本地数据库" class="headerlink" title="配置本地数据库"></a>配置本地数据库</h4><p>sonarqube可以配置本地连接mysql数据库，我们先创建本地mysql数据库账号，注意开启mysql本地服务。</p><p><img src="http://arthornye.github.io/images/sonar/database.png" alt="cmd-markdown-logo"></p><h4 id="maven配置打包自定义规则代码"><a href="#maven配置打包自定义规则代码" class="headerlink" title="maven配置打包自定义规则代码"></a>maven配置打包自定义规则代码</h4><p>sonarqube可以将自定义规则打包到extensions文件夹下，首先我们需要将自己写的自定义规则打包成jar包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;pluginGroups&gt;</span><br><span class="line">       &lt;pluginGroup&gt;org.sonarsource.scanner.maven&lt;/pluginGroup&gt;</span><br><span class="line">    &lt;/pluginGroups&gt;</span><br><span class="line">    &lt;profiles&gt;</span><br><span class="line">        &lt;profile&gt;</span><br><span class="line">            &lt;id&gt;sonar&lt;/id&gt;</span><br><span class="line">            &lt;activation&gt;</span><br><span class="line">                &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">            &lt;/activation&gt;</span><br><span class="line">            &lt;properties&gt;</span><br><span class="line">                &lt;!-- Optional URL to server. Default value is http://localhost:9000 --&gt;</span><br><span class="line">                &lt;sonar.host.url&gt;</span><br><span class="line">                  http://localhost:9000</span><br><span class="line">                &lt;/sonar.host.url&gt;</span><br><span class="line">            &lt;/properties&gt;</span><br><span class="line">        &lt;/profile&gt;</span><br><span class="line">     &lt;/profiles&gt;</span><br></pre></td></tr></table></figure><p>那么我们通过mvn sonar:sonar可以打包成功，然后在target目录下获取到打包好的jar包。</p><h4 id="sonarqube设置使用规则"><a href="#sonarqube设置使用规则" class="headerlink" title="sonarqube设置使用规则"></a>sonarqube设置使用规则</h4><p>我们登录到sonarqube创建一个自定义规则组。</p><p><img src="http://arthornye.github.io/images/sonar/addrules.png" alt="cmd-markdown-logo"></p><p>我们可以启用规则。</p><h4 id="Idea拉取代码分析结果sonarlink"><a href="#Idea拉取代码分析结果sonarlink" class="headerlink" title="Idea拉取代码分析结果sonarlink"></a>Idea拉取代码分析结果sonarlink</h4><p>我们可以在idea中下载插件，sonarlink配置到我们的sonarqube代码检测平台，将对应的代码检测结果下载到本地代码中注释。本地代码会在对应行的位置报错，不同的代码规则会给到不同的提示。这里需要保证本地代码的版本和远程分析代码的版本一致，不然可能部分的报错没办法正常显示在正确的位置。</p><p><img src="http://arthornye.github.io/images/sonar/sonartest.png" alt="cmd-markdown-logo"></p><h4 id="如何添加自定义代码规则"><a href="#如何添加自定义代码规则" class="headerlink" title="如何添加自定义代码规则"></a>如何添加自定义代码规则</h4><p>大家可以移步到<a href="https://github.com/ArthornYe/saas-sonar-rules" target="_blank" rel="noopener">我的github</a>，根据readme.md中的demo进行开发自定义规则。这里记录下自己开发过程中碰到的部分问题：</p><p>1.context.reportissue()调用过程需要指定对应的tree</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Rule(</span><br><span class="line">        key = &quot;SaasParamStartCheck&quot;,</span><br><span class="line">        name = &quot;POJO 类中布尔类型的变量，都不要加 is&quot;,</span><br><span class="line">        description = &quot;定义为基本数据类型Boolean isSuccess;的属性，它的方法也是isSuccess()，RPC 框架在反向解析的时候，“以为”对应的属性名称是 success，导致属性获取不到，进而抛出异常。&quot;,</span><br><span class="line">        priority = Priority.CRITICAL,</span><br><span class="line">        tags = &#123;&quot;bug&quot;&#125;)</span><br><span class="line">public class SaasParamStartCheck extends BaseCheck &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void visitClass(ClassTree tree)&#123;</span><br><span class="line">        //1.获取类信息</span><br><span class="line">        //2.获取属性元素</span><br><span class="line">        List&lt;Tree&gt; treeList=tree.members();</span><br><span class="line">        //3.判断属性命名</span><br><span class="line">        for(Tree oneTree:treeList)&#123;</span><br><span class="line">            if(oneTree instanceof VariableTree)&#123;</span><br><span class="line">                VariableTree variableTree=(VariableTree) oneTree;</span><br><span class="line">                if(variableTree.type()!=null &amp;&amp; variableTree.type().symbolType().name().equals(&quot;boolean&quot;))&#123;</span><br><span class="line">                    String name=variableTree.simpleName().name();</span><br><span class="line">                    if(checkStartWithIS(name))&#123;</span><br><span class="line">                        context.reportIssue(this,oneTree,&quot;属性名不能以is开头&quot;);</span><br><span class="line">                       // System.out.println(&quot;命名错误&quot;+&quot;属性名不能以is开头&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        super.visitClass(tree);</span><br><span class="line">    &#125;</span><br><span class="line">    Boolean checkStartWithIS(String name)&#123;</span><br><span class="line">        if(name.startsWith(&quot;is&quot;))&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行测试用例之后报错：</p><p><img src="http://arthornye.github.io/images/sonar/error.png" alt="cmd-markdown-logo"></p><p>因为错将tree打出，所以在报错的时候找错了行。抛出了异常。</p><h4 id="碰到的问题"><a href="#碰到的问题" class="headerlink" title="碰到的问题"></a>碰到的问题</h4><p>1.从本地访问localhost:9000会访问到空白页，一直没办法定位，一开始以为是数据库配置的问题，后面删除了本地数据库所有的表，sonarqube重启之后正常。</p><p>2.从本地访问localhost:9000空白页，上面提到过通过./sonar.sh status访问到的状态是sonarqube is running但是实际上sonarqube并没有启动成功。</p><p>3.从本地访问localhost:9000空白页，可能是本地数据库服务没打开，我们cd到mysql的目录下启动服务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;部门需要对代码质量和风格进行统一，提高开发效率和质量。本篇主要对搭建sonar服务过程中碰到的问题做一个简单的复习记录。&lt;/p&gt;
&lt;h3 id=&quot;SonarQube介绍&quot;&gt;&lt;a href=&quot;#SonarQube介绍&quot; class=&quot;headerlink&quot; title=&quot;So
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Paxos算法和BFT问题</title>
    <link href="http://jianghao.wang/2018/Paxos%E7%AE%97%E6%B3%95%E5%92%8CBFT%E9%97%AE%E9%A2%98/"/>
    <id>http://jianghao.wang/2018/Paxos算法和BFT问题/</id>
    <published>2018-02-05T10:18:04.000Z</published>
    <updated>2018-02-05T13:13:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>区块链可以去中心化，很大程度上依赖于自建的“共识机制”。Paxos是古代希腊的一个城邦，城邦中有众多议员，议员会对法律提案进行决议，提案通过通讯员进行提交。当某个提案者的提案获得大部分议员的赞同时，代表议案通过。这里涉及到的三个角色，议员，提案者，通讯员，可以对应到区块链网络。每个节点可以去计算hash值，将其作为一个提案，提交给区块链网络中其他的所有节点，这个过程中每个节点都在进行计算和提交：</p><p>1.Paxos问题保证这样的分布式网络中节点可能存在故障的情况下在最快的时间内达成共识。</p><p>2.BFT保证允许少数节点作恶（企图伪造消息）场景下的一致性达成问题。</p><h2 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h2><h3 id="什么是Paxos算法"><a href="#什么是Paxos算法" class="headerlink" title="什么是Paxos算法"></a>什么是Paxos算法</h3><p>Paxos问题是指分布式系统中存在故障（fault），但是不存在恶意（corrupt）节点场景（消息可能重复或者丢失但是没有错误消息）下的共识达成（consensus）问题。最早是Leslise Lamport用Paxos岛的故事模型来进行描述而命名。</p><p>Paxos可以保证在一半正常节点存在时，系统能达成共识。</p><h4 id="单个提案者-多个接收者"><a href="#单个提案者-多个接收者" class="headerlink" title="单个提案者+多个接收者"></a>单个提案者+多个接收者</h4><p>系统中只指定某个特定的节点时提案者，那么一致性肯定可以达成（只有一个方案，要么达成要么失败）。提案者只要收到了来自多数接收者的投票即可认为是通过，因为系统中不存在其他的提案。</p><h4 id="多个提案者-单个接收者"><a href="#多个提案者-单个接收者" class="headerlink" title="多个提案者+单个接收者"></a>多个提案者+单个接收者</h4><p>限定某个节点作为接收者。这种情况下，共识也很容易达成，接收者接收到多个提案，选择第一个提案作为决议，拒绝掉后续的提案。</p><p>缺陷也是容易发生单点故障，包括接受者故障或者首个提案节点发生故障。</p><p>上面这两种情形实际上类似主从模式，虽然并不是很可靠，但是原理十分简单，在zookeeper等应用中广泛存在。这里主要介绍提案者和接收者扩展到多个的情形。</p><h4 id="多个提案者-多个接受者"><a href="#多个提案者-多个接受者" class="headerlink" title="多个提案者+多个接受者"></a>多个提案者+多个接受者</h4><p>这种情况最接近于区块链共识机制，在区块链的所有节点中每个节点都可以去计算hash值，并发布给网络中的所有节点，当某个值获得大部分节点的赞同（校验hash值，可参考上篇文章）时，通过并写入数据库。</p><p>像这样的场景下，同一个时间片段内可能会有多个节点会去提交自己算出的hash值，企图通过大部分节点的校验。那么当同一个节点收到多个提案的时候如何进行区分？如果只接受第一个这样的方式，也会造成节点对提案的混乱。所以我们需要定一个意见领袖，也就是先来后到，当某个节点已经有提案被提交的时候，后续提交的节点可以广播这个节点的提案，这样不断扩散，也加速了达成共识的速度。</p><p>我们为每个提交的hash记录根据时间分配一个序号？我们可以尝试为每个节点进行编号，配合在前面加上时间戳来达到递增的目的。</p><h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><p>想象节点在发出自己的提案的时候，收到一些反馈。一种结果是自己的提案被大多数接收，另一种结果是没被接收。但是即便收到了来自大多数的反馈，也不能认为就是最终确认，因为这些接收者并不知道自己刚才反馈的就是全局的大多数，也就是意见领袖。</p><p>那么我们引入一个新的阶段，提案者在前一阶段拿到所有的反馈之后，判断这个提案是可能被大多数接受的提案，需要对其进行最终确认。</p><p>将Paxos分为准备（prepare）和提交（commit）两个阶段。准备阶段解决大家对哪个提案进行投票的问题（统一意见领袖），提交阶段解决确认最终值的问题。</p><h5 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h5><p>接受者时刻保留收到过的提案的最大编号和接受过的最大提案编号。如果收到的提案号比目前保留的最大的提案号还大，则返回自己已接受的提案值（如果还未收到过任何提案，则为空）给提案者，更新当前最大提案号，并说明不再接收小于最大提案号的提案。提案者以这样的方式去锁定大部分节点的支持。</p><h5 id="提交阶段"><a href="#提交阶段" class="headerlink" title="提交阶段"></a>提交阶段</h5><p>提案者如果收到大多数的回复(表示大部分人听到它的请求)，则可准备发出带有刚才<br>提案号的接受消息。如果收到的回复中不带有新的提案，说明锁定成功，则使用自己的提案内容（hash值）;如果返回中有提案内容，则替换提案值为返回中编号最大的提案值。接受者收到接受消息后，如果发现提案号不小于已接受的最大提案号，则接受该提案，  并更新接受的最大提案。</p><p>一旦多数接受了共同的提案值，则形成决议，成为最终确认的提案。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>区块链网络模型在对hash值达成共识的过程中可以类比多个提案者+多个接受者模型。当某个节点A计算出了某个hash值，会根据时间戳生成一个唯一的编号，然后将这个hash值提交给网络中其他节点进行审核。当然这个过程中可能也有别的节点B尝试进行提交。为了统一对某个hash值进行共识判断，我们首先要统一意见领袖，也就是尽量让整个系统统一对某个hash值进行判断。当统一之后再对这个hash值进行提交，这时系统中所有节点在准备阶段都已经保留了接受的提案编号，从而辨识当前提交的提案是否为意见领袖也就是第一阶段大家统一要处理的提案。在大多数节点统一之后这个hash值便会被直接写入数据库。</p><h2 id="BFT（Byzantine-Generals-Problem）拜占庭问题"><a href="#BFT（Byzantine-Generals-Problem）拜占庭问题" class="headerlink" title="BFT（Byzantine Generals Problem）拜占庭问题"></a>BFT（Byzantine Generals Problem）拜占庭问题</h2><p>拜占庭问题更为广泛，讨论的是允许少数节点作恶的（消息被伪造）场景下的一致性达成问题。拜占庭算法讨论的是最坏情况下的保障。</p><h4 id="中国将军问题"><a href="#中国将军问题" class="headerlink" title="中国将军问题"></a>中国将军问题</h4><p>拜占庭将军问题之前，就已经存在中国将军问题:两个将军要通过信使来达成进攻还是撤退的约定，但信使可能迷路或被敌军阻拦(消息丢失或伪造)，如何达成一致。</p><h4 id="拜占庭问题"><a href="#拜占庭问题" class="headerlink" title="拜占庭问题"></a>拜占庭问题</h4><p>拜占庭将军(Byzantine Generals Problem)问题，是 Leslie Lamport 1982 年提出用来解释一致性问题的一个虚构模型。拜占庭是古代东罗马帝国的首都，由于地域宽广，守卫边境的多个将军(系统中的多个节点)需要通过信使来传递消息，达成某些一致的决定。但由于将军中可能存在叛徒(系统中节点出错)，这些叛徒将努力向不同的将军发送不同的消息，试图会干扰一致性的达成。</p><p>拜占庭问题即为在此情况下，如何让忠诚的将军们能达成行动的一致。</p><p>对于拜占庭问题，如果节点总数为N，叛变的将军数为F，那么当N和F呈现怎样的分布时会让忠诚的将军们保证正确的决策。</p><p>我们很容易可以推理到N&gt;2F，当某个忠诚的节点希望得到正确的决策，会有F个篡改节点进行干扰，那么需要满足N-F&gt;F才能保证忠诚的一方可以胜利。</p><h4 id="PoW（Proof-of-Work）算法"><a href="#PoW（Proof-of-Work）算法" class="headerlink" title="PoW（Proof of Work）算法"></a>PoW（Proof of Work）算法</h4><p>比特币区块链网络在设计之初提出了创新的PoW（Proof of Work）算法思路。一个限制了一段时间内整个网络中出现的提案个数（增加提案成本，减少坏节点对系统的干扰）另外一个是放宽对最终一致性确认的需求，约定好大家都确认并沿着已知最长的链进行拓宽。这样，如果有人试图去篡改一条链，那么他的计算速度永远要大于网络中节点的计算速度。</p><p>这里的话个人理解，如果有人试图篡改一条链，在主链上生产一个分支链，是不是意味着他需要自己编写自己的账本数据计算hash值然后不断添加伪造链，那么这样的链是永远不可能被读到的。因为总是默认读最长的链，伪造的速度不可能大于真实存在的链的增长速度，因为算力上的差距是很大的。而且即使伪造链的长度要大于真实链，那么根据大多数原则，这条链也肯定会立即被系统中所共识的链取代。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>BFT和PoW算法为区块链的共识机制奠定了算法基础。这部分的东西个人觉得理解起来还是比较抽象的，需要具体化到很多现实的场景下可能会更好理解。我将Paxos共识的准备阶段类比为拿票，提案者先扫描所有决策者的队列去拿票（每个决策者只有一张票），先来的人（如果当前没人拿票）先拿到票，后来的人没办法拿票，只能查看当前票被谁拿走了，然后帮那个人先提交提案。<br>​<br>​<br>​<br>​<br>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;区块链可以去中心化，很大程度上依赖于自建的“共识机制”。Paxos是古代希腊的一个城邦，城邦中有众多议员，议员会对法律提案进行决议，提案通过通讯员进行提交。当某个提案者的提案获得大部分议员的赞同时，代表议案通过。这里涉及到的三个角色，议员，提案者，通讯员，可以对应到区块链网
      
    
    </summary>
    
    
      <category term="科技" scheme="http://jianghao.wang/tags/%E7%A7%91%E6%8A%80/"/>
    
  </entry>
  
  <entry>
    <title>工作问题记录</title>
    <link href="http://jianghao.wang/2018/%E5%B7%A5%E4%BD%9C%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://jianghao.wang/2018/工作问题记录/</id>
    <published>2018-01-28T04:03:44.000Z</published>
    <updated>2018-05-22T03:12:17.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="工作问题记录"><a href="#工作问题记录" class="headerlink" title="工作问题记录"></a>工作问题记录</h4><p>1.mac os查看本地ip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig |grep &quot;inet&quot;</span><br></pre></td></tr></table></figure><p>服务器git切换分支:</p><p>2.修改脚本指向本地分支，通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b localbranchname remotebranchname</span><br></pre></td></tr></table></figure><p>3.idea中java文件右下角有个红色的j：</p><p>不可编译，File—&gt;Project Structure—&gt;Module—&gt;Sources将右边第一个X点掉，去掉Root路径之后重新添加。</p><p>4.引入不必要文件修改.gitignore忽略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">'update .gitignore'</span></span><br></pre></td></tr></table></figure><p>我们在修改了gitignore文件之后，如果想要被忽略的文件目录已经被git add记录到git工作区中。需要git rm -r –cached .将文件从git中清除再重新add。之后所有被add的文件都会检验.gitignore文件是否忽略。</p><p><strong>如果git目录下没有.gitignore文件可以自行添加</strong></p><p>5.关闭linux服务器上所有的tomcat进程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep <span class="string">'org.apache.catalina.startup.Bootstrap start'</span> | awk <span class="string">'&#123; print $2 &#125;'</span> | xargs kill -<span class="number">9</span></span><br></pre></td></tr></table></figure><p>6.mvn clean install 找不到symbol问题</p><p>会报错maven-compile-plugin的版本问题，实际上是找不到依赖的包。这种问题可以从以下两个方面定位：</p><p>1.依赖错误，引用了低版本的jar包，部分本地仓库有低版本的拷贝，不会报错。</p><p>2.编译错误</p><p>有时候本地的引用类库和远程的类库不一致，或者低版本不被维护了，导致部分引用到低版本的在存在本地复制的情况下不会报错。</p><p>7.在最外层依赖jar包完全依赖不到</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--仓储服务--&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.souche&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;souche-storage-api&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>这样是不能将远程仓库的jar包直接下载到本地的，需要在parent上级添加依赖：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--仓储服务--&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.souche&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;souche-storage-api&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>这样就可以将包下载到本地。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;工作问题记录&quot;&gt;&lt;a href=&quot;#工作问题记录&quot; class=&quot;headerlink&quot; title=&quot;工作问题记录&quot;&gt;&lt;/a&gt;工作问题记录&lt;/h4&gt;&lt;p&gt;1.mac os查看本地ip&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;ta
      
    
    </summary>
    
    
      <category term="大搜车的点滴记录" scheme="http://jianghao.wang/tags/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%9A%84%E7%82%B9%E6%BB%B4%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>WTF is The BlockChain?</title>
    <link href="http://jianghao.wang/2018/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <id>http://jianghao.wang/2018/区块链/</id>
    <published>2018-01-15T03:32:25.000Z</published>
    <updated>2018-01-15T09:37:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近区块链大热，走到哪儿都有人在讨论区块链和比特币，甚至于一些对密码学完全没有概念的人都开始大肆吹捧，不免让人嗤之以鼻。相信很多技术和非技术的朋友都希望能够更深层次地去了解它是如何工作的。本文将用不到四千字来尝试阐述区块链的实现原理：</p><h3 id="为什么需要区块链这么复杂玩意儿？"><a href="#为什么需要区块链这么复杂玩意儿？" class="headerlink" title="为什么需要区块链这么复杂玩意儿？"></a>为什么需要区块链这么复杂玩意儿？</h3><blockquote><p>For every complex problem there is an answer that is clear, simple, and wrong.” — H. L. Mencken        </p></blockquote><p>在这里不尝试去给区块链一个准确的定义，而是通过区块链可以被使用的地方去分析和深入理解这项技术可能给世界带来的改变。</p><p>可以想象一个场景，你的朋友Joe在国外旅行，在旅行将要结束的第五天，他打电话给你说自己需要借点钱。你在接到电话之后会通知银行进行转账到Joe的指定账户，银行客户经理审查你的账户余额是否足够之后打钱给指定的Joe的账户。然后银行会产生一条转账记录：</p><p>​                             <img src="https://arthornye.github.io/images/banktransfer.png" alt="cmd-markdown-logo"></p><p>​    在打帐成功之后，银行通知你钱已经转账到位然后你会通知Joe打帐成功让其确认。<img src="https://arthornye.github.io/images/sure.png" alt="cmd-markdown-logo"></p><p>这样的转账方式是我们目前乃至几个世纪之前一直使用的，我们需要一个第三方机构进行担保，才能在彼此之间建立一种信任。但是这样的方式往往机构是单一的，也就是说如果这个第三方机构产生腐化，那么造成的影响也是巨大的（金融次贷危机的屡次发生），这就需要很多的人力去维持机构的工作以及政府的有力监管（政企腐败难以监管）。同时还会面临可能出现的几个问题：</p><ul><li>如果这个第三方机构的数据在一次火灾中被烧毁或者数据库数据直接被篡改。</li><li>又或者客户经理（第三方机构）在转账数额上动手脚，客户可能根本无法感知到（可以关注相关新闻）。</li></ul><blockquote><p>多年以来我们都将所有的鸡蛋放在第三方机构，并且建立了一种习惯上的信任。</p></blockquote><p>那么我们是否可以自己去建立这种信任，而不是通过第三方…….</p><h4 id="所以，区块链是如何工作的？"><a href="#所以，区块链是如何工作的？" class="headerlink" title="所以，区块链是如何工作的？"></a>所以，区块链是如何工作的？</h4><p>要达到不通过第三方的目的，我们需要聚集这些志同道合的人形成一个团队，以某种方式在内部建立一种信任机制。</p><p><img src="https://arthornye.github.io/images/group.png" alt="cmd-markdown-logo"></p><h4 id="一个空的文件夹"><a href="#一个空的文件夹" class="headerlink" title="一个空的文件夹"></a>一个空的文件夹</h4><p>现在我们发给每个人一个空的文件夹，这个团队内部所有的交易都会被写到各自的文件夹中，这些所有文件夹的集合共同建立了一种信任机制。</p><h4 id="发生转账事务"><a href="#发生转账事务" class="headerlink" title="发生转账事务"></a>发生转账事务</h4><p>每个人都配有一支笔和空白页，当团队内部发生转账交易时，会记录在自己的纸上，纸张满了会将其存入文件夹。那么我们假设#2想转10美元给#9，然后2号大喊一声：“我要转10块钱给9号，所有人都写下这笔记录”。</p><p><img src="https://arthornye.github.io/images/transaction.png" alt="cmd-markdown-logo"></p><p>然后每个人都去check一下2号是否有足够的钱去支持这笔转账，如果有的话每个人都写一份记录在自己的纸上。</p><p>​                            <img src="https://arthornye.github.io/images/firsttrans.png" alt="cmd-markdown-logo"></p><h4 id="持续产生转账记录"><a href="#持续产生转账记录" class="headerlink" title="持续产生转账记录"></a>持续产生转账记录</h4><p>通过这样的方式团队中每个人想转账就喊一声让其他人记录下这次转账记录，假设一张纸可以写十条记录，那么十条记录写满之后就需要将这张纸存进文件夹，然后拿出一张新的纸开始循环第二步。</p><p><img src="https://arthornye.github.io/images/fullfull.png" alt="cmd-markdown-logo"></p><p>在我们将写满的一页加入文件夹时，我们需要考虑一个问题如何保证这张被记录的纸是可信任的（所有的记录都未被篡改，所有人的纸张内容不一定一致，即使通过非对称加密保证通讯的加密性也不能保证每个节点都是忠诚的为这个分布式系统服务），那么我们需要给这张纸的内容盖一个印章。盖这个章的目的：</p><ul><li>保证团队所有写入的记录都是未被篡改而且一致。</li><li>保证团队从文件夹取出的历史记录未被篡改。</li></ul><h3 id="如何去进行签章"><a href="#如何去进行签章" class="headerlink" title="如何去进行签章"></a>如何去进行签章</h3><p>以前我们通过第三方/中间人建立信任，无条件信任第三方。在区块链这样的分布式和分散系统中，这个印章将会提供信任。在进行签章之前我们需要了解hash算法：</p><blockquote><p>Given an output, it is extremely difficult to calculate the input, but given an input and output, it is pretty easy to verify if the input leads to the output.</p></blockquote><ul><li>无冲突。任何一个a通过hash算法能生成一个唯一对应的b。</li><li>不可逆。任何一个a通过hash算法生成的b是不可逆的，也就是知道b不能推出a。</li></ul><p>那么我们可以用一种box的概念来描述这种算法：</p><p><img src="https://arthornye.github.io/images/hash.png" alt="cmd-markdown-logo"></p><p>​                            <img src="https://arthornye.github.io/images/testhash.png" alt="cmd-markdown-logo"></p><p>一个input对应一个output，现在我们可以假设我们要得到的结果必须以三个零开头，得到这样的结果集算成功。</p><p><img src="https://arthornye.github.io/images/threezero.png" alt="cmd-markdown-logo"></p><p>然后开始不停地计算和重试，挖矿的过程就是计算签章的过程，实际的过程比这更复杂，但是可以用这种方式类比。</p><p><img src="https://arthornye.github.io/images/try.png" alt="cmd-markdown-logo"></p><p>经过无数次尝试可能得到结果：</p><p><img src="https://arthornye.github.io/images/result.png" alt="cmd-markdown-logo"></p><h4 id="如何利用hash算法去进行签章？"><a href="#如何利用hash算法去进行签章？" class="headerlink" title="如何利用hash算法去进行签章？"></a>如何利用hash算法去进行签章？</h4><p>在hash算法的基础之上，我们需要关联纸张中的内容，通过下面的算法得到签章：</p><p><img src="https://arthornye.github.io/images/get.png" alt="cmd-markdown-logo"></p><p>矿工帮我们计算好的到的签章数字为“21191”：</p><p><img src="https://arthornye.github.io/images/sign.png" alt="cmd-markdown-logo"></p><p>然后我们将签章通知团队中所有的人，他们会各自验证，这个签章的值+纸张内容值的hash结果是不是符合000开头的标准。只要大多数通过，那么这个数值有效，挖出这个数值的矿工会获得相应的奖励，最后所有人都签上这个签章，然后将记录存储在文件夹中：</p><p>​                            <img src="https://arthornye.github.io/images/signresult.png" alt="cmd-markdown-logo"></p><p>在矿工工作的过程中，也可能产生欺诈行为，错误的签章数字不能通过团队其他人的校验。其他人如果内容记录被修改过也不能通过校验，这样就保证了被存储的记录永远是可信任的（通过大多数人一致的原则保证）。在挖矿的过程中会消耗“燃料”，这个成本和电力的消耗是巨大的，团队中每个人必须签上章，签章校验不过可能的原因：</p><p>​                          <img src="https://arthornye.github.io/images/seal.png" alt="cmd-markdown-logo"></p><ul><li>节点可能误听了网络中的交易。</li><li>节点可能错写了网络中的交易。</li><li>节点可能试图盗取或者欺骗网络中的其他节点。</li></ul><p>当然无论出于何种原因，校验不通过的节点只能从其他节点中拷贝一份账本到自己的文件夹中。</p><h4 id="为什么要建立一种竞争机制"><a href="#为什么要建立一种竞争机制" class="headerlink" title="为什么要建立一种竞争机制"></a>为什么要建立一种竞争机制</h4><p>我们可能有个疑问，为什么花费大量的资源去计算这个签章值，建立在竞争机制下的计算出了第一个算力的结果值是有效的。其他的算力都是在产生浪费，之前新加坡一家区块链公司针对比特币产生的大量资源浪费提出了分块计算进行资源利用的优化，但是并没有消除这种竞争，那么我们为什么需要这种竞争？</p><p>这就是我们需要了解的激励机制，每个区块链中的节点都可以去竞争这个奖励。第一个计算出来签章的会获得一定的奖励（在消耗大量cpu和电力资源的前提下）。</p><p>假设五号计算出了这个签章值，它会获得这个奖励可能是1bitcorn，它的账户余额也会相应增加。这就是比特币以及大多区块链一致存在的原因，不断会有新的节点加入挖矿，成为分布式账本中的一员参与竞争。只有足够多的节点加入，这个区块链才能建立一种更为健全的共识机制。</p><p>当有足够的人拥有比特币时，他们的价值就会增长，使其他人想要比特币;使比特币进一步增长;使更多的人想要比特币;使其进一步增长;等等</p><blockquote><p>激励机制使网络中所有节点都在努力工作。</p></blockquote><p>在此之前我并没有提到过一个问题，想象一下如果我们现在的文件夹已经存储了五页纸张，都被签上了各自的签章。那么如果我找到第二页并且企图去修改一次交易信息？签章会保证这次修改再取出的时候被检测到被修改对吧？但是如果我同时计算一个新的签章，并且替换掉旧的签章呢，我可以修改一个就可以修改网络节点中其他的节点，当超过百分之五十的节点都被篡改了签章，那么这页数据也就被成功篡改，网络的共识机制无法感知。所以我们的区块链设计有漏洞？</p><h4 id="如何防止签章被篡改"><a href="#如何防止签章被篡改" class="headerlink" title="如何防止签章被篡改"></a>如何防止签章被篡改</h4><p>我们其实很容易想到，在上面产生签章的模型中我们用了页面的内容和一个未知值作为input，实际上如果要防止签章数字被篡改。我们可以在input中增加一个数值，将上一页的签章数值作为这一页数值计算的输入：</p><p>​    <img src="https://arthornye.github.io/images/right.png" alt="cmd-markdown-logo"></p><p>当我们通过这样的方式将每一页的数据关联在一起的时候，如果有人试图去篡改某一页的签章，那么它需要篡改之前连续很多页的签章和内容，这样的代价是极大的，修改一个节点数据的代价是完全创造一份新的数据，然后为了破坏共识机制还需要修改网络中大于一半的节点数据。</p><p>也就是说基于现在区块链的设计，你需要不断去产生新的区块，篡改节点全部的数据，通过计算不断去篡改，但是一个人的篡改速度远远没有其他节点继续计算和不断回写数据的速度。即使是针对同一个节点，最长的链也永远是最可信的：</p><blockquote><p>Longest chain is the honest chain.</p></blockquote><p><img src="https://arthornye.github.io/images/longest.png" alt="cmd-markdown-logo"></p><p>绿色的部分是篡改者企图想要开启的一条篡改的链路，红色的部分是正常发展的链路，下面的链路计算能力永远大于上面链路的计算能力，基于共识机制团队中大部分人都是诚实的。</p><h4 id="团队中超过半数的人不诚实？"><a href="#团队中超过半数的人不诚实？" class="headerlink" title="团队中超过半数的人不诚实？"></a>团队中超过半数的人不诚实？</h4><p>这就是区块链如果可能会崩溃的唯一脆弱的原因。 要知道，这是不太可能发生的，但我们都必须知道系统的弱点。 它建立在大多数人群总是诚实的假设之上。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文希望给大家一个对区块链较为深入的了解。区块链是如何达到去中心化的目的的，明白了共识机制以及共识机制的基本条件，我们可以尝试去理解区块链能够如何改变我们的生活。其实不难发现，区块链的设计并没有那么复杂，将所有的节点理解为区块，每个区块都是链接起来的账本数据。</p><p>向创造区块链思想的中本聪致敬，我们需要从不同的角度去思考现在的生活，正如乔布斯所说，世界上没有一种设计是理所当然的。也许有一天我们不再需要键盘来操作电脑，于是苹果设计了触摸板，至今没有用过比这更有创意的快捷操作。</p><p>最后，希望我们都能想孩童一样去思考，创造一个不一样的世界。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近区块链大热，走到哪儿都有人在讨论区块链和比特币，甚至于一些对密码学完全没有概念的人都开始大肆吹捧，不免让人嗤之以鼻。相信很多技术和非技术的朋友都希望能够更深层次地去了解它是如何工作的。本文将用不到四千字来尝试阐述区块链的实现原理：&lt;/p&gt;
&lt;h3 id=&quot;为什么需要区块
      
    
    </summary>
    
    
      <category term="科技" scheme="http://jianghao.wang/tags/%E7%A7%91%E6%8A%80/"/>
    
  </entry>
  
  <entry>
    <title>微信小游戏那些坑</title>
    <link href="http://jianghao.wang/2018/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
    <id>http://jianghao.wang/2018/微信小游戏那些坑/</id>
    <published>2018-01-12T10:04:24.000Z</published>
    <updated>2018-01-15T09:55:49.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-未找到入口-app-json-文件，或者文件读取失败，请检查后重新编译"><a href="#1-未找到入口-app-json-文件，或者文件读取失败，请检查后重新编译" class="headerlink" title="1.未找到入口 app.json 文件，或者文件读取失败，请检查后重新编译"></a>1.未找到入口 app.json 文件，或者文件读取失败，请检查后重新编译</h4><p>微信小程序和小游戏在微信公众号是两个不同的东西，安装开发者工具错误安装了微信小程序。从微信开放平台重新瞎下载<a href="https://mp.weixin.qq.com/debug/wxagame/dev/devtools/download.html?t=2018110" target="_blank" rel="noopener">微信游戏开发者工具</a>最新版本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-未找到入口-app-json-文件，或者文件读取失败，请检查后重新编译&quot;&gt;&lt;a href=&quot;#1-未找到入口-app-json-文件，或者文件读取失败，请检查后重新编译&quot; class=&quot;headerlink&quot; title=&quot;1.未找到入口 app.json 文
      
    
    </summary>
    
    
      <category term="大搜车微信小游戏学习点滴" scheme="http://jianghao.wang/tags/%E5%A4%A7%E6%90%9C%E8%BD%A6%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%AD%A6%E4%B9%A0%E7%82%B9%E6%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>SSH无密码登录</title>
    <link href="http://jianghao.wang/2018/SSH%E6%97%A0%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95/"/>
    <id>http://jianghao.wang/2018/SSH无密码登录/</id>
    <published>2018-01-11T09:16:55.000Z</published>
    <updated>2018-03-27T02:14:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>​工作中经常需要登录服务器，每次都需要输入服务器登录密码是相当麻烦的，我们可以通过设置RSA密钥对免密码登录。通过本地配置私钥，服务器配置公钥，并且保证私钥不丢失的情况下，服务器可以验证发送方身份唯一，并且报文是未被修改的。</p><h4 id="生成一对密钥"><a href="#生成一对密钥" class="headerlink" title="生成一对密钥"></a>生成一对密钥</h4><p>打开终端，通过ssh-keygen生成RSA密钥对，-t表示type，表示生成rsa加密的钥匙：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>RSA是默认的加密类型，默认长度为2048位，可以指定长度为4096更安全：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -b <span class="number">4096</span> -t rsa</span><br></pre></td></tr></table></figure><p>按Enter键，然后需要输入一个密码来加密你的SSH Key．密码至少要20位长度．SSH密钥会保存在home目录下的<strong>.ssh/id_rsa</strong>文件中．SSH公钥保存在<strong>.ssh/id_rsa.pub</strong>文件中。这里的id是我们在输入的时候指定的文件名。</p><p><img src="https://arthornye.github.io/images/keygen.png" alt="cmd-markdown-logo"></p><h4 id="配置config文件"><a href="#配置config文件" class="headerlink" title="配置config文件"></a>配置config文件</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure><p>打开config文件，如果不存在，自己新建一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfile m config</span><br></pre></td></tr></table></figure><p>当前我本地的config配置为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line"> IdentityFile ~/.ssh/id_rsa</span><br><span class="line">Host jhost</span><br><span class="line">   User yeqiaozhu</span><br><span class="line">   HostName jhost.hz.souche-inc.com</span><br><span class="line">   IdentityFile ~/.ssh/jump_rsa</span><br><span class="line">Host stable</span><br><span class="line">   User souche</span><br><span class="line">   HostName 172.17.40.227</span><br><span class="line">   IdentityFile ~/.ssh/stable_rsa</span><br></pre></td></tr></table></figure><p>其中stable是我增加的配置项，这里的几个参数可以注意下：</p><ul><li>Host：别名，我们可以通过ssh stable进行登录。</li><li>User：username@hostname我们通常通过这种方式指定登录的远程服务器，username填写对应的就行。</li><li>HostName：同User的方式。</li><li>IdentityFile：配置生成的rsa私钥的地址，我们的所有请求报文都会先进行hash之后获得digest然后通过私钥加密。</li></ul><h4 id="配置服务器公钥"><a href="#配置服务器公钥" class="headerlink" title="配置服务器公钥"></a>配置服务器公钥</h4><h5 id="登陆服务器手动配置"><a href="#登陆服务器手动配置" class="headerlink" title="登陆服务器手动配置"></a>登陆服务器手动配置</h5><p>可以直接将公钥粘贴到服务器authorized_keys文件中。</p><h5 id="命令直接配置"><a href="#命令直接配置" class="headerlink" title="命令直接配置"></a>命令直接配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i 公钥文件名(stable_rsa.pub) username@remote-server</span><br></pre></td></tr></table></figure><p>配置之后我们通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh stable</span><br></pre></td></tr></table></figure><p>可以直接登录到服务器：</p><p><img src="https://arthornye.github.io/images/login.png" alt="cmd-markdown-logo"></p><h5 id="碰到的问题"><a href="#碰到的问题" class="headerlink" title="碰到的问题"></a>碰到的问题</h5><p><img src="https://arthornye.github.io/images/msg.png" alt="cmd-markdown-logo"></p><p>目录文件权限太大，需要调整权限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R <span class="number">700</span> ~/.ssh</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>设置SSH免密登录，学习本地~/.ssh文件夹中的配置项即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​工作中经常需要登录服务器，每次都需要输入服务器登录密码是相当麻烦的，我们可以通过设置RSA密钥对免密码登录。通过本地配置私钥，服务器配置公钥，并且保证私钥不丢失的情况下，服务器可以验证发送方身份唯一，并且报文是未被修改的。&lt;/p&gt;
&lt;h4 id=&quot;生成一对密钥&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="大搜车的点滴记录" scheme="http://jianghao.wang/tags/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%9A%84%E7%82%B9%E6%BB%B4%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>数字签名和数字证书</title>
    <link href="http://jianghao.wang/2018/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/"/>
    <id>http://jianghao.wang/2018/数字签名和数字证书/</id>
    <published>2018-01-02T13:05:53.000Z</published>
    <updated>2018-03-27T02:37:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直对RSA等非对称性加密算法理解不够透彻，这几天看到一篇英文文档<a href="http://www.youdzone.com/signature.html" target="_blank" rel="noopener">What is a Digital Signature?</a>介绍较为通俗。本文主要对该文档进行理解翻译：</p><h3 id="数字签名是什么"><a href="#数字签名是什么" class="headerlink" title="数字签名是什么"></a>数字签名是什么</h3><p>主人公Bob拥有两个钥匙，公钥（public key）+私钥（private key），我们可以通过算法随机生成一对密钥。</p><h4 id="公钥和私钥"><a href="#公钥和私钥" class="headerlink" title="公钥和私钥"></a>公钥和私钥</h4><p>​    公钥是对外的，每个人都可以获取到Bob的公钥，但是私钥是自己的。之前项目中有配置过支付宝生活号的密钥，通过本地生成一对RSA密钥，私钥保存在本地，公钥配置到支付宝生活号，同时获取到支付宝生活号服务的公钥保存到本地。通过互换公钥达到双方通信都能保证发送方唯一并且报文不被篡改。</p><h5 id="如何理解公私钥"><a href="#如何理解公私钥" class="headerlink" title="如何理解公私钥"></a>如何理解公私钥</h5><p>​        Bob的公钥，所有需要的人都可以获取到，保证私钥是私有的情况下。密钥是用来加密的，加密的信息是不可逆的，所以只有当对方拥有配对的钥匙的时候才能解开加密后的信息，密钥中的私钥和公钥都可以用来加密，然后另个钥匙对应解密。（这里可能有些人会不理解这两种加密如何区分，我们通常将私钥加密称之为签名也就是Digital Signature，公钥加密称之为加密，因为它并不能代表某种唯一的身份，而私钥加密的报文可以）。</p><h5 id="如何理解Hash算法"><a href="#如何理解Hash算法" class="headerlink" title="如何理解Hash算法"></a>如何理解Hash算法</h5><p>​    我们这里和之后讲的hash算法是区别于一般的hash算法，通常我们将其理解为散列算法，每个x的输入得到唯一对应y输出（不排除随机碰撞导致产生的y一致），hash算法是密码学的基础，我们通常用md5和sha，这里有最重要的两条性质：</p><p>1.不可逆。所谓的不可逆的意思就是当你知道x的hash值，无法求出x。</p><p>2.无冲突。所谓的无冲突的意思就是当你知道x，无法求出一个y，使得x和y的hash值是相同的。</p><p>​    王小云教授制造了md5的碰撞，这样的碰撞是随机的，那么我们假设x和y的hash值碰撞，那么x和y在篡改了之后接收方是无法感知到的。但实际情况我们的输入x都是随机变化的，如果建立x到相同碰撞y的映射，这样的概率事件目前暂时不可能打败无冲突理论。</p><h4 id="数字签名是如何工作的"><a href="#数字签名是如何工作的" class="headerlink" title="数字签名是如何工作的"></a>数字签名是如何工作的</h4><p>我们假设现在Bob需要传送一份文档给某个同事，在这个过程中同事接受到文档后认为安全需要保证两个前提：</p><p>1.文档是由Bob发出的。</p><p>2.文档的内容没有被篡改（保证数据完整性 CIA中C = Confidentiality (机密性), I = Integrity (完整性), A = Avalibility(可用性）。</p><p>我们通过数字签名保证：</p><p>1.私钥只有Bob存有，文档绝对是由Bob发出。</p><p>2.在发送文档的时候，对文档内容进行类似md5加密，获得hash结果作为消息概要message digest，绑定文档内容一并发送，同事接受到消息之后对文档完整性进行验证，比对文档内容hash的结果和公钥验签解密获得的hash结果是否一致。如果一致，代表消息由Bob发出，并且未被篡改；如果不一致代表消息由Bob发出，但是被篡改过。</p><h3 id="数字证书是什么"><a href="#数字证书是什么" class="headerlink" title="数字证书是什么"></a>数字证书是什么</h3><h4 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h4><p>之前尝试去理解了数字证书存在的必要性，既然非对称加密保证了通讯的完整性和来源，那么为何需要数字证书。想象一个场景，你在浏览器输入<a href="www.baidu.com">百度的网址</a>，那么这个域名有可能被中间人劫持，实际上跳转到了黑客的中间服务器，由中间服务器去转发你的请求报文，真实的服务器将响应报文转发给中间服务器。因为真实服务器的公钥是公开的，那么黑客可以将对应的报文解密，同时修改报文的内容和消息概要。然后用自己的私钥进行签名，同时将死钥对应的公钥配置在浏览器客户端。客户端无法确定自己当前解密的公钥是不是真实的服务器公钥。</p><p>所以实际上我们认为非对称加密保证的完整性和来源，实际上是不能抵御中间人攻击的。基于这种情况，我们需要有一个第三方也就是数字证书机构（Certification Authority，CA)来保证客户端使用到正确的公钥。</p><h4 id="数字证书的内容"><a href="#数字证书的内容" class="headerlink" title="数字证书的内容"></a>数字证书的内容</h4><p>给予上面的假设，我们可以想象一下数字证书需要准备哪些内容。具体的内容可能包含很多。个人觉得从理解上来说，这个数字证书的目的是需要保证客户端获取到正确的公钥进行解密，那么我们需要绑定一开始请求的域名和公钥（注册到CA），客户端再接受到响应的时候便直接从本地去取这个证书中的公钥。</p><p>那么我们如何保证这个证书的正确性或者说合法性？理所当然这个证书中必须带有响应CA的数字签名。        </p><p>主流操作系统和浏览器里面会提前预置一些 CA 的证书(承认这些是合法的证书)，然后所有基于他们认证的签名都会自然被认为合法。</p><h4 id="数字证书的简单过程"><a href="#数字证书的简单过程" class="headerlink" title="数字证书的简单过程"></a>数字证书的简单过程</h4><p>数字证书Signature Certificate，在之前Bob和A同事通信的模型下，我们想象如果A同事的公钥被篡改成了B同事的公钥，A同事根本不知道自己接收到的消息来源已经默默从Bob变成了B同事。现实开发过程中也是很有可能发生，如果自己生成一对密钥，只要替换了公钥，另一方是无法感知到消息源的。为了防止这种情况发生，我们需要为消息源建立一个身份认证，类似身份证，我们需要第三方来证明自己的来源，做一个唯一的标示，那么我们在发送消息的时候附送上这个三方的数字证书，接收方直接通过三方提供的公钥来验签解密获取到公钥来进行验签。</p><p><img src="https://arthornye.github.io/images/certificate.png" alt="cmd-markdown-logo"></p><h3 id="PKI-体系（Public-Key-Infrastructure）"><a href="#PKI-体系（Public-Key-Infrastructure）" class="headerlink" title="PKI 体系（Public Key Infrastructure）"></a>PKI 体系（Public Key Infrastructure）</h3><p>PKI体系在现代密码学领域中处于较为基础的地位，帮助解决了核心的证书管理问题。</p><p>一般情况下，PKI 至少包括如下组件:</p><ul><li>CA(Certification Authority):负责证书的颁发和作废，接收来自 RA 的请求，是最核心的部分;</li><li>bRA(Registration Authority):对用户身份进行验证，校验数据合法性，负责登记，审核过了就发给 CA;<ul><li>证书数据库:存放证书，一般采用 LDAP 目录服务，标准格式采用 X.500 系列。CA 是最核心的组件，主要完成对证书的管理。</li></ul></li></ul><p>CA 是最核心的组件，主要完成对证书的管理。</p><p>常见的流程为，用户通过 RA 登记申请证书，CA 完成证书的制造，颁发给用户。用户需要撤销证书则向 CA 发出申请。</p><p>用户证书可以有两种方式。一般可以由 CA 来生成证书和私钥;也可以自己生成公钥和私钥，然后由 CA 来对公钥进行签发。后者情况下，当用户私钥丢失后，CA 无法完成恢复。</p><p>​<br>​<br>​        </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直对RSA等非对称性加密算法理解不够透彻，这几天看到一篇英文文档&lt;a href=&quot;http://www.youdzone.com/signature.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;What is a Digital Signat
      
    
    </summary>
    
    
      <category term="科技" scheme="http://jianghao.wang/tags/%E7%A7%91%E6%8A%80/"/>
    
  </entry>
  
  <entry>
    <title>Teamvier12试用版到期解决办法</title>
    <link href="http://jianghao.wang/2017/teamvier12/"/>
    <id>http://jianghao.wang/2017/teamvier12/</id>
    <published>2017-12-28T08:53:37.000Z</published>
    <updated>2017-12-28T08:53:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下工作中因误使用Teamvier12的试用版导致重复安装无法逃避服务端的试用版检测，提示试用版到期无法使用。解决办法：</p><h3 id="卸载Teamvier并清除所有注册表信息"><a href="#卸载Teamvier并清除所有注册表信息" class="headerlink" title="卸载Teamvier并清除所有注册表信息"></a>卸载Teamvier并清除所有注册表信息</h3><h3 id="修改MAC地址："><a href="#修改MAC地址：" class="headerlink" title="修改MAC地址："></a>修改MAC地址：</h3><p>windows7以及以上操作系统需要注意修改的MAC地址八位16进制，第二位需要是2，6，A，E其中一个，否则MAC地址重置无效，并且修改之后网络也会重连（实际并未生效）。</p><h3 id="重新安装Teamvier12"><a href="#重新安装Teamvier12" class="headerlink" title="重新安装Teamvier12"></a>重新安装Teamvier12</h3><p>重新安装Teamvier12会发现之前的ID已经被重置。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>Teamvier通过首次安装记录本机的MAC地址和对应的ID到服务器，两者的绑定验证设备的唯一性。更改设备的MAC地址可以解决设备验证问题，一定要注意更改是否生效，确认操作系统的MAC修改规则。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录一下工作中因误使用Teamvier12的试用版导致重复安装无法逃避服务端的试用版检测，提示试用版到期无法使用。解决办法：&lt;/p&gt;
&lt;h3 id=&quot;卸载Teamvier并清除所有注册表信息&quot;&gt;&lt;a href=&quot;#卸载Teamvier并清除所有注册表信息&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="Daily" scheme="http://jianghao.wang/tags/Daily/"/>
    
  </entry>
  
  <entry>
    <title>Cglib动态代理</title>
    <link href="http://jianghao.wang/2017/Cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://jianghao.wang/2017/Cglib动态代理/</id>
    <published>2017-05-20T11:52:18.000Z</published>
    <updated>2017-05-20T11:52:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Cglib动态代理实现"><a href="#Cglib动态代理实现" class="headerlink" title="Cglib动态代理实现"></a>Cglib动态代理实现</h3><h4 id="Cglib动态代理代码实现"><a href="#Cglib动态代理代码实现" class="headerlink" title="Cglib动态代理代码实现"></a>Cglib动态代理代码实现</h4><p>Cglib是一个开源框架，可以在maven项目的pom.xml中引用,通过Cglib可以实现不依赖于接口的动态代理模式。同JDK动态代理实现模式对比，Cglib依赖类继承和重写，JDK依赖接口实现和方法实现。下面用Java实现Cglib动态代理：</p><p>1.定义一个不基于实现接口的类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieStar</span> <span class="keyword">extends</span> <span class="title">Star</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">movieShow</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行演员功能"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.实现MethodIntercepter接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyHandler</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    Object target=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibProxyHandler</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target=target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());</span><br><span class="line">        <span class="comment">// 回调方法</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一个参数 代理对象，动态生成，通过getInstance方法获取</span></span><br><span class="line">    <span class="comment">//第二个参数 委托类方法，实现的MovieStar类对象</span></span><br><span class="line">    <span class="comment">//第三个参数 方法参数，传递给委托类对象方法的参数</span></span><br><span class="line">    <span class="comment">//第四个参数 代理方法的MethodProxy对象，委托类每个方法都对应一个MethodProxy对象</span></span><br><span class="line">    <span class="comment">//methodProxy.invokeSuper方法实际调用MethodProxy对象中的invokeSuper方法，MethodProxy对象内部定义了一个静态内部类，保存了动态生成的代理类对象和委托类对象引用类型为FastClass(提供通过索引的方式定位到具体方法)。通过调用代理类对象中的invoke方法，需要传人方法索引，代理对象和方法参数。调用CGLIB$movieShow$0方法执行super.movieShow()。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"准备开始执行代理类方法"</span>);</span><br><span class="line">        methodProxy.invokeSuper(o,objects);</span><br><span class="line">        System.out.println(<span class="string">"已经执行完代理类方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.客户端调用动态生成代理类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MovieStar movieStar=<span class="keyword">new</span> MovieStar();</span><br><span class="line">        CglibProxyHandler cglibProxyHandler=<span class="keyword">new</span> CglibProxyHandler(movieStar);</span><br><span class="line">        MovieStar star=(MovieStar)cglibProxyHandler.getInstance();</span><br><span class="line">        star.movieShow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4.输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">准备开始执行代理类方法</span><br><span class="line">执行演员功能</span><br><span class="line">已经执行完代理类方法</span><br></pre></td></tr></table></figure></p><h3 id="Cglib动态代理源码阅读对比JDK动态代理"><a href="#Cglib动态代理源码阅读对比JDK动态代理" class="headerlink" title="Cglib动态代理源码阅读对比JDK动态代理"></a>Cglib动态代理源码阅读对比JDK动态代理</h3><p>读源码相对还是比较抽象，笔者也主要阐述一些自己对Cglib动态代理源码的理解。其实无论是Cglib还是JDK动态代理实际上都是探讨如何设计这个动态生成的代理类，将所有的工作交给运行时过程去动态维护而不是人工维护。</p><h4 id="Cglib动态代理与JDK动态代理基本区别"><a href="#Cglib动态代理与JDK动态代理基本区别" class="headerlink" title="Cglib动态代理与JDK动态代理基本区别"></a>Cglib动态代理与JDK动态代理基本区别</h4><p>1.Cglib动态代理委托类不需要实现接口，扩展性更强，而JDK动态代理通过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy.newProxyInstance(mtarget.getClass().getClassLoader(),mtarget.getClass().getInterfaces(),<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure></p><p>的方式去反射出一个代理类就必然需要获取到委托类对象的接口信息。<br>2.Cglib动态代理不依赖于JDK的反射，而是定义了一个方法入口的索引，这样的实现方式较JDK动态代理的反射实现方式是高效的。<br>3.Cglib动态代理中生成的字节码更加复杂，生成的代理类是委托类的子类，且不能处理被final关键字修饰的方法。</p><h4 id="Cglib动态代理源码实现"><a href="#Cglib动态代理源码实现" class="headerlink" title="Cglib动态代理源码实现"></a>Cglib动态代理源码实现</h4><p>不多说，先上图：<br><img src="arthornye.github.io/images/Cglib动态代理实现.png" alt="cmd-markdown-logo"></p><h5 id="动态生成的代理类实例"><a href="#动态生成的代理类实例" class="headerlink" title="动态生成的代理类实例"></a>动态生成的代理类实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.core.Signature;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.core.ReflectUtils;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Callback;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span>$$<span class="title">EnhancerByCGLIB</span>$$394<span class="title">dddeb</span> <span class="keyword">extends</span> <span class="title">UserService</span> <span class="keyword">implements</span> <span class="title">Factory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> CGLIB$BOUND;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal CGLIB$THREAD_CALLBACKS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Callback[] CGLIB$STATIC_CALLBACKS;</span><br><span class="line">    <span class="comment">//对应拦截器对象的引用</span></span><br><span class="line">    <span class="keyword">private</span> MethodInterceptor CGLIB$CALLBACK_0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$add$<span class="number">0</span>$Method;</span><br><span class="line">    <span class="comment">//对应委托类中的add方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$add$<span class="number">0</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] CGLIB$emptyArgs;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$STATICHOOK2() &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        CGLIB$emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; forName = Class.forName(<span class="string">"UserService$$EnhancerByCGLIB$$394dddeb"</span>);</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; forName3;</span><br><span class="line">        CGLIB$add$<span class="number">0</span>$Method = ReflectUtils.findMethods(<span class="keyword">new</span> String[] &#123; <span class="string">"add"</span>, <span class="string">"()V"</span> &#125;, (forName3 = Class.forName(<span class="string">"UserService"</span>)).getDeclaredMethods())[<span class="number">0</span>];</span><br><span class="line">        CGLIB$add$<span class="number">0</span>$Proxy = MethodProxy.create((Class)forName3, (Class)forName, <span class="string">"()V"</span>, <span class="string">"add"</span>, <span class="string">"CGLIB$add$0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//动态生成的调用委托类中对应方法</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> CGLIB$add$<span class="number">0</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.add();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//暴露的动态代理服务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_2;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> ((cglib$CALLBACK_0 = (cglib$CALLBACK_2 = <span class="keyword">this</span>.CGLIB$CALLBACK_0)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            cglib$CALLBACK_2 = (cglib$CALLBACK_0 = <span class="keyword">this</span>.CGLIB$CALLBACK_0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cglib$CALLBACK_0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cglib$CALLBACK_2.intercept((Object)<span class="keyword">this</span>, UserService$$EnhancerByCGLIB$$<span class="number">394</span>dddeb.CGLIB$add$<span class="number">0</span>$Method, UserService$$EnhancerByCGLIB$$<span class="number">394</span>dddeb.CGLIB$emptyArgs, UserService$$EnhancerByCGLIB$$<span class="number">394</span>dddeb.CGLIB$add$<span class="number">0</span>$Proxy);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.add();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        CGLIB$STATICHOOK2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="MethodProxy对象"><a href="#MethodProxy对象" class="headerlink" title="MethodProxy对象"></a>MethodProxy对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodProxy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Signature sig1;</span><br><span class="line">    <span class="keyword">private</span> Signature sig2;</span><br><span class="line">    <span class="keyword">private</span> MethodProxy.CreateInfo createInfo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object initLock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> MethodProxy.FastClassInfo fastClassInfo;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invokeSuper</span><span class="params">(Object obj, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        init();</span><br><span class="line">        FastClassInfo fci = fastClassInfo;</span><br><span class="line">        <span class="keyword">return</span> fci.f2.invoke(fci.i2, obj, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.getTargetException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*单看invokeSuper方法的实现，似乎看不出委托类add方法调用，在MethodProxy实现中，通过FastClassInfo维护了委托类和代理类的FastClass。*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FastClassInfo</span> </span>&#123;</span><br><span class="line">    FastClass f1;</span><br><span class="line">    FastClass f2;</span><br><span class="line">    <span class="keyword">int</span> i1;</span><br><span class="line">    <span class="keyword">int</span> i2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*以add方法的methodProxy为例，f1指向委托类对象，f2指向代理类对象，i1和i2分别是方法add和CGLIB$add$0在对象中索引位置*/</span></span><br></pre></td></tr></table></figure><h5 id="FastClass实现机制"><a href="#FastClass实现机制" class="headerlink" title="FastClass实现机制"></a>FastClass实现机制</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*FastClass其实就是对Class对象进行特殊处理，提出下标概念index，通过索引保存方法的引用信息，将原先的反射调用，转化为方法的直接调用，从而体现所谓的fast，下面通过一个例子了解一下FastClass的实现机制。*/</span></span><br><span class="line"><span class="number">1</span>、定义原类</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"f method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"g method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、定义Fast类</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FastTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(String signature)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(signature.hashCode())&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3078479</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3108270</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">int</span> index, Object o, Object[] ol)</span></span>&#123;</span><br><span class="line">        Test t = (Test) o;</span><br><span class="line">        <span class="keyword">switch</span>(index)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            t.f();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            t.g();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在FastTest中有两个方法，getIndex中对Test类的每个方法根据hash建立索引，invoke根据指定的索引，直接调用目标方法，避免了反射调用。所以当调用methodProxy.invokeSuper方法时，实际上是调用代理类的CGLIB$add$0方法，CGLIB$add$0直接调用了委托类的add方法*/</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于本篇Cglib动态代理源码的解读可能并没有很大的实际价值，笔者倒觉得这种实现方式源码逻辑封装得过于复杂。可以简单的理解Cglib动态生成的代理类是为每个委托类的方法维护了两个方法，一个是客户端调用入口方法，一个是通往其父委托类的入口，这样增大了字节码的复杂度，用空间换取了时间，实现了高效，同时不基于接口实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Cglib动态代理实现&quot;&gt;&lt;a href=&quot;#Cglib动态代理实现&quot; class=&quot;headerlink&quot; title=&quot;Cglib动态代理实现&quot;&gt;&lt;/a&gt;Cglib动态代理实现&lt;/h3&gt;&lt;h4 id=&quot;Cglib动态代理代码实现&quot;&gt;&lt;a href=&quot;#Cgli
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java静态代理与动态代理</title>
    <link href="http://jianghao.wang/2017/Java%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://jianghao.wang/2017/Java静态代理与动态代理/</id>
    <published>2017-05-18T13:15:52.000Z</published>
    <updated>2017-05-18T13:15:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式从字面理解可以和网络中的代理类比，之前的一篇博文中介绍了ngrok反向代理和nginx负载均衡。这整个链路都存在三个主体，客户端对象，代理对象，被代理对象。实际上java编程中代理模式也可以从这个链路过程去考虑。<br><img src="http://arthornye.github.io/images/Java静态代理与动态代理/代理模式.png" alt="cmd-markdown-logo"></p><h3 id="Java静态代理"><a href="#Java静态代理" class="headerlink" title="Java静态代理"></a>Java静态代理</h3><h4 id="Java静态代理的代码实现"><a href="#Java静态代理的代码实现" class="headerlink" title="Java静态代理的代码实现"></a>Java静态代理的代码实现</h4><p>1.创建一个明星类接口定义行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMovieStar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">movieShow</span><span class="params">(<span class="keyword">int</span> money)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tvShow</span><span class="params">(<span class="keyword">int</span> money)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.实现这个明星类接口(被代理对象)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Star</span> <span class="keyword">implements</span> <span class="title">IMovieStar</span> </span>&#123;</span><br><span class="line">    String starname;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Star</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.starname=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">movieShow</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        System.out.println(starname+<span class="string">"出演了一部"</span>+money+<span class="string">"的电影！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tvShow</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        System.out.println(starname+<span class="string">"出演了一部"</span>+money+<span class="string">"的电视剧！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.静态代理类(实现明星类接口，并定义对象)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxyHandler</span> <span class="keyword">implements</span> <span class="title">IMovieStar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  IMovieStar star;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">StaticProxyHandler</span><span class="params">(IMovieStar star)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.star=star;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">movieShow</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before method"</span>);</span><br><span class="line">        star.movieShow(<span class="number">100000</span>);</span><br><span class="line">        System.out.println(<span class="string">"after method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tvShow</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before method"</span>);</span><br><span class="line">        star.tvShow(<span class="number">200000</span>);</span><br><span class="line">        System.out.println(<span class="string">"after method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.客户端调用代理对象:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Star huangbo=<span class="keyword">new</span> Star(<span class="string">"huangbo"</span>);</span><br><span class="line">       <span class="comment">// ProxyHandler agenthandler=new ProxyHandler(huangbo);</span></span><br><span class="line">        StaticProxyHandler agenthandler=<span class="keyword">new</span> StaticProxyHandler(huangbo);</span><br><span class="line">        agenthandler.movieShow(<span class="number">100000</span>);</span><br><span class="line">        agenthandler.tvShow(<span class="number">200000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">before method</span><br><span class="line">huangbo出演了一部<span class="number">100000</span>的电影！</span><br><span class="line">after method</span><br><span class="line">before method</span><br><span class="line">huangbo出演了一部<span class="number">200000</span>的电视剧！</span><br><span class="line">after method</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>静态代理实际上是对代理对象的一个组合封装，通过代理对象去增强被代理对象的方法逻辑,在方法执行前增加了代理对象的逻辑，实现了代码的复用和解耦合。缺点是如果接口行为发生改变，如增加了接口，那么代理类和被代理类都需要改变（因为都实现了这个接口），同时如果需要对代理类的每个方法都添加统一的逻辑。如打日志通用的业务逻辑，通过静态代理的方式需要手动增加大量代码，不利于扩展。</p><h3 id="Java动态代理"><a href="#Java动态代理" class="headerlink" title="Java动态代理"></a>Java动态代理</h3><h4 id="Java动态代理的代码实现"><a href="#Java动态代理的代码实现" class="headerlink" title="Java动态代理的代码实现"></a>Java动态代理的代码实现</h4><p>1.动态代理类（实现InvocationHandler接口）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object mtarget;<span class="comment">//被代理类对象，对应某个明星类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">ProxyHandler</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mtarget=target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//关联的这个实现类的方法被调用时将被执行  </span></span><br><span class="line">    <span class="comment">/*InvocationHandler接口的方法，proxy表示代理，method表示原对象被调用的方法，args表示方法的参数*/</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String methodname=method.getName();</span><br><span class="line">        <span class="keyword">if</span>(methodname.equals(<span class="string">"movieShow"</span>) || methodname.equals(<span class="string">"tvShow"</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(args[<span class="number">0</span>]<span class="keyword">instanceof</span> Integer &amp;&amp; (<span class="keyword">int</span>)args[<span class="number">0</span>]&lt;<span class="number">3000000</span>)&#123;</span><br><span class="line">                 System.out.println(((<span class="keyword">int</span>) args[<span class="number">0</span>])+<span class="string">"?价格不达标不演"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Object result=method.invoke(mtarget,args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取代理</span></span><br><span class="line">    <span class="comment">//该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例    </span></span><br><span class="line">    <span class="comment">//第一个参数指定产生代理对象的类加载器，需要将其指定为和目标对象同一个类加载器  </span></span><br><span class="line">    <span class="comment">//第二个参数要实现和目标对象一样的接口，所以只需要拿到目标对象的实现接口  </span></span><br><span class="line">    <span class="comment">//第三个参数表明这些被拦截的方法在被拦截时需要执行哪个InvocationHandler的invoke方法  </span></span><br><span class="line">    <span class="comment">//根据传入的目标返回一个代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(mtarget.getClass().getClassLoader(),mtarget.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.客户端调用代理对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Star huangbo=<span class="keyword">new</span> Star(<span class="string">"huangbo"</span>);</span><br><span class="line">        ProxyHandler agenthandler=<span class="keyword">new</span> ProxyHandler(huangbo);</span><br><span class="line">        IMovieStar agent= (IMovieStar) agenthandler.getProxy();</span><br><span class="line">        agent.movieShow(<span class="number">100000</span>);</span><br><span class="line">        agent.tvShow(<span class="number">200000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100000</span>?价格不达标不演</span><br><span class="line">huangbo出演了一部<span class="number">100000</span>的电影！</span><br><span class="line"><span class="number">200000</span>?价格不达标不演</span><br><span class="line">huangbo出演了一部<span class="number">200000</span>的电视剧！</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>这里的动态代理更准确来说是JDK动态代理，它通过实现InvocationHandler接口的ProxyHandler类以发射的方式动态生成一个代理类（对应于我们上面的StaticProxyHandler）。代理类在调用每个方法时实际上执行的都是ProxyHandler类中的invoke方法，这样我们可以理解到这个代理类实际上是在生成实现类之后在每个方法中进行了反射调用。</p><h3 id="Java静态代理与动态代理对比"><a href="#Java静态代理与动态代理对比" class="headerlink" title="Java静态代理与动态代理对比"></a>Java静态代理与动态代理对比</h3><p>Java静态代理是静态的，需要手动维护代理类，当接口变动时需要人为感知，同时修改被代理类和代理类，同时需要为每个接口的实现方法去手动添加一套逻辑。动态代理是动态的，接口变动时因为通过反射机制能够追溯到接口的变化情况去动态生成代理类，那么只需要手动修改被代理类即可，同时它会在每个实现方法中去自动添加一套逻辑。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>其实一开始想了解Spring AOP，最后发现AOP的面向切面编程也是基于JDK动态代理和CGLIB动态代理实现。之后会重点介绍这两种动态代理的区别已经在Spring AOP中的运用。</p><hr><p>在此输入正文</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h3&gt;&lt;p&gt;代理模式从字面理解可以和网络中的代理类比，之前的一篇博文中介绍了ngrok反向代理和nginx负载均衡。这整个链路都存在三个
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于栈的解释执行引擎</title>
    <link href="http://jianghao.wang/2017/%E5%9F%BA%E4%BA%8E%E6%A0%88%E7%9A%84%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <id>http://jianghao.wang/2017/基于栈的解释执行引擎/</id>
    <published>2017-05-10T05:10:35.000Z</published>
    <updated>2017-05-10T05:10:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>相信用过Java的都对解释执行这个名词不陌生，但是可能大多数人都不能理解解释执行的意义，以及虚拟机为什么采用解释执行的方式，有什么利弊，它是如何被执行的。本篇博文标题是基于栈的解释执行引擎，那么我们可以直观理解，解释执行操作的是栈，栈存在于虚拟机内存中，频繁的入栈出栈都是对内存的频繁读写，这也是Java在性能上较之C++等编译执行语言所不足的地方，对内存的读写操作较寄存器总是低效。</p><h3 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h3><p>解释执行是相对编译执行的一个概念，类比java和c++，解释执行基于字节码，编译执行相对于汇编指令。字节码指令只要相应的解释器都能识别，不依赖于CPU寄存器结构和操作系统，汇编指令则是基于CPU寄存器的操作指令，不同的操作系统会根据CPU的不同导致编译不同的结果。这也是java能跨平台而c++不能跨平台的原因，因为不同的操作系统对硬件的适配不同，所以linux和windows系统对c++等编译执行的语言都有不同的编译器，windows上可执行的程序在linux上是无法执行的。</p><p>Java字节码在执行的解释执行的过程中不依赖于CPU寄存器结构，不代表不会利用寄存器优化执行性能。因为现代计算机的缓存结构是金子塔尖形状，寄存器的读写性能是最优也是最昂贵的，所以Java会把频繁访问的操作数栈顶元素优化缓存的到寄存器中。</p><h3 id="基于栈的指令集和基于寄存器的指令集"><a href="#基于栈的指令集和基于寄存器的指令集" class="headerlink" title="基于栈的指令集和基于寄存器的指令集"></a>基于栈的指令集和基于寄存器的指令集</h3><p>栈指令集的优点：</p><blockquote><ul><li>可移植，寄存器由CPU直接提供不受型号限制，虚拟机可以自行利用寄存器优化性能。</li><li>代码相对紧凑，字节码中每个字节代表一个指令。</li><li>编译器实现简单，不用考虑分配空间，都在栈上进行操作。</li></ul></blockquote><p>栈指令集的缺点：</p><blockquote><ul><li>栈指令集数量较寄存器指令集数量更多。</li><li>栈指令集操作内存执行速度更慢。</li></ul></blockquote><h3 id="基于栈的解释器执行过程"><a href="#基于栈的解释器执行过程" class="headerlink" title="基于栈的解释器执行过程"></a>基于栈的解释器执行过程</h3><p>这里以一段四则运算的代码为例，演示解释器执行字节码的过程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">200</span>;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">300</span>;</span><br><span class="line">    <span class="keyword">return</span> (a+b)*c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过javap -v test.class查看解释编译之后的字节码指令:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">   flags: ACC_PUBLIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: bipush        <span class="number">100</span></span><br><span class="line">        <span class="number">2</span>: istore_1</span><br><span class="line">        <span class="number">3</span>: sipush        <span class="number">200</span></span><br><span class="line">        <span class="number">6</span>: istore_2</span><br><span class="line">        <span class="number">7</span>: sipush        <span class="number">300</span></span><br><span class="line">       <span class="number">10</span>: istore_3</span><br><span class="line">       <span class="number">11</span>: iload_1</span><br><span class="line">       <span class="number">12</span>: iload_2</span><br><span class="line">       <span class="number">13</span>: iadd</span><br><span class="line">       <span class="number">14</span>: iload_3</span><br><span class="line">       <span class="number">15</span>: imul</span><br><span class="line">       <span class="number">16</span>: ireturn</span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">       line <span class="number">9</span>: <span class="number">3</span></span><br><span class="line">       line <span class="number">10</span>: <span class="number">7</span></span><br><span class="line">       line <span class="number">11</span>: <span class="number">11</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><p>观察Code部分显示栈深度为2，局部变量表为4个Slot大小，下面演示这段字节码是如何被解释执行的。</p><p><img src="http://arthornye.github.io/images/%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C.png" alt="cmd-markdown-logo"></p><p>这里需要着重解释的一个概念是，虽然虚拟机栈的栈帧在执行过程中局部变量表充当了变量拷贝的角色，有些书上会将堆栈结构类比java并发工作内存和主内存。实际上这里的局部变量表只是在栈中的一份变量拷贝，生命周期是栈帧的生命周期，工作内存是基于高速缓存和主内存这样的缓存结构的，会从一级缓冲向主内存不断会写。如果说强行要将栈类比到工作内存，实际上字节码在执行过程中需要利用现代高速缓存结构这样的概念模型可以类比，如写对象属性操作。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇并没有过多强调和介绍所有的字节码指令，而是展示了字节码指令在执行过程中的几个重要部分，希望读者有一个概念模型上的理解，实际上虚拟机在指令生成过程中会进行很多优化。本文也是解决了我在阅读java并发内存模型中的一些困惑，堆栈模型和java并发内存模型存在本质上的区别，不能完全进行类比，对CAS原子操作的理解也更加深刻。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相信用过Java的都对解释执行这个名词不陌生，但是可能大多数人都不能理解解释执行的意义，以及虚拟机为什么采用解释执行的方式，有什么利弊，它是如何被执行的。本篇博文标题是基于栈的解释执行引擎，那么我们可以直观理解，解释执行操作的是栈，栈存在于虚拟机内存中，频繁的入栈出栈都是对
      
    
    </summary>
    
    
  </entry>
  
</feed>
