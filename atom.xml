<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TizzyT&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/9dde1b9d65b89035e235650923e5811e</icon>
  <subtitle>即使是拖后腿的，拼死努力的话，也是可以超越精英的。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jianghao.wang/"/>
  <updated>2019-10-15T06:13:07.669Z</updated>
  <id>http://jianghao.wang/</id>
  
  <author>
    <name>yeqiaozhu</name>
    <email>yqz_zjut@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Target Sum</title>
    <link href="http://jianghao.wang/2019/P494%20Target%20Sum/"/>
    <id>http://jianghao.wang/2019/P494 Target Sum/</id>
    <published>2019-10-14T09:23:02.325Z</published>
    <updated>2019-10-15T06:13:07.669Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度中等-494）"><a href="#问题描述（难度中等-494）" class="headerlink" title="问题描述（难度中等-494）"></a>问题描述（难度中等-494）</h3><p>You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols <code>+</code> and <code>-</code>. For each integer, you should choose one from <code>+</code> and <code>-</code> as its new symbol.</p><p>Find out how many ways to assign symbols to make sum of integers equal to target S.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: nums is [1, 1, 1, 1, 1], S is 3. </span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 = 3</span><br><span class="line">+1-1+1+1+1 = 3</span><br><span class="line">+1+1-1+1+1 = 3</span><br><span class="line">+1+1+1-1+1 = 3</span><br><span class="line">+1+1+1+1-1 = 3</span><br><span class="line"></span><br><span class="line">There are 5 ways to assign symbols to make the sum of nums be target 3.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The length of the given array is positive and will not exceed 20.</li><li>The sum of elements in the given array will not exceed 1000.</li><li>Your output answer is guaranteed to be fitted in a 32-bit integer.</li></ol><h3 id="方法一：Using-Recursive"><a href="#方法一：Using-Recursive" class="headerlink" title="方法一：Using Recursive"></a>方法一：Using Recursive</h3><p>通过递归，递归有重复的子结构。可以通过DP改善。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P494;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归解决O(N^2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nums=nums;</span><br><span class="line">        <span class="keyword">return</span> findTargetSumWaysIndex(nums.length-<span class="number">1</span>,S);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWaysIndex</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[index]==<span class="number">0</span> &amp;&amp; S==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Math.abs(S)==Math.abs(nums[index])?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> findTargetSumWaysIndex(index-<span class="number">1</span>,S-nums[index])+findTargetSumWaysIndex(index-<span class="number">1</span>,S+nums[index]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> Solution().findTargetSumWays(ints,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：Using-DP"><a href="#方法二：Using-DP" class="headerlink" title="方法二：Using DP"></a>方法二：Using DP</h3><p>通过dp规避重复子问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P494;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-10-14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingDPSolution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i: nums) sum+=i;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;sum || s&lt;-sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*sum+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>+sum] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*sum+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k&lt;<span class="number">2</span>*sum+<span class="number">1</span>; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[k]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    next[k + nums[i]] += dp[k];</span><br><span class="line">                    next[k - nums[i]] += dp[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sum+s];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ints1=&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> UsingDPSolution().findTargetSumWays(ints,<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> UsingDPSolution().findTargetSumWays(ints1,<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的存储结构图：</p><p><img src="http://arthornye.github.io/images/dp.png" alt="cmd-markdown-logo"></p><h3 id="方法三：Using-DFS"><a href="#方法三：Using-DFS" class="headerlink" title="方法三：Using DFS"></a>方法三：Using DFS</h3><p>回溯可以通过递归的方式去实现。这里通过map保存下重复的运算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, <span class="number">0</span>, S, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, <span class="keyword">int</span> sum, <span class="keyword">int</span> S, Map&lt;String, Integer&gt; map)</span></span>&#123;</span><br><span class="line">        String encodeString = index + <span class="string">"-&gt;"</span> + sum;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(encodeString))&#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(encodeString);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == S)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> curNum = nums[index];</span><br><span class="line">        <span class="keyword">int</span> add = helper(nums, index + <span class="number">1</span>, sum - curNum, S, map);</span><br><span class="line">        <span class="keyword">int</span> minus = helper(nums, index + <span class="number">1</span>, sum + curNum, S, map);</span><br><span class="line">        map.put(encodeString, add + minus);</span><br><span class="line">        <span class="keyword">return</span> add + minus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度中等-494）&quot;&gt;&lt;a href=&quot;#问题描述（难度中等-494）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度中等-494）&quot;&gt;&lt;/a&gt;问题描述（难度中等-494）&lt;/h3&gt;&lt;p&gt;You are given a list o
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Comparator和Comparable接口</title>
    <link href="http://jianghao.wang/2019/Comparator%E5%92%8CComparable%E6%8E%A5%E5%8F%A3/"/>
    <id>http://jianghao.wang/2019/Comparator和Comparable接口/</id>
    <published>2019-10-12T03:23:57.487Z</published>
    <updated>2019-10-12T07:01:15.419Z</updated>
    
    <content type="html"><![CDATA[<p>通常我们自定义的一些类需要进行比较，要用到Comparator自定义比较器传递给对应容器或者实现Comparable接口。本文主要介绍两种方式的区别。</p><h3 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h3><p>Comparable是排序接口。若一个类实现了Comparable接口，就意味着该类支持排序。实现了Comparable接口的类的对象的列表或数组可以通过Collections.sort或Arrays.sort进行自动排序。此外，实现此接口的对象可以用作有序映射中的键或有序集合中的集合，无需指定比较器。该接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>此接口只有一个方法compare，比较此对象与指定对象的顺序，如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。</strong></p><h3 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a>Comparator接口</h3><p>Comparator是比较接口，我们如果需要控制某个类的次序，而该类本身不支持排序(即没有实现Comparable接口，那么我们就可以建立一个“该类的比较器”来进行排序，这个“比较器”只需要实现Comparator接口即可。也就是说，<strong><em>我们可以通过实现Comparator来自定义一个比较器</em></strong>，然后通过这个比较器对类进行排序。该接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.ToIntFunction;</span><br><span class="line"><span class="keyword">import</span> java.util.function.ToLongFunction;</span><br><span class="line"><span class="keyword">import</span> java.util.function.ToDoubleFunction;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparators;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title">reversed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.reverseOrder(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title">thenComparingInt</span><span class="params">(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thenComparing(comparingInt(keyExtractor));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title">thenComparingLong</span><span class="params">(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thenComparing(comparingLong(keyExtractor));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title">thenComparingDouble</span><span class="params">(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thenComparing(comparingDouble(keyExtractor));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function">Comparator&lt;T&gt; <span class="title">reverseOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.reverseOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function">Comparator&lt;T&gt; <span class="title">naturalOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Comparator&lt;T&gt;) Comparators.NaturalOrderComparator.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Comparator&lt;T&gt; <span class="title">nullsFirst</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Comparators.NullComparator&lt;&gt;(<span class="keyword">true</span>, comparator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Comparator&lt;T&gt; <span class="title">nullsLast</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Comparators.NullComparator&lt;&gt;(<span class="keyword">false</span>, comparator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U&gt; <span class="function">Comparator&lt;T&gt; <span class="title">comparing</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; keyExtractor,</span></span></span><br><span class="line"><span class="function"><span class="params">            Comparator&lt;? <span class="keyword">super</span> U&gt; keyComparator)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Objects.requireNonNull(keyExtractor);</span><br><span class="line">        Objects.requireNonNull(keyComparator);</span><br><span class="line">        <span class="keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable)</span><br><span class="line">            (c1, c2) -&gt; keyComparator.compare(keyExtractor.apply(c1),</span><br><span class="line">                                              keyExtractor.apply(c2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U extends Comparable&lt;? <span class="keyword">super</span> U&gt;&gt; <span class="function">Comparator&lt;T&gt; <span class="title">comparing</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; keyExtractor)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Objects.requireNonNull(keyExtractor);</span><br><span class="line">        <span class="keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable)</span><br><span class="line">            (c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Comparator&lt;T&gt; <span class="title">comparingInt</span><span class="params">(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(keyExtractor);</span><br><span class="line">        <span class="keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable)</span><br><span class="line">            (c1, c2) -&gt; Integer.compare(keyExtractor.applyAsInt(c1), keyExtractor.applyAsInt(c2));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Comparator&lt;T&gt; <span class="title">comparingLong</span><span class="params">(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(keyExtractor);</span><br><span class="line">        <span class="keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable)</span><br><span class="line">            (c1, c2) -&gt; Long.compare(keyExtractor.applyAsLong(c1), keyExtractor.applyAsLong(c2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Comparator&lt;T&gt; <span class="title">comparingDouble</span><span class="params">(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(keyExtractor);</span><br><span class="line">        <span class="keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable)</span><br><span class="line">            (c1, c2) -&gt; Double.compare(keyExtractor.applyAsDouble(c1), keyExtractor.applyAsDouble(c2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要关注前两个方法，后面的方法都是一些比较方便的初始化的函数。</p><ul><li><strong>若一个类要实现Comparator接口：它一定要实现compare(T o1, T o2) 函数，但可以不实现 equals(Object obj) 函数。</strong></li><li><strong>int compare(T o1, T o2) 是“比较o1和o2的大小”。返回“负数”，意味着“o1比o2小”；返回“零”，意味着“o1等于o2”；返回“正数”，意味着“o1大于o2”。</strong></li></ul><p>现在假如上面的Person类没有实现Comparable接口，该如何比较大小呢？我们可以新建一个类，让其实现Comparator接口，从而构造一个“自定义比较器”。</p><h3 id="Comparator和Comparable的区别"><a href="#Comparator和Comparable的区别" class="headerlink" title="Comparator和Comparable的区别"></a>Comparator和Comparable的区别</h3><p>Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。而Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。</p><p>Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。</p><ul><li><strong><em>用Comparable 简单， 只要实现Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码。</em></strong></li><li><strong><em>Comparator 的好处是不需要修改源代码， 而是另外实现一个比较器， 当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去就可以比大小了。</em></strong></li></ul><p>　</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常我们自定义的一些类需要进行比较，要用到Comparator自定义比较器传递给对应容器或者实现Comparable接口。本文主要介绍两种方式的区别。&lt;/p&gt;
&lt;h3 id=&quot;Comparable接口&quot;&gt;&lt;a href=&quot;#Comparable接口&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="Java" scheme="http://jianghao.wang/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Move Zeroes.</title>
    <link href="http://jianghao.wang/2019/P283%20Move%20Zeroes/"/>
    <id>http://jianghao.wang/2019/P283 Move Zeroes/</id>
    <published>2019-10-12T02:47:51.254Z</published>
    <updated>2019-10-12T02:50:25.985Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度简单-283）"><a href="#问题描述（难度简单-283）" class="headerlink" title="问题描述（难度简单-283）"></a>问题描述（难度简单-283）</h3><p>Given an array <code>nums</code>, write a function to move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0,3,12]</span><br><span class="line">Output: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>Note</strong>:</p><ol><li>You must do this <strong>in-place</strong> without making a copy of the array.</li><li>Minimize the total number of operations.</li></ol><h3 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h3><p>两个index遍历，遍历到符合条件的节点互换位置。<strong>时间复杂度O(N),空间复杂度O(1)。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P283;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双指针 时间复杂度O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;nums.length &amp;&amp; j&lt;nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j]!=<span class="number">0</span>) &#123;</span><br><span class="line">                    mid=nums[i];</span><br><span class="line">                    nums[i]=nums[j];</span><br><span class="line">                    nums[j]=mid;</span><br><span class="line">                    i++;j++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i++;j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Solution().moveZeroes(ints);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度简单-283）&quot;&gt;&lt;a href=&quot;#问题描述（难度简单-283）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度简单-283）&quot;&gt;&lt;/a&gt;问题描述（难度简单-283）&lt;/h3&gt;&lt;p&gt;Given an array &lt;code&gt;n
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Top K Frequent Elements</title>
    <link href="http://jianghao.wang/2019/P347%20Top%20K%20Frequent%20Elements/"/>
    <id>http://jianghao.wang/2019/P347 Top K Frequent Elements/</id>
    <published>2019-10-11T09:28:34.405Z</published>
    <updated>2019-10-11T10:04:01.406Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度中等-347）"><a href="#问题描述（难度中等-347）" class="headerlink" title="问题描述（难度中等-347）"></a>问题描述（难度中等-347）</h3><p>Given a non-empty array of integers, return the <strong>k</strong> most frequent elements.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1], k = 1</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>You may assume <em>k</em> is always valid, 1 ≤ <em>k</em> ≤ number of unique elements.</li><li>Your algorithm’s time complexity <strong>must be</strong> better than O(<em>n</em> log <em>n</em>), where <em>n</em> is the array’s size.</li></ul><h3 id="方法一：HashMap-PriorityQueue"><a href="#方法一：HashMap-PriorityQueue" class="headerlink" title="方法一：HashMap+PriorityQueue"></a>方法一：HashMap+PriorityQueue</h3><h4 id="复杂度分析摘录"><a href="#复杂度分析摘录" class="headerlink" title="复杂度分析摘录"></a>复杂度分析摘录</h4><p><strong>Complexity Analysis</strong></p><ul><li>Time complexity : <strong>O(<em>N</em>log(<em>k</em>)</strong>. The complexity of <code>Counter</code> method is <strong>O(<em>N</em>)</strong>. To build a heap and output list takes <strong>O(<em>N</em>log(<em>k</em>))</strong>. Hence the overall complexity of the algorithm is <strong>O(N + Nlog(k)) =O(<em>N</em>log(<em>k</em>))</strong>.</li><li>Space complexity : <strong>O(<em>N</em></strong>) to store the hash map.</li></ul><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><p>通过HashMap进行计算，再通过优先级队列最小堆找出前k个出现最多的。<strong>时间复杂度O(N*log(k))，空间复杂度O(N)。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> P347;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先用map再用优先级队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; integerMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//统计完出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (integerMap.containsKey(nums[i])) &#123;</span><br><span class="line">                Integer value=integerMap.get(nums[i]);</span><br><span class="line">                integerMap.put(nums[i],++value);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                integerMap.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*//定义一个比较器</span></span><br><span class="line"><span class="comment">        Comparator&lt;Map.Entry&lt;Integer,Integer&gt;&gt; comparator=</span></span><br><span class="line"><span class="comment">                (entry1,entry2)-&gt; entry1.getValue()-entry2.getValue();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="comment">//定义一个比较器  这个操作可以类比上面的函数表达式</span></span><br><span class="line">        Comparator&lt;Map.Entry&lt;Integer,Integer&gt;&gt; comparator=</span><br><span class="line">                Comparator.comparing(Map.Entry&lt;Integer,Integer&gt;::getValue);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造优先级队列</span></span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;Integer,Integer&gt;&gt; priorityQueue=<span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">                k,comparator</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//放入优先级队列</span></span><br><span class="line">        integerMap.entrySet().forEach(integerIntegerEntry -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (priorityQueue.size()&lt;k) &#123;</span><br><span class="line">                priorityQueue.offer(integerIntegerEntry);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                Map.Entry&lt;Integer,Integer&gt; top=priorityQueue.peek();</span><br><span class="line">                <span class="keyword">if</span> (comparator.compare(integerIntegerEntry,top)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    priorityQueue.poll();</span><br><span class="line">                    priorityQueue.offer(integerIntegerEntry);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//获取k大的key</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer,Integer&gt;&gt; iterator=priorityQueue.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            result.add(iterator.next().getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints=&#123;<span class="number">4</span>,<span class="number">1</span>,-<span class="number">1</span>,<span class="number">2</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> Solution().topKFrequent(ints,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ints1=&#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> Solution().topKFrequent(ints1,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要需要定义一个比较器，传送给PriorityQueue。</p><h3 id="方法二：Map-TreeMap"><a href="#方法二：Map-TreeMap" class="headerlink" title="方法二：Map+TreeMap"></a>方法二：Map+TreeMap</h3><p>这个方法相当于对搜集的结果进行全排序，<strong>时间复杂度O(N*log(N)),空间复杂度O(N)。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P347;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-10-11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingTreeMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; countMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            countMap.put(nums[i],countMap.getOrDefault(nums[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeMap&lt;Integer,List&lt;Integer&gt;&gt; treeMap= <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : countMap.keySet())&#123;</span><br><span class="line">            <span class="keyword">int</span> freq = countMap.get(num);</span><br><span class="line">            <span class="keyword">if</span>(!treeMap.containsKey(freq))&#123;</span><br><span class="line">                treeMap.put(freq, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            treeMap.get(freq).add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(res.size()&lt;k)&#123;</span><br><span class="line">            Map.Entry&lt;Integer, List&lt;Integer&gt;&gt; entry = treeMap.pollLastEntry();</span><br><span class="line">            res.addAll(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints=&#123;<span class="number">4</span>,<span class="number">1</span>,-<span class="number">1</span>,<span class="number">2</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] ints1=&#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> UsingTreeMap().topKFrequent(ints,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">new</span> UsingTreeMap().topKFrequent(ints1,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度中等-347）&quot;&gt;&lt;a href=&quot;#问题描述（难度中等-347）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度中等-347）&quot;&gt;&lt;/a&gt;问题描述（难度中等-347）&lt;/h3&gt;&lt;p&gt;Given a non-empty arra
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Majority Element</title>
    <link href="http://jianghao.wang/2019/P169%20Majority%20Element/"/>
    <id>http://jianghao.wang/2019/P169 Majority Element/</id>
    <published>2019-10-10T07:37:51.962Z</published>
    <updated>2019-10-10T08:30:18.893Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度简单-169）"><a href="#问题描述（难度简单-169）" class="headerlink" title="问题描述（难度简单-169）"></a>问题描述（难度简单-169）</h3><p>Given an array of size <em>n</em>, find the majority element. The majority element is the element that appears <strong>more than</strong> <code>⌊ n/2 ⌋</code> times.</p><p>You may assume that the array is non-empty and the majority element always exist in the array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,1,1,1,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><h3 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h3><p>直接排序，取出中间的索引值。因为数量大于一半，所以中间的值肯定是大多数的值。<strong>时间复杂度O(nlogn)，空间复杂度O(1)。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">  <span class="keyword">int</span> len = nums.length;</span><br><span class="line">  <span class="keyword">return</span> nums[len/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：using-hash"><a href="#方法二：using-hash" class="headerlink" title="方法二：using hash"></a>方法二：using hash</h3><p>一遍扫描，用HashMap记录出现的次数，中间记录出现最多的key。<strong>时间复杂度O(n)，空间复杂度O(n)。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P169;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 时间复杂度O(N)</span></span><br><span class="line"><span class="comment"> * 空间复杂度O(N)</span></span><br><span class="line"><span class="comment"> * Using hash</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer,Integer&gt; integerMap=<span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(integerMap.containsKey(nums[i]))&#123;</span><br><span class="line">                Integer value=integerMap.get(nums[i]);</span><br><span class="line">                integerMap.put(nums[i],++value);</span><br><span class="line">                <span class="keyword">if</span>(value&gt;nums.length/<span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                integerMap.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints=&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().majorityElement(ints));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ints1=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().majorityElement(ints1));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ints2=&#123;<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().majorityElement(ints2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三：一遍遍历"><a href="#方法三：一遍遍历" class="headerlink" title="方法三：一遍遍历"></a>方法三：一遍遍历</h3><p>利用数组中某一个数一定会出现一半以上这个特点，只需要一遍遍历就可以完成。<strong>时间复杂度O(n)，空间复杂度O(1)。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> major=num[<span class="number">0</span>], count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;num.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                major=num[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(major==num[i])&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span> count--;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> major;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一遍遍历的方法比较巧妙。利用了同一个数字出现的次数大于一半以上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度简单-169）&quot;&gt;&lt;a href=&quot;#问题描述（难度简单-169）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度简单-169）&quot;&gt;&lt;/a&gt;问题描述（难度简单-169）&lt;/h3&gt;&lt;p&gt;Given an array of size
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Intersection of Two Linked Lists</title>
    <link href="http://jianghao.wang/2019/P160%20Intersection%20of%20Two%20Linked%20Lists/"/>
    <id>http://jianghao.wang/2019/P160 Intersection of Two Linked Lists/</id>
    <published>2019-10-10T02:10:32.127Z</published>
    <updated>2019-10-10T03:00:22.883Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度简单-160）"><a href="#问题描述（难度简单-160）" class="headerlink" title="问题描述（难度简单-160）"></a>问题描述（难度简单-160）</h3><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p><p>For example, the following two linked lists:</p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_statement.png" target="_blank" rel="noopener"><img src="https://assets.leetcode.com/uploads/2018/12/13/160_statement.png" alt="img"></a></p><p><strong>Example 1:</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" target="_blank" rel="noopener"><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" alt="img"></a></p><p><strong>Example 2:</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png" target="_blank" rel="noopener"><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png" alt="img"></a></p><p><strong>Example 3:</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png" target="_blank" rel="noopener"><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png" alt="img"></a></p><p><strong>Notes:</strong></p><ul><li>If the two linked lists have no intersection at all, return <code>null</code>.</li><li>The linked lists must retain their original structure after the function returns.</li><li>You may assume there are no cycles anywhere in the entire linked structure.</li><li>Your code should preferably run in O(n) time and use only O(1) memory.</li></ul><h3 id="方法一：using-hash"><a href="#方法一：using-hash" class="headerlink" title="方法一：using hash"></a>方法一：using hash</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P160;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> AddTwoNumbers.ListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过set的方式实现，需要占用额外的空间</span></span><br><span class="line"><span class="comment"> * 时间复杂度O(M+N)</span></span><br><span class="line"><span class="comment"> * 空间复杂度O(M)/O(N)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-10-10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode a=headA;</span><br><span class="line">        ListNode b=headB;</span><br><span class="line">        Set&lt;ListNode&gt; aSet=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (a!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            aSet.add(a);</span><br><span class="line">            a=a.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历一下</span></span><br><span class="line">        <span class="keyword">while</span> (b!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (aSet.contains(b)) &#123;</span><br><span class="line">                <span class="keyword">return</span> b;</span><br><span class="line">            &#125;</span><br><span class="line">            b=b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：using-two-pointer"><a href="#方法二：using-two-pointer" class="headerlink" title="方法二：using two pointer"></a>方法二：using two pointer</h3><p>双指针遍历，其中一个链表遍历到结尾之后从另一个链表的开头开始遍历，时间复杂度O(M+N)，空间复杂度O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P160;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> AddTwoNumbers.ListNode;</span><br><span class="line"><span class="keyword">import</span> CommonUtils.ListNodeUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 时间复杂度O(M+N)</span></span><br><span class="line"><span class="comment"> * 空间复杂度O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode a=headA;</span><br><span class="line">        ListNode b=headB;</span><br><span class="line">        <span class="comment">//如果同时到达尾部 没有交点直接返回null</span></span><br><span class="line">        <span class="keyword">while</span> (a!=b)&#123;</span><br><span class="line">            <span class="comment">//a一遍循环结束没有找到交点 继续从b开头节点开始往下走</span></span><br><span class="line">            a=a==<span class="keyword">null</span>?headA:a.next;</span><br><span class="line">            <span class="comment">//b一遍循环结束没有找到交点 继续从a开头节点开始循环 最后一定会遇到交点的</span></span><br><span class="line">            b=b==<span class="keyword">null</span>?headB:b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode listNodeA=ListNodeUtils.createListNode(<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line">        ListNode listNodeB=ListNodeUtils.createListNode(<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Solution().getIntersectionNode(listNodeA,listNodeB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>双指针的方式比较巧妙，注意需要在遍历到尾部的时候重新遍历另一个链表。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度简单-160）&quot;&gt;&lt;a href=&quot;#问题描述（难度简单-160）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度简单-160）&quot;&gt;&lt;/a&gt;问题描述（难度简单-160）&lt;/h3&gt;&lt;p&gt;Write a program to fin
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Min Stack</title>
    <link href="http://jianghao.wang/2019/P155%20Min%20Stack/"/>
    <id>http://jianghao.wang/2019/P155 Min Stack/</id>
    <published>2019-10-09T13:58:51.836Z</published>
    <updated>2019-10-09T14:13:37.496Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度简单-155）"><a href="#问题描述（难度简单-155）" class="headerlink" title="问题描述（难度简单-155）"></a>问题描述（难度简单-155）</h3><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><ul><li>push(x) – Push element x onto stack.</li><li>pop() – Removes the element on top of the stack.</li><li>top() – Get the top element.</li><li>getMin() – Retrieve the minimum element in the stack.</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; Returns -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; Returns 0.</span><br><span class="line">minStack.getMin();   --&gt; Returns -2.</span><br></pre></td></tr></table></figure><h3 id="方法一：双数组实现"><a href="#方法一：双数组实现" class="headerlink" title="方法一：双数组实现"></a>方法一：双数组实现</h3><p>一个数组作为输入的数值栈（stackArray），另一个数组作为最小值栈（minArray）。minArray[i]表示前i个stackArray中的最小值。每次pop出栈的时候同时pop一下minArray。<strong>空间复杂度为O(N)，时间复杂度O(N)。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P155;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过数组实现栈</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; stackArray;</span><br><span class="line">    <span class="comment">//记录最小值，在push和pop的过程中都要更新下当前的最小值</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; minArray;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackArray=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        minArray=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        stackArray.add(x);</span><br><span class="line">        <span class="keyword">int</span> topIndex=minArray.size()-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//最小栈无元素 直接插入</span></span><br><span class="line">        <span class="keyword">if</span>(minArray.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            minArray.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最小栈有元素但是栈顶元素比插入元素小 插入栈顶元素</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;minArray.get(topIndex))&#123;</span><br><span class="line">            minArray.add(minArray.get(topIndex));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最小栈有元素但是栈顶元素比插入元素大 插入插入元素</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            minArray.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stackArray.size()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"元素为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        stackArray.remove(stackArray.size() - <span class="number">1</span>);</span><br><span class="line">        minArray.remove(minArray.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stackArray.size()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"元素为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackArray.get(stackArray.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(minArray.size()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"元素为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minArray.get(minArray.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MinStack minStack = <span class="keyword">new</span> MinStack();</span><br><span class="line">        minStack.push(<span class="number">2</span>);</span><br><span class="line">        minStack.push(<span class="number">0</span>);</span><br><span class="line">        minStack.push(<span class="number">3</span>);</span><br><span class="line">        minStack.push(<span class="number">0</span>);</span><br><span class="line">        minStack.pop();</span><br><span class="line">        System.out.println(minStack.getMin());</span><br><span class="line">        System.out.println(minStack.getMin());</span><br><span class="line">        minStack.pop();</span><br><span class="line">        System.out.println(minStack.getMin());</span><br><span class="line">        minStack.pop();</span><br><span class="line">        System.out.println(minStack.getMin());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="方法二：双数组实现（缩减空间）"><a href="#方法二：双数组实现（缩减空间）" class="headerlink" title="方法二：双数组实现（缩减空间）"></a>方法二：双数组实现（缩减空间）</h3><p>在方法一的基础上，实际上minArray没有必要存储N个最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P155;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 改善第一种方式</span></span><br><span class="line"><span class="comment"> * 最小值的数组不需要存全部的结果结</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-10-09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MInStackUsingTwoArrayBetter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过数组实现栈</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; stackArray;</span><br><span class="line">    <span class="comment">//记录最小值，在push和pop的过程中都要更新下当前的最小值</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; minArray;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MInStackUsingTwoArrayBetter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackArray=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        minArray=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        stackArray.add(x);</span><br><span class="line">        <span class="keyword">int</span> topIndex=minArray.size()-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//最小栈无元素 直接插入</span></span><br><span class="line">        <span class="keyword">if</span>(minArray.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            minArray.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最小栈有元素但是栈顶元素比插入元素大 插入插入元素</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;=minArray.get(topIndex))&#123;</span><br><span class="line">            minArray.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stackArray.size()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"元素为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value=stackArray.remove(stackArray.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(value==minArray.get(minArray.size()-<span class="number">1</span>)) &#123;</span><br><span class="line">            minArray.remove(minArray.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stackArray.size()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"元素为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackArray.get(stackArray.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(minArray.size()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"元素为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minArray.get(minArray.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MInStackUsingTwoArrayBetter minStack = <span class="keyword">new</span> MInStackUsingTwoArrayBetter();</span><br><span class="line">        minStack.push(<span class="number">2</span>);</span><br><span class="line">        minStack.push(<span class="number">3</span>);</span><br><span class="line">        minStack.push(<span class="number">0</span>);</span><br><span class="line">        minStack.push(<span class="number">0</span>);</span><br><span class="line">        System.out.println(minStack.getMin());</span><br><span class="line">        minStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">        System.out.println(minStack.getMin());</span><br><span class="line">        minStack.pop();</span><br><span class="line">        System.out.println(minStack.getMin());</span><br><span class="line">        System.out.println(minStack.top());</span><br><span class="line">        minStack.pop();</span><br><span class="line">        System.out.println(minStack.getMin());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度简单-155）&quot;&gt;&lt;a href=&quot;#问题描述（难度简单-155）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度简单-155）&quot;&gt;&lt;/a&gt;问题描述（难度简单-155）&lt;/h3&gt;&lt;p&gt;Design a stack that su
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Fizz Buzz Multithreaded</title>
    <link href="http://jianghao.wang/2019/P1195%20Fizz%20Buzz%20Multithreaded/"/>
    <id>http://jianghao.wang/2019/P1195 Fizz Buzz Multithreaded/</id>
    <published>2019-10-08T03:14:12.381Z</published>
    <updated>2019-10-09T14:14:55.761Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度中等-1195）"><a href="#问题描述（难度中等-1195）" class="headerlink" title="问题描述（难度中等-1195）"></a>问题描述（难度中等-1195）</h3><p>Write a program that outputs the string representation of numbers from 1 to <em>n</em>, however:</p><ul><li>If the number is divisible by 3, output “fizz”.</li><li>If the number is divisible by 5, output “buzz”.</li><li>If the number is divisible by both 3 and 5, output “fizzbuzz”.</li></ul><p>For example, for <code>n = 15</code>, we output: <code>1, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz, 11, fizz, 13, 14, fizzbuzz</code>.</p><p>Suppose you are given the following code:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class FizzBuzz &#123;</span><br><span class="line">  public FizzBuzz(int n) &#123; ... &#125;               // constructor</span><br><span class="line">  public void fizz(printFizz) &#123; ... &#125;          // only output &quot;fizz&quot;</span><br><span class="line">  public void buzz(printBuzz) &#123; ... &#125;          // only output &quot;buzz&quot;</span><br><span class="line">  public void fizzbuzz(printFizzBuzz) &#123; ... &#125;  // only output &quot;fizzbuzz&quot;</span><br><span class="line">  public void number(printNumber) &#123; ... &#125;      // only output the numbers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Implement a multithreaded version of <code>FizzBuzz</code> with <strong>four</strong> threads. The same instance of <code>FizzBuzz</code> will be passed to four different threads:</p><ol><li>Thread A will call <code>fizz()</code> to check for divisibility of 3 and outputs <code>fizz</code>.</li><li>Thread B will call <code>buzz()</code> to check for divisibility of 5 and outputs <code>buzz</code>.</li><li>Thread C will call <code>fizzbuzz()</code> to check for divisibility of 3 and 5 and outputs <code>fizzbuzz</code>.</li><li>Thread D will call <code>number()</code> which should only output the numbers.</li></ol><h3 id="方法一：using-volatile"><a href="#方法一：using-volatile" class="headerlink" title="方法一：using volatile"></a>方法一：using volatile</h3><p>通过定义volatile变量flag，以循环自检的方式执行。这里总结下这种方法的通用范式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(trure)&#123;</span><br><span class="line">  <span class="comment">//条件1 条件必须唯一</span></span><br><span class="line">  <span class="keyword">if</span>(flag)&#123;...update flag&#125;</span><br><span class="line">  <span class="comment">//条件2 条件必须唯一</span></span><br><span class="line">  <span class="keyword">if</span>(flag)&#123;...update flag&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的范式可以通用，但是可能会导致TLP问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P1195;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntConsumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-10-04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingVolatile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> currentValue=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UsingVolatile</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizz.run() outputs "fizz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizz</span><span class="params">(Runnable printFizz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(currentValue&lt;=n &amp;&amp; currentValue%<span class="number">3</span>==<span class="number">0</span> &amp;&amp; currentValue%<span class="number">15</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//执行打印fizz代码</span></span><br><span class="line">                printFizz.run();</span><br><span class="line">                ++currentValue;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printBuzz.run() outputs "buzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buzz</span><span class="params">(Runnable printBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(currentValue&lt;=n &amp;&amp; currentValue % <span class="number">5</span>== <span class="number">0</span> &amp;&amp; currentValue % <span class="number">15</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                printBuzz.run();</span><br><span class="line">                ++currentValue;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizzBuzz.run() outputs "fizzbuzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span><span class="params">(Runnable printFizzBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(currentValue&lt;=n &amp;&amp; currentValue % <span class="number">15</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                printFizzBuzz.run();</span><br><span class="line">                ++currentValue;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber.accept(x) outputs "x", where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">number</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(currentValue%<span class="number">3</span>!=<span class="number">0</span> &amp;&amp; currentValue % <span class="number">5</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                printNumber.accept(currentValue);</span><br><span class="line">                ++currentValue;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; strings = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        FizzBuzz fizzBuzz = <span class="keyword">new</span> FizzBuzz(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        Thread t1, t2, t3, t4;</span><br><span class="line"></span><br><span class="line">        (t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fizzBuzz.fizz(() -&gt; strings.add(<span class="string">"fizz"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.err.println(e.toString());</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)).start();</span><br><span class="line"></span><br><span class="line">        (t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fizzBuzz.buzz(() -&gt; strings.add(<span class="string">"buzz"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.err.println(e.toString());</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)).start();</span><br><span class="line"></span><br><span class="line">        (t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fizzBuzz.fizzbuzz(() -&gt; strings.add(<span class="string">"fizzbuzz"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.err.println(e.toString());</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)).start();</span><br><span class="line"></span><br><span class="line">        (t4 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fizzBuzz.number(number -&gt; strings.add(<span class="string">""</span> + number));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.err.println(e.toString());</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t3.join();</span><br><span class="line">            t4.join();</span><br><span class="line">            t2.join();</span><br><span class="line">            t1.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：using-synchronized"><a href="#方法二：using-synchronized" class="headerlink" title="方法二：using synchronized"></a>方法二：using synchronized</h3><p>通过对象提供的基本操作等待/通知范式，等待通知需要定义两个基本操作一个生产一个消费：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">  synchoronized(object)&#123;</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">      object.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行消费过程 例如打印一个b 检查生产的标志变量是否已经生产完成</span></span><br><span class="line">    system.out.println(<span class="string">"b"</span>);</span><br><span class="line">    flag=<span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">  synchornized(object)&#123;</span><br><span class="line">    <span class="comment">//执行生产动作 例如打印一个a 同时将变量修改为已生产</span></span><br><span class="line"> system.out.println(<span class="string">"a"</span>);</span><br><span class="line">    object.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要进行范式的循环，在范式外面加一层循环，于是范式演变成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//执行循环的次数 不断进行消费</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        synchoronized(object)&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        object.wait();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//执行消费过程 例如打印一个b</span></span><br><span class="line">       system.out.println(<span class="string">"b"</span>);</span><br><span class="line">       flag=<span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用上面的范式，我们可以看到关键是要确定两步：</p><ul><li>1.循环次数</li><li>2.变量的等待条件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P1195;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntConsumer;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FizzBuzz</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentValue=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizz.run() outputs "fizz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizz</span><span class="params">(Runnable printFizz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">3</span>-n/<span class="number">15</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (FizzBuzz.class)&#123;</span><br><span class="line">                <span class="keyword">while</span>(currentValue%<span class="number">3</span>!=<span class="number">0</span> || currentValue%<span class="number">15</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    FizzBuzz.class.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//执行打印fizz代码</span></span><br><span class="line">                printFizz.run();</span><br><span class="line">                currentValue++;</span><br><span class="line">                FizzBuzz.class.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printBuzz.run() outputs "buzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buzz</span><span class="params">(Runnable printBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">5</span>-n/<span class="number">15</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (FizzBuzz.class)&#123;</span><br><span class="line">                <span class="keyword">while</span> (currentValue%<span class="number">5</span>!=<span class="number">0</span> || currentValue%<span class="number">15</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    FizzBuzz.class.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                printBuzz.run();</span><br><span class="line">                currentValue++;</span><br><span class="line">                FizzBuzz.class.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizzBuzz.run() outputs "fizzbuzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span><span class="params">(Runnable printFizzBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">15</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (FizzBuzz.class)&#123;</span><br><span class="line">                <span class="keyword">while</span> (currentValue%<span class="number">15</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                    FizzBuzz.class.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                printFizzBuzz.run();</span><br><span class="line">                currentValue++;</span><br><span class="line">                FizzBuzz.class.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber.accept(x) outputs "x", where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">number</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (n-n/<span class="number">3</span>-n/<span class="number">5</span>+n/<span class="number">15</span>); i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (FizzBuzz.class)&#123;</span><br><span class="line">                <span class="keyword">while</span> (currentValue%<span class="number">5</span>==<span class="number">0</span> || currentValue%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    FizzBuzz.class.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                printNumber.accept(currentValue);</span><br><span class="line">                currentValue++;</span><br><span class="line">                FizzBuzz.class.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三：using-lock"><a href="#方法三：using-lock" class="headerlink" title="方法三：using lock"></a>方法三：using lock</h3><p>这里维护多个等待队列貌似没有意义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P1195;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntConsumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-10-04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingLockCondition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentValue=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    ReentrantLock reentrantLock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    Condition condition=reentrantLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UsingLockCondition</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizz.run() outputs "fizz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizz</span><span class="params">(Runnable printFizz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">3</span>-n/<span class="number">15</span>; i++) &#123;</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            <span class="keyword">while</span>(currentValue%<span class="number">3</span>!=<span class="number">0</span> || currentValue%<span class="number">15</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//执行打印fizz代码</span></span><br><span class="line">            printFizz.run();</span><br><span class="line">            currentValue++;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printBuzz.run() outputs "buzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buzz</span><span class="params">(Runnable printBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">5</span>-n/<span class="number">15</span>; i++) &#123;</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            <span class="keyword">while</span> (currentValue%<span class="number">5</span>!=<span class="number">0</span> || currentValue%<span class="number">15</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            printBuzz.run();</span><br><span class="line">            currentValue++;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizzBuzz.run() outputs "fizzbuzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span><span class="params">(Runnable printFizzBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">15</span>; i++) &#123;</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            <span class="keyword">while</span> (currentValue%<span class="number">15</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            printFizzBuzz.run();</span><br><span class="line">            currentValue++;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber.accept(x) outputs "x", where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">number</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (n-n/<span class="number">3</span>-n/<span class="number">5</span>+n/<span class="number">15</span>); i++) &#123;</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            <span class="keyword">while</span> (currentValue%<span class="number">5</span>==<span class="number">0</span> || currentValue%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            printNumber.accept(currentValue);</span><br><span class="line">            currentValue++;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法四：using-atomic"><a href="#方法四：using-atomic" class="headerlink" title="方法四：using atomic"></a>方法四：using atomic</h3><p>利用atomic提供的封装函数，实际上利用cas实现原子写操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ConcurrentModificationException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntConsumer;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FizzBuzz</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger counter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        counter = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateToNext</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!counter.compareAndSet(count, count + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizz</span><span class="params">(Runnable printFizz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">while</span> ((count = counter.get()) &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; count % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                printFizz.run();</span><br><span class="line">                updateToNext(count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buzz</span><span class="params">(Runnable printBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">while</span> ((count = counter.get()) &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count % <span class="number">3</span> != <span class="number">0</span> &amp;&amp; count % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                printBuzz.run();</span><br><span class="line">                updateToNext(count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span><span class="params">(Runnable printFizzBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">while</span> ((count = counter.get()) &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; count % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                printFizzBuzz.run();</span><br><span class="line">                updateToNext(count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">number</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">while</span> ((count = counter.get()) &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count % <span class="number">3</span> != <span class="number">0</span> &amp;&amp; count % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                printNumber.accept(count);</span><br><span class="line">                updateToNext(count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过循环自检或者等待通知的方式实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度中等-1195）&quot;&gt;&lt;a href=&quot;#问题描述（难度中等-1195）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度中等-1195）&quot;&gt;&lt;/a&gt;问题描述（难度中等-1195）&lt;/h3&gt;&lt;p&gt;Write a program th
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Balanced Binary Tree</title>
    <link href="http://jianghao.wang/2019/P110%20Balanced%20Binary%20Tree/"/>
    <id>http://jianghao.wang/2019/P110 Balanced Binary Tree/</id>
    <published>2019-09-30T06:09:52.696Z</published>
    <updated>2019-09-30T06:56:29.390Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度简单-110）"><a href="#问题描述（难度简单-110）" class="headerlink" title="问题描述（难度简单-110）"></a>问题描述（难度简单-110）</h3><p>Given a binary tree, determine if it is height-balanced.</p><p>For this problem, a height-balanced binary tree is defined as:</p><blockquote><p>a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p></blockquote><p><strong>Example 1:</strong></p><p>Given the following tree <code>[3,9,20,null,null,15,7]</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>Return true.</p><p><strong>Example 2:</strong></p><p>Given the following tree <code>[1,2,2,3,3,null,null,4,4]</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     / \</span><br><span class="line">    2   2</span><br><span class="line">   / \</span><br><span class="line">  3   3</span><br><span class="line"> / \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure><p>Return false.</p><h3 id="方法一：递归（Recursive）"><a href="#方法一：递归（Recursive）" class="headerlink" title="方法一：递归（Recursive）"></a>方法一：递归（Recursive）</h3><p>判断平衡树是否平衡的标准：</p><ul><li><strong>左右子树的高度差不大于1。这里的高度值得是树的最大高度。</strong></li></ul><p>根据标准得到一个递归公式（没有好的作图工具，直接看height函数的递归实现）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> height(root)==-<span class="number">1</span>?<span class="keyword">false</span>:<span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode treeNode)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (treeNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> leftHeight=height(treeNode.left);</span><br><span class="line">       <span class="keyword">int</span> rightHeight=height(treeNode.right);</span><br><span class="line">       <span class="keyword">if</span>(leftHeight==-<span class="number">1</span> || rightHeight==-<span class="number">1</span> || Math.abs(leftHeight-rightHeight)&gt;<span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> Math.max(leftHeight,rightHeight)+<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>首先掌握平衡树的判断标准，不能用最大深度减去最小深度来进行计算。需要递归判断左右子树的高度差，当递归到高度差大于1的时候递归往上返回-1值。递归到null时，说明到达了叶子结点的下的空节点，返回0。其他情况都返回左右节点的最大高度加1。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度简单-110）&quot;&gt;&lt;a href=&quot;#问题描述（难度简单-110）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度简单-110）&quot;&gt;&lt;/a&gt;问题描述（难度简单-110）&lt;/h3&gt;&lt;p&gt;Given a binary tree, d
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Single Number</title>
    <link href="http://jianghao.wang/2019/P136%20Single%20Number/"/>
    <id>http://jianghao.wang/2019/P136 Single Number/</id>
    <published>2019-09-20T07:00:07.169Z</published>
    <updated>2019-09-30T06:15:52.530Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度简单-136）"><a href="#问题描述（难度简单-136）" class="headerlink" title="问题描述（难度简单-136）"></a>问题描述（难度简单-136）</h3><p>Given a <strong>non-empty</strong> array of integers, every element appears <em>twice</em> except for one. Find that single one.</p><p><strong>Note:</strong></p><p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,1,2,1,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><h3 id="XOR（异或）"><a href="#XOR（异或）" class="headerlink" title="XOR（异或）"></a>XOR（异或）</h3><p>如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。</p><h3 id="方法一：一边遍历Map"><a href="#方法一：一边遍历Map" class="headerlink" title="方法一：一边遍历Map"></a>方法一：一边遍历Map</h3><p>一遍遍历保留只出现一次的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map= <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(nums[i])==<span class="keyword">null</span>)&#123;</span><br><span class="line">                map.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                map.remove(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (Integer) map.keySet().toArray()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：XOR"><a href="#方法二：XOR" class="headerlink" title="方法二：XOR"></a>方法二：XOR</h3><p>first , we have to know the bitwise XOR in java:</p><ul><li><strong>0 ^ N = N</strong></li><li><strong>N ^ N = 0</strong></li></ul><p>So….. if N is the single number:</p><p>N1 ^ N1 ^ N2 ^ N2 ^…………..^ Nx ^ Nx ^ N= (N1^N1) ^ (N2^N2) ^…………..^ (Nx^Nx) ^ N= 0 ^ 0 ^ ……….^ 0 ^ N</p><p>= N</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans =<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;i++)</span><br><span class="line">        ans ^= nums[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>采用XOR（异或）的方式，相同的数字都相互抵消了，最后留下单一的不同的数字。也就是方法二的精髓。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度简单-136）&quot;&gt;&lt;a href=&quot;#问题描述（难度简单-136）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度简单-136）&quot;&gt;&lt;/a&gt;问题描述（难度简单-136）&lt;/h3&gt;&lt;p&gt;Given a &lt;strong&gt;non-em
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java中的阻塞队列</title>
    <link href="http://jianghao.wang/2019/%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/Java%E4%B8%AD%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>http://jianghao.wang/2019/并发学习/Java中的阻塞队列/</id>
    <published>2019-07-30T05:00:06.328Z</published>
    <updated>2019-10-09T03:04:27.281Z</updated>
    
    <content type="html"><![CDATA[<p>Java中的阻塞队列，可以基于BlockingQueue接口自定义实现多种自定义阻塞队列。阻塞队列最经典的应用主要是帮助线程池管理任务，是一个经典的等待/通知（生产者/消费者）模型。这里根据源码主要介绍几种比较经典的实现，并提炼出一些经典范式。</p><table><br><tr><br>    <th>add</th><br>    <th>remove</th><br>    <th>抛出异常</th><br></tr><br><tr><br>    <th>put</th><br>    <th>take</th><br>    <th>等待直到中断</th><br></tr><br><tr><br>    <th>offer</th><br>    <th>poll</th><br>    <th>直接返回</th><br></tr><br><tr><br>    <th>offer(time)</th><br>    <th>poll(time)</th><br>    <th>设定等待时间</th><br></tr><br></table><h3 id="LinkedBlockingQueue（基于链表的有界阻塞队列）"><a href="#LinkedBlockingQueue（基于链表的有界阻塞队列）" class="headerlink" title="LinkedBlockingQueue（基于链表的有界阻塞队列）"></a>LinkedBlockingQueue（基于链表的有界阻塞队列）</h3><p>Executors.newFixedThreadPool（根据需要可重用部分消费者线程数）和Executors.newSingledThreadPool（单个消费者线程）都使用了LinkedBlockingQueue无界队列来管理任务。</p><h4 id="put-take（double-lock-wait-notify）"><a href="#put-take（double-lock-wait-notify）" class="headerlink" title="put/take（double lock+wait/notify）"></a>put/take（double lock+wait/notify）</h4><p>通过双锁来增加队列的并发度，通过wait/notify进行等待/通知。因为通常无界队列默认可以容下Integer.MAX_VALUE的任务。</p><h3 id="Design-Bounded-Blocking-Queue"><a href="#Design-Bounded-Blocking-Queue" class="headerlink" title="Design Bounded Blocking Queue"></a>Design Bounded Blocking Queue</h3><p>设计一个阻塞队列，通过等待通知机制设计一个阻塞队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P1188;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设计一个有界阻塞队列</span></span><br><span class="line"><span class="comment"> * Design Bounded Blocking Queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-10-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个队列</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="comment">//队列的capacity 限制容量</span></span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="comment">//定义一个lock</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock reentrantLock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义两个队列</span></span><br><span class="line">    <span class="keyword">private</span> Condition notEmpty=reentrantLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Condition notFull=reentrantLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(Integer size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue=<span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">this</span>.size=size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        reentrantLock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size()==size)&#123;</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(integer);</span><br><span class="line">            notEmpty.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        reentrantLock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.remove();</span><br><span class="line">            notFull.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java中的阻塞队列，可以基于BlockingQueue接口自定义实现多种自定义阻塞队列。阻塞队列最经典的应用主要是帮助线程池管理任务，是一个经典的等待/通知（生产者/消费者）模型。这里根据源码主要介绍几种比较经典的实现，并提炼出一些经典范式。&lt;/p&gt;
&lt;table&gt;&lt;br
      
    
    </summary>
    
    
      <category term="源码解析" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://jianghao.wang/2019/%E7%AE%80%E5%8E%86/"/>
    <id>http://jianghao.wang/2019/简历/</id>
    <published>2019-07-22T08:13:50.299Z</published>
    <updated>2019-09-23T15:11:15.993Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本资料"><a href="#基本资料" class="headerlink" title="基本资料"></a>基本资料</h3><p>姓名 : 叶乔柱                                                       联系电话：18668486087   </p><p>电子邮箱： <a href="mailto:yqz_zjut@aliyun.com" target="_blank" rel="noopener">yqz_zjut@aliyun.com</a>                           毕业院校：浙江工业大学计算机学院</p><p>出生年月：1993年8月                                         专业：计算机科学与技术</p><p>求职意向：Java/全栈                                          技术博客：<a href="http://arthornye.github.io" target="_blank" rel="noopener">http://arthornye.github.io</a> </p><h3 id="职业技能"><a href="#职业技能" class="headerlink" title="职业技能"></a>职业技能</h3><ul><li>专业技能 综合能力： 演讲能力 | 责任心 | 团队精神 | 英语 | 数据库软件 。</li><li>熟悉基于 Mysql 的数据库设计，Sql 性能调优，对数据库引擎有一定的了解。</li><li>熟悉 Spring, Mybatis 框架的使用，且对其原理有一定的理解。</li><li>熟悉 Java 编程基础，熟悉多线程并发，反射，集合等高级特性，并且对 Jvm 有一定的理解。</li><li>了解分布式消息服务，分布式存储缓存，分布式服务框架。 </li><li>熟悉 ReactJS，Jquery，AngularJS，Jsx，Html 标准语法，具备一定的前端开发能力。 </li><li>熟悉 Git 管理代码，Maven 项目管理。  </li></ul><h3 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h3><p><strong>杭州大搜车汽车服务有限公司（新车新零售）</strong>    2017.07 - 2019.09</p><p>先后独立负责线上 App 和 PC 签署汽车销售合同模块搭建，对接公司内部基础服务和支付宝开放平台。参与和阿里天猫共同合作的汽车新零售项目，对接公司内部支付网关和外部天猫平台。负责公司后台运营系统 Web 页面以及后台搭建。对小组内部已有业务做 Sql 性能优化改造。运用 Dubbo，MQ 支付消息，通过 Swagger 为前端提供文档。  </p><p><strong>浙江远图互联科技股份有限公司（互联网医疗）</strong>    2016.06 - 2017.06 </p><p>搭建医院系统 His，Lis 以及 Pacs 适配器，为公司自助终端和移动终端服务提供统一医院内部系统入口，包括挂号，缴费，充值，医保等服务。系统采用 Springmvc+Ibatis+Mysql 实现，通过 Socket，Websevice，存储过程，视图以及 Http 等多种方式与医院内部系统交互，实现复杂的医疗服务逻辑。对接公司内部支付系统和结算系统，实现医院内部的各种支付以及对账。 </p><p><strong>杭州博克软件有限公司（外企实习）</strong>    2015.03 – 2016.01</p><p>任职于公司研发部门，设计实现内部提名系统，全程采用scrum敏捷开发方式和英文汇报交流工作，供内部人员使用。整套系统通过Html+Bootstrap+Jquery+AngularJS框架搭建前端页面，Mysql做数据存储。</p><h3 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h3><h4 id="订单交易模块"><a href="#订单交易模块" class="headerlink" title="订单交易模块"></a>订单交易模块</h4><p>功能： 新车交易采购和零售，为4s店和二网等B端提供订单交易Api服务，对接天猫券中心C端购买优惠券后线下进行核销，客户在天猫上签署合同支付尾款。                </p><p>技术： Dubbo 、Redis 、RocketMQ 、Spring 、Mysql         </p><p>简述： </p><ul><li><p>交易模块主要基于Mysql和Redis集群做数据存储，使用RocketMQ做消息队列，通过Dubbo微服务化， 基于ZK集群搭建高可用系统。                   </p></li><li><p>前期我们整个交易前台模块的设计面向过程编程，服务耦合性较高，后期对部分业务引入基于观察者模式的 Spring状态机和事件监听机制。                          </p></li><li><p>前期订单管理分页基于Sql优化分页查询，后期引入ESSearch。            </p></li></ul><h4 id="运营后台管理系统"><a href="#运营后台管理系统" class="headerlink" title="运营后台管理系统"></a>运营后台管理系统</h4><p>功能： 运营订单管理，订单搜索，详情页展示，报表导出，针对部门各个业务线。 </p><p>技术： React 、Ant Design、Webpack、 Dubbo 、 ESSearch、Mysql </p><p>简述：</p><ul><li><p>通过 React+Antd Design搭建订单管理、详情、审核以及导出页面。              </p></li><li><p>基于简单工厂和策略模式改善运营后台订单导出功能，便于扩展各个业务。                                              </p></li><li><p>前期基于Sql优化分页查询，后期引入ESSearch。 </p></li><li><p>链接： <a href="http://arthornye.github.io/2019/ShowPages/" target="_blank" rel="noopener">http://arthornye.github.io/2019/ShowPages/</a> </p></li></ul><h4 id="网关适配系统"><a href="#网关适配系统" class="headerlink" title="网关适配系统"></a>网关适配系统</h4><p>功能： 适配医院内部复杂系统，为客户端提供统一Api入口。</p><p>技术： WebService、SpringMVC、Mysql、Ibatis、Nginx </p><p>简述： </p><ul><li>系统主要部署在医院内部，Nginx做负载均衡，Mysql做数据存储，通过令牌进行高峰限流。           </li><li>后期通过简单工厂和策略模式针对不同的医院逻辑提供不同实现，支持WebService，Socket，存储过程等多种 适配方式。  </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本资料&quot;&gt;&lt;a href=&quot;#基本资料&quot; class=&quot;headerlink&quot; title=&quot;基本资料&quot;&gt;&lt;/a&gt;基本资料&lt;/h3&gt;&lt;p&gt;姓名 : 叶乔柱                                                      
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Show Pages</title>
    <link href="http://jianghao.wang/2019/ShowPages/"/>
    <id>http://jianghao.wang/2019/ShowPages/</id>
    <published>2019-07-22T04:52:17.228Z</published>
    <updated>2019-07-22T05:06:36.804Z</updated>
    
    <content type="html"><![CDATA[<h3 id="订单详情"><a href="#订单详情" class="headerlink" title="订单详情"></a>订单详情</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="http://arthornye.github.io/images/detail.png" alt="cmd-markdown-logo"></h3><h3 id="订单列表"><a href="#订单列表" class="headerlink" title="订单列表"></a>订单列表</h3><p><img src="http://arthornye.github.io/images/manager.png" alt="cmd-markdown-logo"></p><h3 id="订单导出"><a href="#订单导出" class="headerlink" title="订单导出"></a>订单导出</h3><p><img src="http://arthornye.github.io/images/export.png" alt="cmd-markdown-logo"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;订单详情&quot;&gt;&lt;a href=&quot;#订单详情&quot; class=&quot;headerlink&quot; title=&quot;订单详情&quot;&gt;&lt;/a&gt;订单详情&lt;/h3&gt;&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;img src=&quot;h
      
    
    </summary>
    
    
      <category term="大搜车的点滴记录" scheme="http://jianghao.wang/tags/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%9A%84%E7%82%B9%E6%BB%B4%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>CopyOnWriteArrayList</title>
    <link href="http://jianghao.wang/2019/CopyOnWriteArrayList%E4%BB%8B%E7%BB%8D/"/>
    <id>http://jianghao.wang/2019/CopyOnWriteArrayList介绍/</id>
    <published>2019-07-01T07:56:26.260Z</published>
    <updated>2019-07-01T12:39:19.744Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要介绍juc内部针对数组提供的并发容器<strong>CopyOnWriteArrayList</strong>，主要的思想是针对增删改等修改操作都将原数组拷贝一份新数组，然后做完修改操作后，通过原子的方式写入到原数组的引用，通知到其他线程。</p><h3 id="CopyOnWriteArrayList实现"><a href="#CopyOnWriteArrayList实现" class="headerlink" title="CopyOnWriteArrayList实现"></a>CopyOnWriteArrayList实现</h3><p>设计一个线程安全的容器主要针对改（增删改）和查操作，<strong>CopyOnWriteArrayList</strong>对put操作通过RetrantLock加锁，将数组定义为volatile类型，再通过加锁完成新数组的生成之后，将新数组赋值给volatile数组，通知到其他线程。这里的lock同样我们可以用synchronized关键字或者cas来实现。put操作源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Object[] elements = getArray();</span><br><span class="line">           <span class="keyword">int</span> len = elements.length;</span><br><span class="line">           Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">           newElements[len] = e;</span><br><span class="line">           setArray(newElements);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="Iterating过程中不允许修改"><a href="#Iterating过程中不允许修改" class="headerlink" title="Iterating过程中不允许修改"></a>Iterating过程中不允许修改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.study.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayListTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] integers=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        DefinedCopyOnWirteArrayList list=<span class="keyword">new</span> DefinedCopyOnWirteArrayList(integers);</span><br><span class="line"></span><br><span class="line">        Iterator iterator=list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            <span class="comment">//不允许操作，抛出异常</span></span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器浅拷贝，不允许修改，只能查询而且是临时快照</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"remove"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过CAS改写CopyOnWriteArrayList"><a href="#通过CAS改写CopyOnWriteArrayList" class="headerlink" title="通过CAS改写CopyOnWriteArrayList"></a>通过CAS改写CopyOnWriteArrayList</h3><p>继承CopyOnWriteArrayList进行方法的重写，重新实现的add方法供参考：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.study.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义CopyOnWriteArrayList的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefinedCopyOnWirteArrayList</span> <span class="keyword">extends</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Integer[]&gt; atomicIntegers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefinedCopyOnWirteArrayList</span><span class="params">(Integer[] integers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.atomicIntegers = <span class="keyword">new</span> AtomicReference&lt;&gt;(integers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">(Integer index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;atomicIntegers.get().length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"数组越界"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> atomicIntegers.get()[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Integer insertData)</span></span>&#123;</span><br><span class="line">        <span class="comment">//step 1:拷贝一份数组</span></span><br><span class="line">        Integer[] integers=atomicIntegers.get();</span><br><span class="line">        <span class="keyword">int</span> length=integers.length;</span><br><span class="line">        Integer[] newIntegers=Arrays.copyOf(integers,length+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//step 2:将新值添加到新的数组中</span></span><br><span class="line">        newIntegers[length]=insertData;</span><br><span class="line">        <span class="comment">//step 3:采用cas替换引用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.atomicIntegers.compareAndSet(integers,newIntegers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CopyOnWriteArrayList设计-vs-RetrantWriteReadLock"><a href="#CopyOnWriteArrayList设计-vs-RetrantWriteReadLock" class="headerlink" title="CopyOnWriteArrayList设计 vs RetrantWriteReadLock"></a>CopyOnWriteArrayList设计 vs RetrantWriteReadLock</h3><p>对比一下<strong>CopyOnWriteArrayList设计</strong>和<strong>RetrantWriteReadLock</strong>的实现。</p><ul><li><strong>CopyOnWriteArrayList设计读不加锁，写加锁。RetrantWriteReadLock读和写都加锁。</strong></li><li><strong>CopyOnWriteArrayList设计针对读多写少场景表现优。RetrantWriteReadLock虽然针对读锁做了共享，读多写少依旧阻塞。</strong></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>感觉CopyOnWriteArrayList的设计还是蛮巧妙的，之前在了解读写锁的这种设计时还是蛮质疑这个设计的实际意义的。类比innodb的MDL表锁（如果一个写操作（修改表结构）获取到写锁前面有一个长事务获取读锁，那么所有的ddl操作（读锁）都有被阻塞），inndb因此设计了更小粒度的行锁。行锁同时设计了写锁，但是取消了读锁，用MVCC多版本并发控制取代，类比CopyOnWriteArrayList保留了写锁，通过线程通信的方式取消了读锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇主要介绍juc内部针对数组提供的并发容器&lt;strong&gt;CopyOnWriteArrayList&lt;/strong&gt;，主要的思想是针对增删改等修改操作都将原数组拷贝一份新数组，然后做完修改操作后，通过原子的方式写入到原数组的引用，通知到其他线程。&lt;/p&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
    
      <category term="juc源码学习" scheme="http://jianghao.wang/tags/juc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Find All Numbers Disappeared in an Array</title>
    <link href="http://jianghao.wang/2019/Find%20All%20Numbers%20Disappeared/"/>
    <id>http://jianghao.wang/2019/Find All Numbers Disappeared/</id>
    <published>2019-06-06T01:29:54.700Z</published>
    <updated>2019-06-06T02:02:07.232Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述-难度简单-448"><a href="#问题描述-难度简单-448" class="headerlink" title="问题描述 (难度简单-448)"></a>问题描述 (难度简单-448)</h3><p>Given an array of integers where 1 ≤ a[i] ≤ <em>n</em> (<em>n</em> = size of array), some elements appear twice and others appear once.</p><p>Find all the elements of [1, <em>n</em>] inclusive that do not appear in this array.</p><p>Could you do it without extra space and in O(<em>n</em>) runtime? You may assume the returned list does not count as extra space.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure><h3 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h3><p>需要在一次遍历的过程中标记已经出现过的数字，进而找出未出现的数字，只能通过自身的数组进行标记。按照上面的示例，索引位置为0的位置值为4，我们需要将4标记一下已经出现过，索性用索引位置为3的地方做标记，将对应的值取反，标记为负值。<strong><em>这样1-8的数组可以对应0-7的索引位置进行标记，最后未被标记为负值的元素的index加上1即为未出现过的数字</em></strong>。迭代的流程如下图：</p><p><img src="https://arthornye.github.io/images/disappear-first.jpg" alt="cmd-markdown-logo"></p><p><img src="https://arthornye.github.io/images/disappear-second.jpg" alt="cmd-markdown-logo"></p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><p>实践代码的过程中需要注意，遍历到的节点value值可能已经是负，已经被标记，但是还是需要根据其绝对值找到该value需要标记的index位置，这也是为什么将其标记为反数而不是其他任意负数的原因。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="comment">//数组index对应的数值为value，将index=value的位置标记为-value，表示出现过，并且value取正可以持续标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//已经被标记</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[-nums[i]-<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    nums[-nums[i]-<span class="number">1</span>]=-nums[-nums[i]-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//未被标记</span></span><br><span class="line">                <span class="keyword">if</span>(nums[nums[i]-<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    nums[nums[i] - <span class="number">1</span>] = -nums[nums[i] - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历出未被标记的index，index+1即为未出现过的数值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                arrayList.add(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arrayList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实际上第一个循环的处理可以更加简单清晰，用下面的循环体内容替换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> value=Math.abs(nums[i])-<span class="number">1</span>;<span class="comment">//直接取当前index位置value的绝对值</span></span><br><span class="line">    <span class="keyword">if</span>(nums[value] &gt;<span class="number">0</span>)&#123;</span><br><span class="line">        nums[value]=-nums[value];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题比较难想到这个思路，并且在编码过程中思考也需要更加缜密，想清楚了再进行书写。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述-难度简单-448&quot;&gt;&lt;a href=&quot;#问题描述-难度简单-448&quot; class=&quot;headerlink&quot; title=&quot;问题描述 (难度简单-448)&quot;&gt;&lt;/a&gt;问题描述 (难度简单-448)&lt;/h3&gt;&lt;p&gt;Given an array of inte
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Pow(x, n)</title>
    <link href="http://jianghao.wang/2019/Pow(x,%20n)/"/>
    <id>http://jianghao.wang/2019/Pow(x, n)/</id>
    <published>2019-05-16T11:44:47.616Z</published>
    <updated>2019-05-16T15:00:35.892Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度中等）"><a href="#问题描述（难度中等）" class="headerlink" title="问题描述（难度中等）"></a>问题描述（难度中等）</h3><p>Implement <a href="http://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(<em>x</em>, <em>n</em>)</a>, which calculates <em>x</em> raised to the power <em>n</em> (xn).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.00000, 10</span><br><span class="line">Output: 1024.00000</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.10000, 3</span><br><span class="line">Output: 9.26100</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.00000, -2</span><br><span class="line">Output: 0.25000</span><br><span class="line">Explanation: 2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>-100.0 &lt; <em>x</em> &lt; 100.0</li><li><em>n</em> is a 32-bit signed integer, within the range [−231, 231 − 1]</li></ul><h3 id="递归经典范式"><a href="#递归经典范式" class="headerlink" title="递归经典范式"></a>递归经典范式</h3><p>递归的写法主要包括四个部分，第一个<strong>recursion terminater终止条件</strong>，第二个<strong>process logic in current level当前level需要执行的逻辑</strong>，第三个<strong>drill down进入到下一层</strong>，第四个<strong>reverse the current level status if needed内层结束后继续执行。</strong></p><p><img src="https://arthornye.github.io/images/recursion.jpg" alt="cmd-markdown-logo"></p><h3 id="方法一：递归方式一"><a href="#方法一：递归方式一" class="headerlink" title="方法一：递归方式一"></a>方法一：递归方式一</h3><p>通过递归的方式将n次方的问题拆分成n/2的子问题，时间复杂度减少到logn。<strong>x的n次转换为x^2的n/2次子问题。</strong></p><h3 id="方法一代码"><a href="#方法一代码" class="headerlink" title="方法一代码"></a>方法一代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//偶数直接转化为子问题</span></span><br><span class="line">            <span class="keyword">if</span>((n &amp; <span class="number">1</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> myPow(x*x,n/<span class="number">2</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> n&lt;<span class="number">0</span>?<span class="number">1</span>/x*myPow(<span class="number">1</span>/x*<span class="number">1</span>/x,n/<span class="number">2</span>):x*myPow(x*x,n/<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：递归方式二"><a href="#方法二：递归方式二" class="headerlink" title="方法二：递归方式二"></a>方法二：递归方式二</h3><p>利用递归范式的第四步，<strong>子问题返回的结果乘以自身。</strong></p><h3 id="方法二代码"><a href="#方法二代码" class="headerlink" title="方法二代码"></a>方法二代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow1</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> temp=myPow(x,n/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//偶数直接转化为子问题</span></span><br><span class="line">            <span class="keyword">if</span>((n &amp; <span class="number">1</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> temp*temp;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> n&lt;<span class="number">0</span>?<span class="number">1</span>/x*temp*temp:x*temp*temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="方法三：非递归方式"><a href="#方法三：非递归方式" class="headerlink" title="方法三：非递归方式"></a>方法三：非递归方式</h3><p>不采用递归的方式。</p><h3 id="方法三代码"><a href="#方法三代码" class="headerlink" title="方法三代码"></a>方法三代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        n = -n;</span><br><span class="line">        x = <span class="number">1</span>/x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans *= x;</span><br><span class="line">        x *= x;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题主要是理解递归的范式，递归虽然简洁还是需要灵活运用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度中等）&quot;&gt;&lt;a href=&quot;#问题描述（难度中等）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度中等）&quot;&gt;&lt;/a&gt;问题描述（难度中等）&lt;/h3&gt;&lt;p&gt;Implement &lt;a href=&quot;http://www.cplusplu
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Median of Two Sorted Arrays</title>
    <link href="http://jianghao.wang/2019/Median%20of%20Two%20Sorted%20Arrays/"/>
    <id>http://jianghao.wang/2019/Median of Two Sorted Arrays/</id>
    <published>2019-05-14T03:22:24.489Z</published>
    <updated>2019-05-14T08:48:37.018Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度困难）"><a href="#问题描述（难度困难）" class="headerlink" title="问题描述（难度困难）"></a>问题描述（难度困难）</h3><p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p>You may assume <strong>nums1</strong> and <strong>nums2</strong> cannot be both empty.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">The median is 2.0</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">The median is (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure><h3 id="方法一：归并排序思想"><a href="#方法一：归并排序思想" class="headerlink" title="方法一：归并排序思想"></a>方法一：归并排序思想</h3><p>归并排序在merge之后会将各个有序的子数组合并为一个数组，这里采用归并排序sort的思想，时间和空间复杂度为<strong>O(m+n)</strong>。<strong>用两个index去遍历，每次将最小的整合到一个新的list中，直到整个都遍历完成，需要注意当一个列表遍历完成之后的极端情况。</strong>整合的流程如下：</p><p><img src="https://arthornye.github.io/images/sortIndex.jpg" alt="cmd-markdown-logo"></p><h3 id="方法一代码"><a href="#方法一代码" class="headerlink" title="方法一代码"></a>方法一代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> length = nums1.length + nums2.length;</span><br><span class="line">       ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">       <span class="keyword">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (index1 &gt; nums1.length - <span class="number">1</span>) &#123;</span><br><span class="line">               arrayList.add(nums2[index2]);</span><br><span class="line">               index2++;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index2 &gt; nums2.length - <span class="number">1</span>) &#123;</span><br><span class="line">               arrayList.add(nums1[index1]);</span><br><span class="line">               index1++;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (nums1[index1] &lt; nums2[index2]) &#123;</span><br><span class="line">                   arrayList.add(nums1[index1]);</span><br><span class="line">                   index1++;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   arrayList.add(nums2[index2]);</span><br><span class="line">                   index2++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> mid = length / <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">if</span> ((length &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> (arrayList.get(mid) + arrayList.get(mid - <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> arrayList.get(mid);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：固定和双指针遍历"><a href="#方法二：固定和双指针遍历" class="headerlink" title="方法二：固定和双指针遍历"></a>方法二：固定和双指针遍历</h3><p>方法一中我们其实是把问题转换为了归并排序归并问题，但是实际上并不需要扫描全部的记录，并且也不需要存储整合之后排序的所有的结果，时间复杂度为<strong>O(min(m,n)/2，leetcode上大部分说是O(log(min(m,n)))，可能理解还不够到位，先记录下吧</strong>，空间复杂度为<strong>1</strong>。这里介绍另一种方式：</p><p><img src="https://arthornye.github.io/images/median.jpg" alt="cmd-markdown-logo"></p><p>大概的思路就是两个数组都维持一个索引位置，两个索引位置需要满足<strong>index_first+index_second=(length1+length2-1)/2-1，只有当first_left小于second_right并且second_left小于first_right的时候表示找到了中位数的位置，不然改变其中一个的位置。</strong>感觉这个公式还是蛮难理解的，可以理解为在两个数组之间画一条分割线，分割在中间就需要满足<strong>index=(length-1)/2</strong>。</p><p>这里还需要注意一种情况就是当<strong>index_first==-1和index_second==-1时first_left和second_left用Integer.MIN_VALUE代替，index_first == length1-1和index_second=length2-1时first_right和second_right用Integer.MAX_VALUE代替。</strong></p><h3 id="方法二代码"><a href="#方法二代码" class="headerlink" title="方法二代码"></a>方法二代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.记录当前划分位置的前后节点</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; tempArray=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length1 = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> length2 = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> length = length1 + length2;</span><br><span class="line">        <span class="keyword">if</span> (length1 == <span class="number">0</span> &amp;&amp; length2 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (nums2[length2 / <span class="number">2</span>] + nums2[(length2 - <span class="number">1</span>) / <span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (length2 == <span class="number">0</span> &amp;&amp; length1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (nums1[length1 / <span class="number">2</span>] + nums1[(length1 - <span class="number">1</span>) / <span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//2.若数组的长度为length1，那么分割数组的index位置为(length-1)/2,那么这里整个数组的分割位置为(length-1)/2,减去numsIndex1，但是因为数组是分成了两个，这里需要额外减去1</span></span><br><span class="line">            <span class="keyword">int</span> numIndex1 = (length1 - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> numIndex2 = (length - <span class="number">1</span>) / <span class="number">2</span> - numIndex1 - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//3.边界值，最左边==-1的边界值left设置为Integer.MIN_VALUE，最右边的边界值right==length-1设置为Integer.MAX_VALUE</span></span><br><span class="line">                setLeftAndRight(numIndex1,nums1);</span><br><span class="line">                setLeftAndRight(numIndex2,nums2);</span><br><span class="line">                <span class="comment">//4.比较更加直观</span></span><br><span class="line">                Integer nums1Left=tempArray.get(<span class="number">0</span>),nums1Right=tempArray.get(<span class="number">1</span>),nums2Left=tempArray.get(<span class="number">2</span>),nums2Right=tempArray.get(<span class="number">3</span>);</span><br><span class="line">                <span class="comment">//5.满足截取的位置条件，数组一分割位置左边的元素小于数组二分割位置右边的元素，数组二分割位置左边的元素小于数组一分割位置右边的元素。</span></span><br><span class="line">                <span class="keyword">if</span> (nums1Left &lt;= nums2Right &amp;&amp; nums2Left &lt;= nums1Right) &#123;</span><br><span class="line">                    <span class="comment">//6.判断整个length的长度是否为偶数</span></span><br><span class="line">                    <span class="keyword">int</span> temp = length &amp; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (temp == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> findMax(nums1Left, nums2Left) / <span class="number">1.0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> (findMax(nums1Left, nums2Left) + findMin(nums1Right, nums2Right)) / <span class="number">2.0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1Left &gt; nums2Right) &#123;</span><br><span class="line">                    numIndex1--;</span><br><span class="line">                    numIndex2++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    numIndex1++;</span><br><span class="line">                    numIndex2--;</span><br><span class="line">                &#125;</span><br><span class="line">                tempArray.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setLeftAndRight</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left,right;</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            left = Integer.MIN_VALUE;</span><br><span class="line">            right = nums[index + <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == nums.length- <span class="number">1</span>) &#123;</span><br><span class="line">            left = nums[index];</span><br><span class="line">            right = Integer.MAX_VALUE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = nums[index];</span><br><span class="line">            right = nums[index + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        tempArray.add(left);</span><br><span class="line">        tempArray.add(right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMax</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? b : a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>两种方式感觉还是第一种理解和书写上更加简单明了，第二种方式在理解和书写上相对困难，而且实际表现出的性能优化也没有特别夸张，可能在非常大的数据量上会表现更加好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度困难）&quot;&gt;&lt;a href=&quot;#问题描述（难度困难）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度困难）&quot;&gt;&lt;/a&gt;问题描述（难度困难）&lt;/h3&gt;&lt;p&gt;There are two sorted arrays &lt;strong&gt;nu
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linked List Cycle II</title>
    <link href="http://jianghao.wang/2019/Linked%20List%20Cycle%20II/"/>
    <id>http://jianghao.wang/2019/Linked List Cycle II/</id>
    <published>2019-05-13T03:17:13.356Z</published>
    <updated>2019-05-13T06:14:45.502Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度中等）"><a href="#问题描述（难度中等）" class="headerlink" title="问题描述（难度中等）"></a>问题描述（难度中等）</h3><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p><p>To represent a cycle in the given linked list, we use an integer <code>pos</code>which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p><p><strong>Note:</strong> Do not modify the linked list.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [3,2,0,-4], pos = 1</span><br><span class="line">Output: tail connects to node index 1</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2], pos = 0</span><br><span class="line">Output: tail connects to node index 0</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the first node.</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1], pos = -1</span><br><span class="line">Output: no cycle</span><br><span class="line">Explanation: There is no cycle in the linked list.</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><h3 id="方法一：用HashSet检查重复"><a href="#方法一：用HashSet检查重复" class="headerlink" title="方法一：用HashSet检查重复"></a>方法一：用HashSet检查重复</h3><p>这里将每个节点看作独立的对象，<strong><em>散列到HashSet中</em></strong>，如果出现了重复节点，就直接返回当前的节点，那么该节点就是环的起点。这种方法比较直观，当然需要消耗n的空间复杂度。穿插记录下这里的每个节点都会根据hashCode去散列到数组不同的位置，我们没有重写hashCode和equals方法，那么默认每个object都有不同的hashCode，并且eqauls方法也只返回引用的比较结果。<strong>Effective Java中对对象重写equal方法有个规范，需要同时重写hashCode方法，主要为了避免用当前类对象作为Hash这种数据结构的key的时候会导致不一致，equals相等但是hashCode不想等，导致逻辑上认为相等的一个对象被散列到两个链表上。</strong></p><h3 id="方法一代码"><a href="#方法一代码" class="headerlink" title="方法一代码"></a>方法一代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> HashSet&lt;ListNode&gt; hashSet=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (head!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashSet.contains(head))&#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                hashSet.add(head);</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看起来逻辑是非常清晰的，实现非常的简单。</p><h3 id="方法二：快慢指针遍历"><a href="#方法二：快慢指针遍历" class="headerlink" title="方法二：快慢指针遍历"></a>方法二：快慢指针遍历</h3><p>方法一虽然实现比较简单但是需要n的空间复杂度，在判断链表是否有环的练习题我们同样可以用快慢指针，返回相遇点，但是这里<strong>需要寻找环的起点</strong>，这个自己没有想到好的solution，从disscuss中发现了一些宝藏男孩。这里我们简单推理重现一下。</p><p><img src="https://arthornye.github.io/images/circle.jpg" alt="cmd-markdown-logo"></p><p>这里假设我们慢指针以一步的步长往前走，快指针两步走，最终相遇在<strong>Meet Pointer</strong>的位置，慢指针走了<strong>S</strong>的距离，快指针走了<strong>2S</strong>距离，根据图中可以推导出<strong>A=C+(N-1)*loop</strong>，也就是说设置两个起点一个从链表头部开始，一个从<strong>Meet Pointer</strong>开始，分别往下遍历，最终会在<strong>Circle Start Pointer</strong>相遇。整个算法的过程是第一次循环找到<strong>Meet Pointer</strong>,第二次循环找到<strong>Circle Start Pointer</strong>。</p><h3 id="方法二代码"><a href="#方法二代码" class="headerlink" title="方法二代码"></a>方法二代码</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycleUsingPointer</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head ==<span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next ==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pointer1=head.next;</span><br><span class="line">        ListNode pointer2=head.next.next;</span><br><span class="line">        <span class="comment">//step1:找出环的位置</span></span><br><span class="line">        <span class="keyword">while</span> (pointer1!=pointer2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pointer2 ==<span class="keyword">null</span> || pointer2.next ==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pointer2 =pointer2.next.next;</span><br><span class="line">            pointer1 = pointer1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//step2:重新开始一遍扫描环</span></span><br><span class="line">        <span class="keyword">while</span>(head != pointer1)&#123;</span><br><span class="line">            head=head.next;</span><br><span class="line">            pointer1=pointer1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>第一种方式较为直观，实现上较为简单，但是需要占用n的空间复杂度。第二种时间空间效率更高，但是实现上一开始比较难想到。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度中等）&quot;&gt;&lt;a href=&quot;#问题描述（难度中等）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度中等）&quot;&gt;&lt;/a&gt;问题描述（难度中等）&lt;/h3&gt;&lt;p&gt;Given a linked list, return the node w
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Kth Largest Element in a Stream</title>
    <link href="http://jianghao.wang/2019/Kth%20Largest%20Element%20in%20a%20Stream/"/>
    <id>http://jianghao.wang/2019/Kth Largest Element in a Stream/</id>
    <published>2019-05-10T01:50:51.499Z</published>
    <updated>2019-05-10T02:05:15.124Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度简单）"><a href="#问题描述（难度简单）" class="headerlink" title="问题描述（难度简单）"></a>问题描述（难度简单）</h3><p>Design a class to find the <strong>k</strong>th largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p>Your <code>KthLargest</code> class will have a constructor which accepts an integer <code>k</code> and an integer array <code>nums</code>, which contains initial elements from the stream. For each call to the method <code>KthLargest.add</code>, return the element representing the kth largest element in the stream.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int k = 3;</span><br><span class="line">int[] arr = [4,5,8,2];</span><br><span class="line">KthLargest kthLargest = new KthLargest(3, arr);</span><br><span class="line">kthLargest.add(3);   // returns 4</span><br><span class="line">kthLargest.add(5);   // returns 5</span><br><span class="line">kthLargest.add(10);  // returns 5</span><br><span class="line">kthLargest.add(9);   // returns 8</span><br><span class="line">kthLargest.add(4);   // returns 8</span><br></pre></td></tr></table></figure><p><strong>Note:</strong><br>You may assume that <code>nums</code>‘ length ≥ <code>k-1</code> and <code>k</code> ≥ 1.</p><h3 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h3><p>维护一个k大小的数组，排序时间复杂度klogk，每次进入新元素判断当前k个有序数组中最小值，小于最小值不进入，大于最小值进入。<strong>整体时间复杂度nklogk。</strong></p><h3 id="方法一代码"><a href="#方法一代码" class="headerlink" title="方法一代码"></a>方法一代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> FindKLargestNumber;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KthLargestTwo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KthLargestTwo</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        <span class="keyword">int</span> numsLength = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsLength; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; k-<span class="number">1</span>) &#123;</span><br><span class="line">                Collections.sort(array);</span><br><span class="line">                add(nums[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                array.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.size() &lt; k) &#123;</span><br><span class="line">            array.add(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; array.get(<span class="number">0</span>)) &#123;</span><br><span class="line">            array.set(<span class="number">0</span>, val);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(array);</span><br><span class="line">        <span class="keyword">return</span> array.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：优先队列"><a href="#方法二：优先队列" class="headerlink" title="方法二：优先队列"></a>方法二：优先队列</h3><p>单纯排序的算法klogk的时间复杂度还有优化的空间，如果是最小堆的话搜素插入的时间只需要logk的复杂度，这里我们增加一个优先级队列的版本。<strong>优先级队列默认是一个堆的数据结构，堆这种数据结构是一个完全二叉树，满足每个子节点都要比父节点要小（小顶堆）或者大（大顶堆）。所以堆顶永远是k个数当中最小的，只需要比较堆顶的元素即可。同样的搜索插入的复杂度是logk。</strong></p><h3 id="方法二代码"><a href="#方法二代码" class="headerlink" title="方法二代码"></a>方法二代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> FindKLargestNumber;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Method 1:采用优先级队列（最小堆）的方式实现，nlogk时间复杂度，k的空间复杂度</span></span><br><span class="line"><span class="comment"> * Method 2:采用排序的方式，nklogk时间复杂度，k的空间复杂度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;Integer&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建一个有k个元素的堆</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KthLargest</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        Arrays.stream(nums).forEach(integer -&gt;</span><br><span class="line">                add(integer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果优先级队列中数量小于k，直接往最小堆中追加</span></span><br><span class="line">        <span class="keyword">if</span> (priorityQueue.size() &lt; k) &#123;</span><br><span class="line">            priorityQueue.offer(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (priorityQueue.peek() &lt; val) &#123;<span class="comment">//如果当前追加元素大于堆顶的元素，将堆顶的元素poll滚出，然后将当前的值offer进入堆</span></span><br><span class="line">            priorityQueue.poll();</span><br><span class="line">            priorityQueue.offer(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> priorityQueue.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        KthLargest kthLargest = <span class="keyword">new</span> KthLargest(<span class="number">3</span>, arr);</span><br><span class="line">        System.out.println(kthLargest.add(<span class="number">3</span>));   <span class="comment">// returns 4</span></span><br><span class="line">        System.out.println(kthLargest.add(<span class="number">5</span>));   <span class="comment">// returns 5</span></span><br><span class="line">        System.out.println(kthLargest.add(<span class="number">10</span>));  <span class="comment">// returns 5</span></span><br><span class="line">        System.out.println(kthLargest.add(<span class="number">9</span>));   <span class="comment">// returns 8</span></span><br><span class="line">        System.out.println(kthLargest.add(<span class="number">4</span>));   <span class="comment">// returns 8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本质上两种方式都是维护一个k大小的数据结构，优先级队列在搜索插入的时间复杂度上具备优势，只需要logk的时间复杂度，优先级队列本质上是一个小顶堆。我们可以利用优先级队列去优化方法一。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度简单）&quot;&gt;&lt;a href=&quot;#问题描述（难度简单）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度简单）&quot;&gt;&lt;/a&gt;问题描述（难度简单）&lt;/h3&gt;&lt;p&gt;Design a class to find the &lt;strong&gt;k&lt;/
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Reverse Linked List</title>
    <link href="http://jianghao.wang/2019/Reverse%20Linked%20List/"/>
    <id>http://jianghao.wang/2019/Reverse Linked List/</id>
    <published>2019-05-08T07:18:20.669Z</published>
    <updated>2019-05-16T14:42:28.027Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述（难度简单）"><a href="#题目描述（难度简单）" class="headerlink" title="题目描述（难度简单）"></a>题目描述（难度简单）</h3><p>Reverse a singly linked list.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong></p><p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p><h3 id="方法一：一遍遍历"><a href="#方法一：一遍遍历" class="headerlink" title="方法一：一遍遍历"></a>方法一：一遍遍历</h3><p>一遍遍历，定义一个初始值为null的pre节点，一个current为head的当前节点，nextTemp为current的下一个节点。</p><p><strong>首先定义好pre和current两个节点，中间虚线表示原来链表存在的指向，红色表示当前pre节点位置，绿色表示已经被倒转的节点，蓝色为待倒转节点：</strong></p><p><img src="https://arthornye.github.io/images/reverseone.jpg" alt="cmd-markdown-logo"></p><p><img src="https://arthornye.github.io/images/reversetwo.jpg" alt="cmd-markdown-logo"></p><p><img src="https://arthornye.github.io/images/reversethree.jpg" alt="cmd-markdown-logo"></p><p><strong>最后只需要pre返回也就完成了一次遍历。返回的链表也就是倒转之后的链表。</strong></p><h3 id="方法一代码："><a href="#方法一代码：" class="headerlink" title="方法一代码："></a>方法一代码：</h3><p>在自己写的过程中发现代码并没有这么简洁，算法设计上没有这么完善，针对链表的题目还是需要画出来指向关系，写出优雅。这里循环结束的条件我们可以看到是current=null，然后直接返回pre。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseListOneScanMoreClear</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode nextTemp = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h3><p>递归的版本理解上较为复杂，因为如果递归到尾节点的时候，直接将尾节点返回作为倒转链表的头节点返回，这样的逻辑会有问题，我们总是需要在一次递归中寻找倒转链表的尾节点。<strong>当然我们可以通过记录链表最尾巴的节点作为头节点，然后每次递归返回当前倒转链表的尾节点，缺点就是丧失了递归的美感。</strong>这样的方式写出来的版本会是下面这样的，也比较好理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录倒转链表首节点</span></span><br><span class="line"><span class="keyword">private</span> ListNode newHead;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* method 1 : 利用递归进行反转</span></span><br><span class="line"><span class="comment">* 递归返回的节点每次都是尾节点可以直接追加</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    reverseToTail(head);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.newHead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseToTail</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span> || node.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.newHead=node;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        ListNode tempListNode=reverseToTail(node.next);</span><br><span class="line">        tempListNode.next=node;</span><br><span class="line">        node.next =<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们想能不能每次都返回倒转链表的头部然后不需要遍历到尾节点还能进行追加？我们假设在第三次递归返回的程序体中，后两个节点已经具备了倒转结构并且返回了头节点，也就是<strong>n1-&gt;n2-&gt;n3…n(k)-&gt;n(k+1)&lt;-n(k+2)需要把n(k)节点在第三次递归中追加到倒转链表中。</strong></p><p><img src="https://arthornye.github.io/images/recursive.jpg" alt="cmd-markdown-logo"></p><h3 id="方法二代码："><a href="#方法二代码：" class="headerlink" title="方法二代码："></a>方法二代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.recursion terminater</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//2.drill down</span></span><br><span class="line">    ListNode p = reverseList(head.next);</span><br><span class="line">    <span class="comment">//3.reverse the current level status if needed</span></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归确实还是简洁，根据递归的范式写出来即可。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>链表倒转，主要可以通过一遍遍历和递归的方式来进行实现，实现的过程主要需要关注指针的指向，在指针的操作过程中写出来演示效果会更好，搞清楚指向关系很重要，否则很容易造成逻辑错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述（难度简单）&quot;&gt;&lt;a href=&quot;#题目描述（难度简单）&quot; class=&quot;headerlink&quot; title=&quot;题目描述（难度简单）&quot;&gt;&lt;/a&gt;题目描述（难度简单）&lt;/h3&gt;&lt;p&gt;Reverse a singly linked list.&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
