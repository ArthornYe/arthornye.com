<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TizzyT&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/9dde1b9d65b89035e235650923e5811e</icon>
  <subtitle>即使是拖后腿的，拼死努力的话，也是可以超越精英的。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jianghao.wang/"/>
  <updated>2019-10-26T06:31:43.920Z</updated>
  <id>http://jianghao.wang/</id>
  
  <author>
    <name>yeqiaozhu</name>
    <email>yqz_zjut@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Sort List</title>
    <link href="http://jianghao.wang/2019/leetCode%E7%AE%97%E6%B3%95/P148%20Sort%20List/"/>
    <id>http://jianghao.wang/2019/leetCode算法/P148 Sort List/</id>
    <published>2019-10-26T06:21:40.799Z</published>
    <updated>2019-10-26T06:31:43.920Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度中等）"><a href="#问题描述（难度中等）" class="headerlink" title="问题描述（难度中等）"></a>问题描述（难度中等）</h3><p>Sort a linked list in <em>O</em>(<em>n</em> log <em>n</em>) time using constant space complexity.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">Output: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure><h3 id="方法一：递归归并排序"><a href="#方法一：递归归并排序" class="headerlink" title="方法一：递归归并排序"></a>方法一：递归归并排序</h3><p>记录下时间复杂度分析吧，如何理解归并排序的时间复杂度。假设当前有m个数字待排序，需要被分成logm次，每个同等级的子问题需要m的时间去排序。总体的复杂度为m*logm。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度中等）&quot;&gt;&lt;a href=&quot;#问题描述（难度中等）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度中等）&quot;&gt;&lt;/a&gt;问题描述（难度中等）&lt;/h3&gt;&lt;p&gt;Sort a linked list in &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Daily Temperatures</title>
    <link href="http://jianghao.wang/2019/leetCode%E7%AE%97%E6%B3%95/P739%20Daily%20Temperatures/"/>
    <id>http://jianghao.wang/2019/leetCode算法/P739 Daily Temperatures/</id>
    <published>2019-10-25T08:08:46.890Z</published>
    <updated>2019-10-25T08:34:17.748Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度中等）"><a href="#问题描述（难度中等）" class="headerlink" title="问题描述（难度中等）"></a>问题描述（难度中等）</h3><p>Given a list of daily temperatures <code>T</code>, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put <code>0</code> instead.</p><p>For example, given the list of temperatures <code>T = [73, 74, 75, 71, 69, 72, 76, 73]</code>, your output should be <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>.</p><p><strong>Note:</strong> The length of <code>temperatures</code> will be in the range <code>[1, 30000]</code>. Each temperature will be an integer in the range <code>[30, 100]</code>.</p><h3 id="方法一：Force遍历"><a href="#方法一：Force遍历" class="headerlink" title="方法一：Force遍历"></a>方法一：Force遍历</h3><p>两个循环，<strong>时间复杂度O(N^2)，空间复杂度O(1)</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P739;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 时间复杂度O(N^2)</span></span><br><span class="line"><span class="comment"> * 空间复杂度O(1)</span></span><br><span class="line"><span class="comment"> * 两边循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result=<span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; T.length; x++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = x+<span class="number">1</span>; y &lt; T.length; y++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (T[x]&lt;T[y]) &#123;</span><br><span class="line">                    result[x]=y-x;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints=&#123;<span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">71</span>, <span class="number">69</span>, <span class="number">72</span>, <span class="number">76</span>, <span class="number">73</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> Solution().dailyTemperatures(ints);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：Using-Stack"><a href="#方法二：Using-Stack" class="headerlink" title="方法二：Using Stack"></a>方法二：Using Stack</h3><p>暴力遍历的过程中我们发现有重复没有意义的比较，造成了N^2的复杂度。<strong>用Stack可以减少时间复杂度到O(N)，空间复杂度O(N)。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P739;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 时间复杂度O(N)</span></span><br><span class="line"><span class="comment"> * 空间复杂度O(N)</span></span><br><span class="line"><span class="comment"> * using stack</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-10-25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result=<span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; T[i]&gt;T[stack.peek()])&#123;</span><br><span class="line">                <span class="keyword">int</span> frontIndex=stack.pop();</span><br><span class="line">                result[frontIndex]=i-frontIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints=&#123;<span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">71</span>, <span class="number">69</span>, <span class="number">72</span>, <span class="number">76</span>, <span class="number">73</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> UsingStack().dailyTemperatures(ints);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以用栈减少时间复杂度，数组类的题目碰上重复的计算比较，即可考虑优化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度中等）&quot;&gt;&lt;a href=&quot;#问题描述（难度中等）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度中等）&quot;&gt;&lt;/a&gt;问题描述（难度中等）&lt;/h3&gt;&lt;p&gt;Given a list of daily temperatures &lt;co
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Decode String</title>
    <link href="http://jianghao.wang/2019/leetCode%E7%AE%97%E6%B3%95/P394%20Decode%20String/"/>
    <id>http://jianghao.wang/2019/leetCode算法/P394 Decode String/</id>
    <published>2019-10-23T14:40:17.336Z</published>
    <updated>2019-10-23T14:58:49.099Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度中等）"><a href="#问题描述（难度中等）" class="headerlink" title="问题描述（难度中等）"></a>问题描述（难度中等）</h3><p>Given an encoded string, return its decoded string.</p><p>The encoding rule is: <code>k[encoded_string]</code>, where the <em>encoded_string</em> inside the square brackets is being repeated exactly <em>k</em> times. Note that <em>k</em> is guaranteed to be a positive integer.</p><p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p><p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <em>k</em>. For example, there won’t be input like <code>3a</code> or <code>2[4]</code>.</p><p><strong>Examples:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;3[a]2[bc]&quot;, return &quot;aaabcbc&quot;.</span><br><span class="line">s = &quot;3[a2[c]]&quot;, return &quot;accaccacc&quot;.</span><br><span class="line">s = &quot;2[abc]3[cd]ef&quot;, return &quot;abcabccdcdcdef&quot;.</span><br></pre></td></tr></table></figure><h3 id="方法一：Double-Stack"><a href="#方法一：Double-Stack" class="headerlink" title="方法一：Double Stack"></a>方法一：Double Stack</h3><p>用两个栈，一个保存数字，一个保存字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P394;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; count = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;String&gt; result = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        result.push(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> start = i;</span><br><span class="line">                <span class="keyword">while</span> (s.charAt(i + <span class="number">1</span>) &gt;= <span class="string">'0'</span> &amp;&amp; s.charAt(i + <span class="number">1</span>) &lt;= <span class="string">'9'</span>) i++;</span><br><span class="line">                count.push(Integer.parseInt(s.substring(start, i + <span class="number">1</span>)));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'['</span>) &#123;</span><br><span class="line">                result.push(<span class="string">""</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">']'</span>) &#123;</span><br><span class="line">                String str = result.pop();</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">int</span> times = count.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; times; j += <span class="number">1</span>) &#123;</span><br><span class="line">                    sb.append(str);</span><br><span class="line">                &#125;</span><br><span class="line">                result.push(result.pop() + sb.toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.push(result.pop() + ch);</span><br><span class="line">            &#125;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Solution().decodeString(<span class="string">"3[a2[c]]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度中等）&quot;&gt;&lt;a href=&quot;#问题描述（难度中等）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度中等）&quot;&gt;&lt;/a&gt;问题描述（难度中等）&lt;/h3&gt;&lt;p&gt;Given an encoded string, return its de
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Find the Duplicate Number</title>
    <link href="http://jianghao.wang/2019/leetCode%E7%AE%97%E6%B3%95/P287%20Find%20the%20Duplicate%20Number/"/>
    <id>http://jianghao.wang/2019/leetCode算法/P287 Find the Duplicate Number/</id>
    <published>2019-10-21T13:10:57.016Z</published>
    <updated>2019-10-21T14:34:17.015Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度简单）"><a href="#问题描述（难度简单）" class="headerlink" title="问题描述（难度简单）"></a>问题描述（难度简单）</h3><p>Given an array <em>nums</em> containing <em>n</em> + 1 integers where each integer is between 1 and <em>n</em> (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,4,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,1,3,4,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>You <strong>must not</strong> modify the array (assume the array is read only).</li><li>You must use only constant, <em>O</em>(1) extra space.</li><li>Your runtime complexity should be less than <em>O</em>(<em>n</em>2).</li><li>There is only one duplicate number in the array, but it could be repeated more than once.</li></ol><h3 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h3><p><strong>时间复杂度Nlog(N)，空间复杂度O(1)。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P287;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-10-21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]==nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> UsingSort().findDuplicate(ints);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：哈希Set"><a href="#方法二：哈希Set" class="headerlink" title="方法二：哈希Set"></a>方法二：哈希Set</h3><p><strong>时间复杂度O(1),空间复杂度O(N)。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P287;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-10-18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingHashSet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> UsingHashSet().findDuplicate(ints);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三：快慢指针"><a href="#方法三：快慢指针" class="headerlink" title="方法三：快慢指针"></a>方法三：快慢指针</h3><p>难理解，先摘录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">           fast = nums[nums[fast]];</span><br><span class="line">           slow = nums[slow];</span><br><span class="line">           <span class="keyword">if</span>(fast == slow)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> finder = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">           finder = nums[finder];</span><br><span class="line">           slow = nums[slow];</span><br><span class="line">           <span class="keyword">if</span>(slow == finder)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> slow;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度简单）&quot;&gt;&lt;a href=&quot;#问题描述（难度简单）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度简单）&quot;&gt;&lt;/a&gt;问题描述（难度简单）&lt;/h3&gt;&lt;p&gt;Given an array &lt;em&gt;nums&lt;/em&gt; containin
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>PathSum Problems</title>
    <link href="http://jianghao.wang/2019/leetCode%E7%AE%97%E6%B3%95/PathSum%20Problem/"/>
    <id>http://jianghao.wang/2019/leetCode算法/PathSum Problem/</id>
    <published>2019-10-17T11:30:36.726Z</published>
    <updated>2019-10-18T03:23:56.111Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度简单-112-113-437）"><a href="#问题描述（难度简单-112-113-437）" class="headerlink" title="问题描述（难度简单-112/113/437）"></a>问题描述（难度简单-112/113/437）</h3><p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p><p><strong>Note:</strong> A leaf is a node with no children.</p><p><strong>Example:</strong></p><p>Given the below binary tree and <code>sum = 22</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \    / \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure><p>Return:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="P112"><a href="#P112" class="headerlink" title="P112"></a>P112</h3><h4 id="Using-Recursive"><a href="#Using-Recursive" class="headerlink" title="Using Recursive"></a>Using Recursive</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P112;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> P104.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span> &amp;&amp; root.val==sum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> left=hasPathSum(root.left,sum-root.val);</span><br><span class="line">        <span class="keyword">boolean</span> right=hasPathSum(root.right,sum-root.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left || right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P113"><a href="#P113" class="headerlink" title="P113"></a>P113</h3><h4 id="Using-Recursive-1"><a href="#Using-Recursive-1" class="headerlink" title="Using Recursive"></a>Using Recursive</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P113;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> P104.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root,<span class="keyword">int</span> sum)&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result=findPathSum(root,sum);</span><br><span class="line">        result.forEach(integers -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>,j=integers.size()-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;j)&#123;</span><br><span class="line">                Integer temp=integers.get(i);</span><br><span class="line">                integers.set(i,integers.get(j));</span><br><span class="line">                integers.set(j,temp);</span><br><span class="line">                i++;j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findPathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span> &amp;&amp; root.val==sum) &#123;</span><br><span class="line">            List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            result.add(list);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; leftResult=findPathSum(root.left,sum-root.val);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; rightResult=findPathSum(root.right,sum-root.val);</span><br><span class="line"></span><br><span class="line">        rightResult.forEach(integers -&gt; integers.add(root.val));</span><br><span class="line">        leftResult.stream().forEach(integers -&gt; &#123;</span><br><span class="line">            integers.add(root.val);</span><br><span class="line">            rightResult.add(integers);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rightResult;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Using-Recursive-LinkedList"><a href="#Using-Recursive-LinkedList" class="headerlink" title="Using Recursive+LinkedList"></a>Using Recursive+LinkedList</h4><p>每次递归出来数组无法指定插入位置（数组不利于插入），换成链表，避免了重新换位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P113;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> P104.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接使用linkedList便于插入，不需要重新排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-10-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span> &amp;&amp; root.val==sum) &#123;</span><br><span class="line">            List&lt;Integer&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            result.add(list);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; leftResult=pathSum(root.left,sum-root.val);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; rightResult=pathSum(root.right,sum-root.val);</span><br><span class="line"></span><br><span class="line">        rightResult.forEach(integers -&gt; integers.add(<span class="number">0</span>,root.val));</span><br><span class="line">        leftResult.stream().forEach(integers -&gt; &#123;</span><br><span class="line">            integers.add(<span class="number">0</span>,root.val);</span><br><span class="line">            rightResult.add(integers);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> rightResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P437"><a href="#P437" class="headerlink" title="P437"></a>P437</h3><p>类比上面两题虽然这道标记为简单，但是感觉理解和逻辑上难度更大。</p><h4 id="Using-Recursive-2"><a href="#Using-Recursive-2" class="headerlink" title="Using Recursive"></a>Using Recursive</h4><p>对于递归问题我们首先要明确我们需要解决的问题，这里需要解决的问题是，二叉树中有几个和为指定sum的组合。我们的输入是root和sum，输出是组合数量。然后我们尝试将这个问题分解为子问题，要找到任意节点为根，和为sum的所有可能。所以第一个递归是遍历以每个节点为根的和为sum的数量，第二个递归是根为特定节点的和为sum的数量。</p><ul><li><strong>明确需要解决的问题。函数的输入输出可递归分解为子问题。</strong></li><li><strong>构造出递归的基本结构。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P437;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> CommonUtils.TreeNodeUtils;</span><br><span class="line"><span class="keyword">import</span> P104.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//以当前root节点开头的 统计</span></span><br><span class="line">        <span class="keyword">int</span> mid=count(root,sum);</span><br><span class="line">        <span class="keyword">int</span> left=pathSum(root.left,sum);</span><br><span class="line">        <span class="keyword">int</span> right=pathSum(root.right,sum);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mid+left+right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> isMe=(root.val==sum)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> countLeft=count(root.left,sum-root.val);</span><br><span class="line">        <span class="keyword">int</span> countRight=count(root.right,sum-root.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isMe+countLeft+countRight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints=&#123;<span class="number">10</span>,<span class="number">5</span>,-<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">3</span>,-<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        TreeNode treeNode=TreeNodeUtils.buildTreeNodeUsingArray(ints);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Solution().pathSum(treeNode,<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在写递归的过程中首先参考递归的书写范式，逆向考虑递归要跟踪调用栈实际上非常复杂。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度简单-112-113-437）&quot;&gt;&lt;a href=&quot;#问题描述（难度简单-112-113-437）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度简单-112/113/437）&quot;&gt;&lt;/a&gt;问题描述（难度简单-112/113/43
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Shortest Unsorted Continuous Subarray</title>
    <link href="http://jianghao.wang/2019/leetCode%E7%AE%97%E6%B3%95/P581%20Shortest%20Unsorted%20Continuous%20Subarray/"/>
    <id>http://jianghao.wang/2019/leetCode算法/P581 Shortest Unsorted Continuous Subarray/</id>
    <published>2019-10-16T02:21:00.385Z</published>
    <updated>2019-10-16T02:31:51.520Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度简单-581）"><a href="#问题描述（难度简单-581）" class="headerlink" title="问题描述（难度简单-581）"></a>问题描述（难度简单-581）</h3><p>Given an integer array, you need to find one <strong>continuous subarray</strong> that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.</p><p>You need to find the <strong>shortest</strong> such subarray and output its length.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [2, 6, 4, 8, 10, 9, 15]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>Then length of the input array is in range [1, 10,000].</li><li>The input array may contain duplicates, so ascending order here means <strong>&lt;=</strong>.</li></ol><h3 id="方法一：sort-循环"><a href="#方法一：sort-循环" class="headerlink" title="方法一：sort+循环"></a>方法一：sort+循环</h3><p>直接复制一个数组出来，排序完了之后比较排序和非排序数组。<strong>时间复杂度O(NlogN)，空间复杂度O(N)。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P581;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-10-15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortSolution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] copy=Arrays.copyOf(nums,nums.length);</span><br><span class="line">        Arrays.sort(copy);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=nums.length-<span class="number">1</span>,shortest=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]==copy[i]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[j]==copy[j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]!=copy[i] &amp;&amp; nums[j]!=copy[j]) &#123;</span><br><span class="line">                shortest=j-i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shortest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> SortSolution().findUnsortedSubarray(ints);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：两边遍历"><a href="#方法二：两边遍历" class="headerlink" title="方法二：两边遍历"></a>方法二：两边遍历</h3><p>从前往后找到比前面最大值还要小的值，从后往前找到比之前最小值还要大的值，即为边界值。<strong>时间复杂度O(N),空间复杂度O(1)。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P581;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两次遍历</span></span><br><span class="line"><span class="comment"> * 遍历的过程中保存最大值和最小值</span></span><br><span class="line"><span class="comment"> * 判断当前的值大于这个最大值的时候就是end位置</span></span><br><span class="line"><span class="comment"> * 判断当前的值小于这个最小值的时候就是begin位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-10-15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingOneCircle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max=Integer.MIN_VALUE,min=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> end=-<span class="number">1</span>;<span class="keyword">int</span> begin=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            max=Math.max(max,nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&lt;max) &#123;</span><br><span class="line">                end=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = nums.length-<span class="number">1</span>; j &gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">            min=Math.min(min,nums[j]);</span><br><span class="line">            <span class="keyword">if</span> (nums[j]&gt;min) &#123;</span><br><span class="line">                begin=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> end-begin+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints=&#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> UsingOneCircle().findUnsortedSubarray(ints));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度简单-581）&quot;&gt;&lt;a href=&quot;#问题描述（难度简单-581）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度简单-581）&quot;&gt;&lt;/a&gt;问题描述（难度简单-581）&lt;/h3&gt;&lt;p&gt;Given an integer array
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Target Sum</title>
    <link href="http://jianghao.wang/2019/leetCode%E7%AE%97%E6%B3%95/P494%20Target%20Sum/"/>
    <id>http://jianghao.wang/2019/leetCode算法/P494 Target Sum/</id>
    <published>2019-10-14T09:23:02.325Z</published>
    <updated>2019-10-15T06:13:07.669Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度中等-494）"><a href="#问题描述（难度中等-494）" class="headerlink" title="问题描述（难度中等-494）"></a>问题描述（难度中等-494）</h3><p>You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols <code>+</code> and <code>-</code>. For each integer, you should choose one from <code>+</code> and <code>-</code> as its new symbol.</p><p>Find out how many ways to assign symbols to make sum of integers equal to target S.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: nums is [1, 1, 1, 1, 1], S is 3. </span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 = 3</span><br><span class="line">+1-1+1+1+1 = 3</span><br><span class="line">+1+1-1+1+1 = 3</span><br><span class="line">+1+1+1-1+1 = 3</span><br><span class="line">+1+1+1+1-1 = 3</span><br><span class="line"></span><br><span class="line">There are 5 ways to assign symbols to make the sum of nums be target 3.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The length of the given array is positive and will not exceed 20.</li><li>The sum of elements in the given array will not exceed 1000.</li><li>Your output answer is guaranteed to be fitted in a 32-bit integer.</li></ol><h3 id="方法一：Using-Recursive"><a href="#方法一：Using-Recursive" class="headerlink" title="方法一：Using Recursive"></a>方法一：Using Recursive</h3><p>通过递归，递归有重复的子结构。可以通过DP改善。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P494;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归解决O(N^2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nums=nums;</span><br><span class="line">        <span class="keyword">return</span> findTargetSumWaysIndex(nums.length-<span class="number">1</span>,S);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWaysIndex</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[index]==<span class="number">0</span> &amp;&amp; S==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Math.abs(S)==Math.abs(nums[index])?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> findTargetSumWaysIndex(index-<span class="number">1</span>,S-nums[index])+findTargetSumWaysIndex(index-<span class="number">1</span>,S+nums[index]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> Solution().findTargetSumWays(ints,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：Using-DP"><a href="#方法二：Using-DP" class="headerlink" title="方法二：Using DP"></a>方法二：Using DP</h3><p>通过dp规避重复子问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P494;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-10-14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingDPSolution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i: nums) sum+=i;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;sum || s&lt;-sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*sum+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>+sum] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*sum+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k&lt;<span class="number">2</span>*sum+<span class="number">1</span>; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[k]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    next[k + nums[i]] += dp[k];</span><br><span class="line">                    next[k - nums[i]] += dp[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sum+s];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ints1=&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> UsingDPSolution().findTargetSumWays(ints,<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> UsingDPSolution().findTargetSumWays(ints1,<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的存储结构图：</p><p><img src="http://arthornye.github.io/images/dp.png" alt="cmd-markdown-logo"></p><h3 id="方法三：Using-DFS"><a href="#方法三：Using-DFS" class="headerlink" title="方法三：Using DFS"></a>方法三：Using DFS</h3><p>回溯可以通过递归的方式去实现。这里通过map保存下重复的运算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, <span class="number">0</span>, S, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, <span class="keyword">int</span> sum, <span class="keyword">int</span> S, Map&lt;String, Integer&gt; map)</span></span>&#123;</span><br><span class="line">        String encodeString = index + <span class="string">"-&gt;"</span> + sum;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(encodeString))&#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(encodeString);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == S)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> curNum = nums[index];</span><br><span class="line">        <span class="keyword">int</span> add = helper(nums, index + <span class="number">1</span>, sum - curNum, S, map);</span><br><span class="line">        <span class="keyword">int</span> minus = helper(nums, index + <span class="number">1</span>, sum + curNum, S, map);</span><br><span class="line">        map.put(encodeString, add + minus);</span><br><span class="line">        <span class="keyword">return</span> add + minus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度中等-494）&quot;&gt;&lt;a href=&quot;#问题描述（难度中等-494）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度中等-494）&quot;&gt;&lt;/a&gt;问题描述（难度中等-494）&lt;/h3&gt;&lt;p&gt;You are given a list o
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Comparator和Comparable接口</title>
    <link href="http://jianghao.wang/2019/Java/Comparator%E5%92%8CComparable%E6%8E%A5%E5%8F%A3/"/>
    <id>http://jianghao.wang/2019/Java/Comparator和Comparable接口/</id>
    <published>2019-10-12T03:23:57.487Z</published>
    <updated>2019-10-16T09:25:42.861Z</updated>
    
    <content type="html"><![CDATA[<p>通常我们自定义的一些类需要进行比较，要用到Comparator自定义比较器传递给对应容器或者实现Comparable接口。本文主要介绍两种方式的区别。</p><h3 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h3><p>Comparable是排序接口。若一个类实现了Comparable接口，就意味着该类支持排序。实现了Comparable接口的类的对象的列表或数组可以通过Collections.sort或Arrays.sort进行自动排序。此外，实现此接口的对象可以用作有序映射中的键或有序集合中的集合，无需指定比较器。该接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>此接口只有一个方法compare，比较此对象与指定对象的顺序，如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。</strong></p><h3 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a>Comparator接口</h3><p>Comparator是比较接口，我们如果需要控制某个类的次序，而该类本身不支持排序(即没有实现Comparable接口，那么我们就可以建立一个“该类的比较器”来进行排序，这个“比较器”只需要实现Comparator接口即可。也就是说，<strong><em>我们可以通过实现Comparator来自定义一个比较器</em></strong>，然后通过这个比较器对类进行排序。该接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.ToIntFunction;</span><br><span class="line"><span class="keyword">import</span> java.util.function.ToLongFunction;</span><br><span class="line"><span class="keyword">import</span> java.util.function.ToDoubleFunction;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparators;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title">reversed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.reverseOrder(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title">thenComparingInt</span><span class="params">(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thenComparing(comparingInt(keyExtractor));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title">thenComparingLong</span><span class="params">(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thenComparing(comparingLong(keyExtractor));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title">thenComparingDouble</span><span class="params">(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thenComparing(comparingDouble(keyExtractor));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function">Comparator&lt;T&gt; <span class="title">reverseOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.reverseOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function">Comparator&lt;T&gt; <span class="title">naturalOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Comparator&lt;T&gt;) Comparators.NaturalOrderComparator.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Comparator&lt;T&gt; <span class="title">nullsFirst</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Comparators.NullComparator&lt;&gt;(<span class="keyword">true</span>, comparator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Comparator&lt;T&gt; <span class="title">nullsLast</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Comparators.NullComparator&lt;&gt;(<span class="keyword">false</span>, comparator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U&gt; <span class="function">Comparator&lt;T&gt; <span class="title">comparing</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; keyExtractor,</span></span></span><br><span class="line"><span class="function"><span class="params">            Comparator&lt;? <span class="keyword">super</span> U&gt; keyComparator)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Objects.requireNonNull(keyExtractor);</span><br><span class="line">        Objects.requireNonNull(keyComparator);</span><br><span class="line">        <span class="keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable)</span><br><span class="line">            (c1, c2) -&gt; keyComparator.compare(keyExtractor.apply(c1),</span><br><span class="line">                                              keyExtractor.apply(c2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U extends Comparable&lt;? <span class="keyword">super</span> U&gt;&gt; <span class="function">Comparator&lt;T&gt; <span class="title">comparing</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; keyExtractor)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Objects.requireNonNull(keyExtractor);</span><br><span class="line">        <span class="keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable)</span><br><span class="line">            (c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Comparator&lt;T&gt; <span class="title">comparingInt</span><span class="params">(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(keyExtractor);</span><br><span class="line">        <span class="keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable)</span><br><span class="line">            (c1, c2) -&gt; Integer.compare(keyExtractor.applyAsInt(c1), keyExtractor.applyAsInt(c2));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Comparator&lt;T&gt; <span class="title">comparingLong</span><span class="params">(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(keyExtractor);</span><br><span class="line">        <span class="keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable)</span><br><span class="line">            (c1, c2) -&gt; Long.compare(keyExtractor.applyAsLong(c1), keyExtractor.applyAsLong(c2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Comparator&lt;T&gt; <span class="title">comparingDouble</span><span class="params">(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(keyExtractor);</span><br><span class="line">        <span class="keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable)</span><br><span class="line">            (c1, c2) -&gt; Double.compare(keyExtractor.applyAsDouble(c1), keyExtractor.applyAsDouble(c2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要关注前两个方法，后面的方法都是一些比较方便的初始化的函数。</p><ul><li><strong>若一个类要实现Comparator接口：它一定要实现compare(T o1, T o2) 函数，但可以不实现 equals(Object obj) 函数。</strong></li><li><strong>int compare(T o1, T o2) 是“比较o1和o2的大小”。返回“负数”，意味着“o1比o2小”；返回“零”，意味着“o1等于o2”；返回“正数”，意味着“o1大于o2”。</strong></li></ul><p>现在假如上面的Person类没有实现Comparable接口，该如何比较大小呢？我们可以新建一个类，让其实现Comparator接口，从而构造一个“自定义比较器”。</p><h3 id="Comparator和Comparable的区别"><a href="#Comparator和Comparable的区别" class="headerlink" title="Comparator和Comparable的区别"></a>Comparator和Comparable的区别</h3><p>Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。而Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。</p><p>Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。</p><ul><li><strong><em>用Comparable 简单， 只要实现Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码。</em></strong></li><li><strong><em>Comparator 的好处是不需要修改源代码， 而是另外实现一个比较器， 当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去就可以比大小了。</em></strong></li></ul><p>　</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常我们自定义的一些类需要进行比较，要用到Comparator自定义比较器传递给对应容器或者实现Comparable接口。本文主要介绍两种方式的区别。&lt;/p&gt;
&lt;h3 id=&quot;Comparable接口&quot;&gt;&lt;a href=&quot;#Comparable接口&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="Java" scheme="http://jianghao.wang/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Move Zeroes.</title>
    <link href="http://jianghao.wang/2019/leetCode%E7%AE%97%E6%B3%95/P283%20Move%20Zeroes/"/>
    <id>http://jianghao.wang/2019/leetCode算法/P283 Move Zeroes/</id>
    <published>2019-10-12T02:47:51.254Z</published>
    <updated>2019-10-14T09:26:46.756Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度简单-283）"><a href="#问题描述（难度简单-283）" class="headerlink" title="问题描述（难度简单-283）"></a>问题描述（难度简单-283）</h3><p>Given an array <code>nums</code>, write a function to move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0,3,12]</span><br><span class="line">Output: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>Note</strong>:</p><ol><li>You must do this <strong>in-place</strong> without making a copy of the array.</li><li>Minimize the total number of operations.</li></ol><h3 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h3><p>两个index遍历，遍历到符合条件的节点互换位置。<strong>时间复杂度O(N),空间复杂度O(1)。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P283;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双指针 时间复杂度O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;nums.length &amp;&amp; j&lt;nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j]!=<span class="number">0</span>) &#123;</span><br><span class="line">                    mid=nums[i];</span><br><span class="line">                    nums[i]=nums[j];</span><br><span class="line">                    nums[j]=mid;</span><br><span class="line">                    i++;j++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i++;j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Solution().moveZeroes(ints);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度简单-283）&quot;&gt;&lt;a href=&quot;#问题描述（难度简单-283）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度简单-283）&quot;&gt;&lt;/a&gt;问题描述（难度简单-283）&lt;/h3&gt;&lt;p&gt;Given an array &lt;code&gt;n
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Top K Frequent Elements</title>
    <link href="http://jianghao.wang/2019/leetCode%E7%AE%97%E6%B3%95/P347%20Top%20K%20Frequent%20Elements/"/>
    <id>http://jianghao.wang/2019/leetCode算法/P347 Top K Frequent Elements/</id>
    <published>2019-10-11T09:28:34.405Z</published>
    <updated>2019-10-11T10:04:01.406Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度中等-347）"><a href="#问题描述（难度中等-347）" class="headerlink" title="问题描述（难度中等-347）"></a>问题描述（难度中等-347）</h3><p>Given a non-empty array of integers, return the <strong>k</strong> most frequent elements.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1], k = 1</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>You may assume <em>k</em> is always valid, 1 ≤ <em>k</em> ≤ number of unique elements.</li><li>Your algorithm’s time complexity <strong>must be</strong> better than O(<em>n</em> log <em>n</em>), where <em>n</em> is the array’s size.</li></ul><h3 id="方法一：HashMap-PriorityQueue"><a href="#方法一：HashMap-PriorityQueue" class="headerlink" title="方法一：HashMap+PriorityQueue"></a>方法一：HashMap+PriorityQueue</h3><h4 id="复杂度分析摘录"><a href="#复杂度分析摘录" class="headerlink" title="复杂度分析摘录"></a>复杂度分析摘录</h4><p><strong>Complexity Analysis</strong></p><ul><li>Time complexity : <strong>O(<em>N</em>log(<em>k</em>)</strong>. The complexity of <code>Counter</code> method is <strong>O(<em>N</em>)</strong>. To build a heap and output list takes <strong>O(<em>N</em>log(<em>k</em>))</strong>. Hence the overall complexity of the algorithm is <strong>O(N + Nlog(k)) =O(<em>N</em>log(<em>k</em>))</strong>.</li><li>Space complexity : <strong>O(<em>N</em></strong>) to store the hash map.</li></ul><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><p>通过HashMap进行计算，再通过优先级队列最小堆找出前k个出现最多的。<strong>时间复杂度O(N*log(k))，空间复杂度O(N)。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> P347;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先用map再用优先级队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; integerMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//统计完出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (integerMap.containsKey(nums[i])) &#123;</span><br><span class="line">                Integer value=integerMap.get(nums[i]);</span><br><span class="line">                integerMap.put(nums[i],++value);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                integerMap.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*//定义一个比较器</span></span><br><span class="line"><span class="comment">        Comparator&lt;Map.Entry&lt;Integer,Integer&gt;&gt; comparator=</span></span><br><span class="line"><span class="comment">                (entry1,entry2)-&gt; entry1.getValue()-entry2.getValue();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="comment">//定义一个比较器  这个操作可以类比上面的函数表达式</span></span><br><span class="line">        Comparator&lt;Map.Entry&lt;Integer,Integer&gt;&gt; comparator=</span><br><span class="line">                Comparator.comparing(Map.Entry&lt;Integer,Integer&gt;::getValue);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造优先级队列</span></span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;Integer,Integer&gt;&gt; priorityQueue=<span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">                k,comparator</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//放入优先级队列</span></span><br><span class="line">        integerMap.entrySet().forEach(integerIntegerEntry -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (priorityQueue.size()&lt;k) &#123;</span><br><span class="line">                priorityQueue.offer(integerIntegerEntry);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                Map.Entry&lt;Integer,Integer&gt; top=priorityQueue.peek();</span><br><span class="line">                <span class="keyword">if</span> (comparator.compare(integerIntegerEntry,top)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    priorityQueue.poll();</span><br><span class="line">                    priorityQueue.offer(integerIntegerEntry);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//获取k大的key</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer,Integer&gt;&gt; iterator=priorityQueue.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            result.add(iterator.next().getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints=&#123;<span class="number">4</span>,<span class="number">1</span>,-<span class="number">1</span>,<span class="number">2</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> Solution().topKFrequent(ints,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ints1=&#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> Solution().topKFrequent(ints1,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要需要定义一个比较器，传送给PriorityQueue。</p><h3 id="方法二：Map-TreeMap"><a href="#方法二：Map-TreeMap" class="headerlink" title="方法二：Map+TreeMap"></a>方法二：Map+TreeMap</h3><p>这个方法相当于对搜集的结果进行全排序，<strong>时间复杂度O(N*log(N)),空间复杂度O(N)。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P347;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-10-11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingTreeMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; countMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            countMap.put(nums[i],countMap.getOrDefault(nums[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeMap&lt;Integer,List&lt;Integer&gt;&gt; treeMap= <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : countMap.keySet())&#123;</span><br><span class="line">            <span class="keyword">int</span> freq = countMap.get(num);</span><br><span class="line">            <span class="keyword">if</span>(!treeMap.containsKey(freq))&#123;</span><br><span class="line">                treeMap.put(freq, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            treeMap.get(freq).add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(res.size()&lt;k)&#123;</span><br><span class="line">            Map.Entry&lt;Integer, List&lt;Integer&gt;&gt; entry = treeMap.pollLastEntry();</span><br><span class="line">            res.addAll(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints=&#123;<span class="number">4</span>,<span class="number">1</span>,-<span class="number">1</span>,<span class="number">2</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] ints1=&#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> UsingTreeMap().topKFrequent(ints,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">new</span> UsingTreeMap().topKFrequent(ints1,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度中等-347）&quot;&gt;&lt;a href=&quot;#问题描述（难度中等-347）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度中等-347）&quot;&gt;&lt;/a&gt;问题描述（难度中等-347）&lt;/h3&gt;&lt;p&gt;Given a non-empty arra
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Majority Element</title>
    <link href="http://jianghao.wang/2019/leetCode%E7%AE%97%E6%B3%95/P169%20Majority%20Element/"/>
    <id>http://jianghao.wang/2019/leetCode算法/P169 Majority Element/</id>
    <published>2019-10-10T07:37:51.962Z</published>
    <updated>2019-10-17T10:06:45.320Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度简单-169）"><a href="#问题描述（难度简单-169）" class="headerlink" title="问题描述（难度简单-169）"></a>问题描述（难度简单-169）</h3><p>Given an array of size <em>n</em>, find the majority element. The majority element is the element that appears <strong>more than</strong> <code>⌊ n/2 ⌋</code> times.</p><p>You may assume that the array is non-empty and the majority element always exist in the array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,1,1,1,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><h3 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h3><p>直接排序，取出中间的索引值。因为数量大于一半，所以中间的值肯定是大多数的值。<strong>时间复杂度O(nlogn)，空间复杂度O(1)。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">  <span class="keyword">int</span> len = nums.length;</span><br><span class="line">  <span class="keyword">return</span> nums[len/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：using-hash"><a href="#方法二：using-hash" class="headerlink" title="方法二：using hash"></a>方法二：using hash</h3><p>一遍扫描，用HashMap记录出现的次数，中间记录出现最多的key。<strong>时间复杂度O(n)，空间复杂度O(n)。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P169;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 时间复杂度O(N)</span></span><br><span class="line"><span class="comment"> * 空间复杂度O(N)</span></span><br><span class="line"><span class="comment"> * Using hash</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer,Integer&gt; integerMap=<span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(integerMap.containsKey(nums[i]))&#123;</span><br><span class="line">                Integer value=integerMap.get(nums[i]);</span><br><span class="line">                integerMap.put(nums[i],++value);</span><br><span class="line">                <span class="keyword">if</span>(value&gt;nums.length/<span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                integerMap.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints=&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().majorityElement(ints));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ints1=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().majorityElement(ints1));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ints2=&#123;<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().majorityElement(ints2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三：一遍遍历"><a href="#方法三：一遍遍历" class="headerlink" title="方法三：一遍遍历"></a>方法三：一遍遍历</h3><p>利用数组中某一个数一定会出现一半以上这个特点，只需要一遍遍历就可以完成。<strong>时间复杂度O(n)，空间复杂度O(1)。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> major=num[<span class="number">0</span>], count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;num.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                major=num[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(major==num[i])&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span> count--;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> major;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一遍遍历的方法比较巧妙。利用了同一个数字出现的次数大于一半以上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度简单-169）&quot;&gt;&lt;a href=&quot;#问题描述（难度简单-169）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度简单-169）&quot;&gt;&lt;/a&gt;问题描述（难度简单-169）&lt;/h3&gt;&lt;p&gt;Given an array of size
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Intersection of Two Linked Lists</title>
    <link href="http://jianghao.wang/2019/leetCode%E7%AE%97%E6%B3%95/P160%20Intersection%20of%20Two%20Linked%20Lists/"/>
    <id>http://jianghao.wang/2019/leetCode算法/P160 Intersection of Two Linked Lists/</id>
    <published>2019-10-10T02:10:32.127Z</published>
    <updated>2019-10-10T03:00:22.883Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度简单-160）"><a href="#问题描述（难度简单-160）" class="headerlink" title="问题描述（难度简单-160）"></a>问题描述（难度简单-160）</h3><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p><p>For example, the following two linked lists:</p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_statement.png" target="_blank" rel="noopener"><img src="https://assets.leetcode.com/uploads/2018/12/13/160_statement.png" alt="img"></a></p><p><strong>Example 1:</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" target="_blank" rel="noopener"><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" alt="img"></a></p><p><strong>Example 2:</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png" target="_blank" rel="noopener"><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png" alt="img"></a></p><p><strong>Example 3:</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png" target="_blank" rel="noopener"><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png" alt="img"></a></p><p><strong>Notes:</strong></p><ul><li>If the two linked lists have no intersection at all, return <code>null</code>.</li><li>The linked lists must retain their original structure after the function returns.</li><li>You may assume there are no cycles anywhere in the entire linked structure.</li><li>Your code should preferably run in O(n) time and use only O(1) memory.</li></ul><h3 id="方法一：using-hash"><a href="#方法一：using-hash" class="headerlink" title="方法一：using hash"></a>方法一：using hash</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P160;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> AddTwoNumbers.ListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过set的方式实现，需要占用额外的空间</span></span><br><span class="line"><span class="comment"> * 时间复杂度O(M+N)</span></span><br><span class="line"><span class="comment"> * 空间复杂度O(M)/O(N)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-10-10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode a=headA;</span><br><span class="line">        ListNode b=headB;</span><br><span class="line">        Set&lt;ListNode&gt; aSet=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (a!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            aSet.add(a);</span><br><span class="line">            a=a.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历一下</span></span><br><span class="line">        <span class="keyword">while</span> (b!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (aSet.contains(b)) &#123;</span><br><span class="line">                <span class="keyword">return</span> b;</span><br><span class="line">            &#125;</span><br><span class="line">            b=b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：using-two-pointer"><a href="#方法二：using-two-pointer" class="headerlink" title="方法二：using two pointer"></a>方法二：using two pointer</h3><p>双指针遍历，其中一个链表遍历到结尾之后从另一个链表的开头开始遍历，时间复杂度O(M+N)，空间复杂度O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P160;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> AddTwoNumbers.ListNode;</span><br><span class="line"><span class="keyword">import</span> CommonUtils.ListNodeUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 时间复杂度O(M+N)</span></span><br><span class="line"><span class="comment"> * 空间复杂度O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode a=headA;</span><br><span class="line">        ListNode b=headB;</span><br><span class="line">        <span class="comment">//如果同时到达尾部 没有交点直接返回null</span></span><br><span class="line">        <span class="keyword">while</span> (a!=b)&#123;</span><br><span class="line">            <span class="comment">//a一遍循环结束没有找到交点 继续从b开头节点开始往下走</span></span><br><span class="line">            a=a==<span class="keyword">null</span>?headA:a.next;</span><br><span class="line">            <span class="comment">//b一遍循环结束没有找到交点 继续从a开头节点开始循环 最后一定会遇到交点的</span></span><br><span class="line">            b=b==<span class="keyword">null</span>?headB:b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode listNodeA=ListNodeUtils.createListNode(<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line">        ListNode listNodeB=ListNodeUtils.createListNode(<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Solution().getIntersectionNode(listNodeA,listNodeB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>双指针的方式比较巧妙，注意需要在遍历到尾部的时候重新遍历另一个链表。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度简单-160）&quot;&gt;&lt;a href=&quot;#问题描述（难度简单-160）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度简单-160）&quot;&gt;&lt;/a&gt;问题描述（难度简单-160）&lt;/h3&gt;&lt;p&gt;Write a program to fin
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Min Stack</title>
    <link href="http://jianghao.wang/2019/leetCode%E7%AE%97%E6%B3%95/P155%20Min%20Stack/"/>
    <id>http://jianghao.wang/2019/leetCode算法/P155 Min Stack/</id>
    <published>2019-10-09T13:58:51.836Z</published>
    <updated>2019-10-09T14:13:37.496Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度简单-155）"><a href="#问题描述（难度简单-155）" class="headerlink" title="问题描述（难度简单-155）"></a>问题描述（难度简单-155）</h3><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><ul><li>push(x) – Push element x onto stack.</li><li>pop() – Removes the element on top of the stack.</li><li>top() – Get the top element.</li><li>getMin() – Retrieve the minimum element in the stack.</li></ul><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; Returns -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; Returns 0.</span><br><span class="line">minStack.getMin();   --&gt; Returns -2.</span><br></pre></td></tr></table></figure><h3 id="方法一：双数组实现"><a href="#方法一：双数组实现" class="headerlink" title="方法一：双数组实现"></a>方法一：双数组实现</h3><p>一个数组作为输入的数值栈（stackArray），另一个数组作为最小值栈（minArray）。minArray[i]表示前i个stackArray中的最小值。每次pop出栈的时候同时pop一下minArray。<strong>空间复杂度为O(N)，时间复杂度O(N)。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P155;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过数组实现栈</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; stackArray;</span><br><span class="line">    <span class="comment">//记录最小值，在push和pop的过程中都要更新下当前的最小值</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; minArray;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackArray=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        minArray=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        stackArray.add(x);</span><br><span class="line">        <span class="keyword">int</span> topIndex=minArray.size()-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//最小栈无元素 直接插入</span></span><br><span class="line">        <span class="keyword">if</span>(minArray.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            minArray.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最小栈有元素但是栈顶元素比插入元素小 插入栈顶元素</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;minArray.get(topIndex))&#123;</span><br><span class="line">            minArray.add(minArray.get(topIndex));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最小栈有元素但是栈顶元素比插入元素大 插入插入元素</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            minArray.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stackArray.size()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"元素为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        stackArray.remove(stackArray.size() - <span class="number">1</span>);</span><br><span class="line">        minArray.remove(minArray.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stackArray.size()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"元素为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackArray.get(stackArray.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(minArray.size()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"元素为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minArray.get(minArray.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MinStack minStack = <span class="keyword">new</span> MinStack();</span><br><span class="line">        minStack.push(<span class="number">2</span>);</span><br><span class="line">        minStack.push(<span class="number">0</span>);</span><br><span class="line">        minStack.push(<span class="number">3</span>);</span><br><span class="line">        minStack.push(<span class="number">0</span>);</span><br><span class="line">        minStack.pop();</span><br><span class="line">        System.out.println(minStack.getMin());</span><br><span class="line">        System.out.println(minStack.getMin());</span><br><span class="line">        minStack.pop();</span><br><span class="line">        System.out.println(minStack.getMin());</span><br><span class="line">        minStack.pop();</span><br><span class="line">        System.out.println(minStack.getMin());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="方法二：双数组实现（缩减空间）"><a href="#方法二：双数组实现（缩减空间）" class="headerlink" title="方法二：双数组实现（缩减空间）"></a>方法二：双数组实现（缩减空间）</h3><p>在方法一的基础上，实际上minArray没有必要存储N个最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P155;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 改善第一种方式</span></span><br><span class="line"><span class="comment"> * 最小值的数组不需要存全部的结果结</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-10-09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MInStackUsingTwoArrayBetter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过数组实现栈</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; stackArray;</span><br><span class="line">    <span class="comment">//记录最小值，在push和pop的过程中都要更新下当前的最小值</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; minArray;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MInStackUsingTwoArrayBetter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackArray=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        minArray=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        stackArray.add(x);</span><br><span class="line">        <span class="keyword">int</span> topIndex=minArray.size()-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//最小栈无元素 直接插入</span></span><br><span class="line">        <span class="keyword">if</span>(minArray.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            minArray.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最小栈有元素但是栈顶元素比插入元素大 插入插入元素</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;=minArray.get(topIndex))&#123;</span><br><span class="line">            minArray.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stackArray.size()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"元素为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value=stackArray.remove(stackArray.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(value==minArray.get(minArray.size()-<span class="number">1</span>)) &#123;</span><br><span class="line">            minArray.remove(minArray.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stackArray.size()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"元素为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackArray.get(stackArray.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(minArray.size()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"元素为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minArray.get(minArray.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MInStackUsingTwoArrayBetter minStack = <span class="keyword">new</span> MInStackUsingTwoArrayBetter();</span><br><span class="line">        minStack.push(<span class="number">2</span>);</span><br><span class="line">        minStack.push(<span class="number">3</span>);</span><br><span class="line">        minStack.push(<span class="number">0</span>);</span><br><span class="line">        minStack.push(<span class="number">0</span>);</span><br><span class="line">        System.out.println(minStack.getMin());</span><br><span class="line">        minStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">        System.out.println(minStack.getMin());</span><br><span class="line">        minStack.pop();</span><br><span class="line">        System.out.println(minStack.getMin());</span><br><span class="line">        System.out.println(minStack.top());</span><br><span class="line">        minStack.pop();</span><br><span class="line">        System.out.println(minStack.getMin());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度简单-155）&quot;&gt;&lt;a href=&quot;#问题描述（难度简单-155）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度简单-155）&quot;&gt;&lt;/a&gt;问题描述（难度简单-155）&lt;/h3&gt;&lt;p&gt;Design a stack that su
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Fizz Buzz Multithreaded</title>
    <link href="http://jianghao.wang/2019/leetCode%E7%AE%97%E6%B3%95/P1195%20Fizz%20Buzz%20Multithreaded/"/>
    <id>http://jianghao.wang/2019/leetCode算法/P1195 Fizz Buzz Multithreaded/</id>
    <published>2019-10-08T03:14:12.381Z</published>
    <updated>2019-10-09T14:14:55.761Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度中等-1195）"><a href="#问题描述（难度中等-1195）" class="headerlink" title="问题描述（难度中等-1195）"></a>问题描述（难度中等-1195）</h3><p>Write a program that outputs the string representation of numbers from 1 to <em>n</em>, however:</p><ul><li>If the number is divisible by 3, output “fizz”.</li><li>If the number is divisible by 5, output “buzz”.</li><li>If the number is divisible by both 3 and 5, output “fizzbuzz”.</li></ul><p>For example, for <code>n = 15</code>, we output: <code>1, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz, 11, fizz, 13, 14, fizzbuzz</code>.</p><p>Suppose you are given the following code:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class FizzBuzz &#123;</span><br><span class="line">  public FizzBuzz(int n) &#123; ... &#125;               // constructor</span><br><span class="line">  public void fizz(printFizz) &#123; ... &#125;          // only output &quot;fizz&quot;</span><br><span class="line">  public void buzz(printBuzz) &#123; ... &#125;          // only output &quot;buzz&quot;</span><br><span class="line">  public void fizzbuzz(printFizzBuzz) &#123; ... &#125;  // only output &quot;fizzbuzz&quot;</span><br><span class="line">  public void number(printNumber) &#123; ... &#125;      // only output the numbers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Implement a multithreaded version of <code>FizzBuzz</code> with <strong>four</strong> threads. The same instance of <code>FizzBuzz</code> will be passed to four different threads:</p><ol><li>Thread A will call <code>fizz()</code> to check for divisibility of 3 and outputs <code>fizz</code>.</li><li>Thread B will call <code>buzz()</code> to check for divisibility of 5 and outputs <code>buzz</code>.</li><li>Thread C will call <code>fizzbuzz()</code> to check for divisibility of 3 and 5 and outputs <code>fizzbuzz</code>.</li><li>Thread D will call <code>number()</code> which should only output the numbers.</li></ol><h3 id="方法一：using-volatile"><a href="#方法一：using-volatile" class="headerlink" title="方法一：using volatile"></a>方法一：using volatile</h3><p>通过定义volatile变量flag，以循环自检的方式执行。这里总结下这种方法的通用范式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(trure)&#123;</span><br><span class="line">  <span class="comment">//条件1 条件必须唯一</span></span><br><span class="line">  <span class="keyword">if</span>(flag)&#123;...update flag&#125;</span><br><span class="line">  <span class="comment">//条件2 条件必须唯一</span></span><br><span class="line">  <span class="keyword">if</span>(flag)&#123;...update flag&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的范式可以通用，但是可能会导致TLP问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P1195;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntConsumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-10-04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingVolatile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> currentValue=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UsingVolatile</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizz.run() outputs "fizz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizz</span><span class="params">(Runnable printFizz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(currentValue&lt;=n &amp;&amp; currentValue%<span class="number">3</span>==<span class="number">0</span> &amp;&amp; currentValue%<span class="number">15</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//执行打印fizz代码</span></span><br><span class="line">                printFizz.run();</span><br><span class="line">                ++currentValue;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printBuzz.run() outputs "buzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buzz</span><span class="params">(Runnable printBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(currentValue&lt;=n &amp;&amp; currentValue % <span class="number">5</span>== <span class="number">0</span> &amp;&amp; currentValue % <span class="number">15</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                printBuzz.run();</span><br><span class="line">                ++currentValue;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizzBuzz.run() outputs "fizzbuzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span><span class="params">(Runnable printFizzBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(currentValue&lt;=n &amp;&amp; currentValue % <span class="number">15</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                printFizzBuzz.run();</span><br><span class="line">                ++currentValue;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber.accept(x) outputs "x", where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">number</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(currentValue%<span class="number">3</span>!=<span class="number">0</span> &amp;&amp; currentValue % <span class="number">5</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                printNumber.accept(currentValue);</span><br><span class="line">                ++currentValue;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; strings = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        FizzBuzz fizzBuzz = <span class="keyword">new</span> FizzBuzz(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        Thread t1, t2, t3, t4;</span><br><span class="line"></span><br><span class="line">        (t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fizzBuzz.fizz(() -&gt; strings.add(<span class="string">"fizz"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.err.println(e.toString());</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)).start();</span><br><span class="line"></span><br><span class="line">        (t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fizzBuzz.buzz(() -&gt; strings.add(<span class="string">"buzz"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.err.println(e.toString());</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)).start();</span><br><span class="line"></span><br><span class="line">        (t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fizzBuzz.fizzbuzz(() -&gt; strings.add(<span class="string">"fizzbuzz"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.err.println(e.toString());</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)).start();</span><br><span class="line"></span><br><span class="line">        (t4 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fizzBuzz.number(number -&gt; strings.add(<span class="string">""</span> + number));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.err.println(e.toString());</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t3.join();</span><br><span class="line">            t4.join();</span><br><span class="line">            t2.join();</span><br><span class="line">            t1.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：using-synchronized"><a href="#方法二：using-synchronized" class="headerlink" title="方法二：using synchronized"></a>方法二：using synchronized</h3><p>通过对象提供的基本操作等待/通知范式，等待通知需要定义两个基本操作一个生产一个消费：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">  synchoronized(object)&#123;</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">      object.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行消费过程 例如打印一个b 检查生产的标志变量是否已经生产完成</span></span><br><span class="line">    system.out.println(<span class="string">"b"</span>);</span><br><span class="line">    flag=<span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">  synchornized(object)&#123;</span><br><span class="line">    <span class="comment">//执行生产动作 例如打印一个a 同时将变量修改为已生产</span></span><br><span class="line"> system.out.println(<span class="string">"a"</span>);</span><br><span class="line">    object.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要进行范式的循环，在范式外面加一层循环，于是范式演变成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//执行循环的次数 不断进行消费</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        synchoronized(object)&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        object.wait();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//执行消费过程 例如打印一个b</span></span><br><span class="line">       system.out.println(<span class="string">"b"</span>);</span><br><span class="line">       flag=<span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用上面的范式，我们可以看到关键是要确定两步：</p><ul><li>1.循环次数</li><li>2.变量的等待条件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P1195;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntConsumer;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FizzBuzz</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentValue=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizz.run() outputs "fizz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizz</span><span class="params">(Runnable printFizz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">3</span>-n/<span class="number">15</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (FizzBuzz.class)&#123;</span><br><span class="line">                <span class="keyword">while</span>(currentValue%<span class="number">3</span>!=<span class="number">0</span> || currentValue%<span class="number">15</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    FizzBuzz.class.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//执行打印fizz代码</span></span><br><span class="line">                printFizz.run();</span><br><span class="line">                currentValue++;</span><br><span class="line">                FizzBuzz.class.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printBuzz.run() outputs "buzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buzz</span><span class="params">(Runnable printBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">5</span>-n/<span class="number">15</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (FizzBuzz.class)&#123;</span><br><span class="line">                <span class="keyword">while</span> (currentValue%<span class="number">5</span>!=<span class="number">0</span> || currentValue%<span class="number">15</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    FizzBuzz.class.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                printBuzz.run();</span><br><span class="line">                currentValue++;</span><br><span class="line">                FizzBuzz.class.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizzBuzz.run() outputs "fizzbuzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span><span class="params">(Runnable printFizzBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">15</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (FizzBuzz.class)&#123;</span><br><span class="line">                <span class="keyword">while</span> (currentValue%<span class="number">15</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                    FizzBuzz.class.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                printFizzBuzz.run();</span><br><span class="line">                currentValue++;</span><br><span class="line">                FizzBuzz.class.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber.accept(x) outputs "x", where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">number</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (n-n/<span class="number">3</span>-n/<span class="number">5</span>+n/<span class="number">15</span>); i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (FizzBuzz.class)&#123;</span><br><span class="line">                <span class="keyword">while</span> (currentValue%<span class="number">5</span>==<span class="number">0</span> || currentValue%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    FizzBuzz.class.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                printNumber.accept(currentValue);</span><br><span class="line">                currentValue++;</span><br><span class="line">                FizzBuzz.class.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三：using-lock"><a href="#方法三：using-lock" class="headerlink" title="方法三：using lock"></a>方法三：using lock</h3><p>这里维护多个等待队列貌似没有意义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P1195;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntConsumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-10-04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingLockCondition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentValue=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    ReentrantLock reentrantLock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    Condition condition=reentrantLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UsingLockCondition</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizz.run() outputs "fizz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizz</span><span class="params">(Runnable printFizz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">3</span>-n/<span class="number">15</span>; i++) &#123;</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            <span class="keyword">while</span>(currentValue%<span class="number">3</span>!=<span class="number">0</span> || currentValue%<span class="number">15</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//执行打印fizz代码</span></span><br><span class="line">            printFizz.run();</span><br><span class="line">            currentValue++;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printBuzz.run() outputs "buzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buzz</span><span class="params">(Runnable printBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">5</span>-n/<span class="number">15</span>; i++) &#123;</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            <span class="keyword">while</span> (currentValue%<span class="number">5</span>!=<span class="number">0</span> || currentValue%<span class="number">15</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            printBuzz.run();</span><br><span class="line">            currentValue++;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizzBuzz.run() outputs "fizzbuzz".</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span><span class="params">(Runnable printFizzBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">15</span>; i++) &#123;</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            <span class="keyword">while</span> (currentValue%<span class="number">15</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            printFizzBuzz.run();</span><br><span class="line">            currentValue++;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber.accept(x) outputs "x", where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">number</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (n-n/<span class="number">3</span>-n/<span class="number">5</span>+n/<span class="number">15</span>); i++) &#123;</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            <span class="keyword">while</span> (currentValue%<span class="number">5</span>==<span class="number">0</span> || currentValue%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            printNumber.accept(currentValue);</span><br><span class="line">            currentValue++;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法四：using-atomic"><a href="#方法四：using-atomic" class="headerlink" title="方法四：using atomic"></a>方法四：using atomic</h3><p>利用atomic提供的封装函数，实际上利用cas实现原子写操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ConcurrentModificationException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntConsumer;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FizzBuzz</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger counter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        counter = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateToNext</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!counter.compareAndSet(count, count + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizz</span><span class="params">(Runnable printFizz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">while</span> ((count = counter.get()) &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; count % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                printFizz.run();</span><br><span class="line">                updateToNext(count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buzz</span><span class="params">(Runnable printBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">while</span> ((count = counter.get()) &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count % <span class="number">3</span> != <span class="number">0</span> &amp;&amp; count % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                printBuzz.run();</span><br><span class="line">                updateToNext(count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fizzbuzz</span><span class="params">(Runnable printFizzBuzz)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">while</span> ((count = counter.get()) &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; count % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                printFizzBuzz.run();</span><br><span class="line">                updateToNext(count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">number</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">while</span> ((count = counter.get()) &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count % <span class="number">3</span> != <span class="number">0</span> &amp;&amp; count % <span class="number">5</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                printNumber.accept(count);</span><br><span class="line">                updateToNext(count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过循环自检或者等待通知的方式实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度中等-1195）&quot;&gt;&lt;a href=&quot;#问题描述（难度中等-1195）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度中等-1195）&quot;&gt;&lt;/a&gt;问题描述（难度中等-1195）&lt;/h3&gt;&lt;p&gt;Write a program th
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Balanced Binary Tree</title>
    <link href="http://jianghao.wang/2019/leetCode%E7%AE%97%E6%B3%95/P110%20Balanced%20Binary%20Tree/"/>
    <id>http://jianghao.wang/2019/leetCode算法/P110 Balanced Binary Tree/</id>
    <published>2019-09-30T06:09:52.696Z</published>
    <updated>2019-10-09T14:00:28.921Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度简单-110）"><a href="#问题描述（难度简单-110）" class="headerlink" title="问题描述（难度简单-110）"></a>问题描述（难度简单-110）</h3><p>Given a binary tree, determine if it is height-balanced.</p><p>For this problem, a height-balanced binary tree is defined as:</p><blockquote><p>a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p></blockquote><p><strong>Example 1:</strong></p><p>Given the following tree <code>[3,9,20,null,null,15,7]</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>Return true.</p><p><strong>Example 2:</strong></p><p>Given the following tree <code>[1,2,2,3,3,null,null,4,4]</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     / \</span><br><span class="line">    2   2</span><br><span class="line">   / \</span><br><span class="line">  3   3</span><br><span class="line"> / \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure><p>Return false.</p><h3 id="方法一：递归（Recursive）"><a href="#方法一：递归（Recursive）" class="headerlink" title="方法一：递归（Recursive）"></a>方法一：递归（Recursive）</h3><p>判断平衡树是否平衡的标准：</p><ul><li><strong>左右子树的高度差不大于1。这里的高度值得是树的最大高度。</strong></li></ul><p>根据标准得到一个递归公式（没有好的作图工具，直接看height函数的递归实现）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> height(root)==-<span class="number">1</span>?<span class="keyword">false</span>:<span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode treeNode)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (treeNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> leftHeight=height(treeNode.left);</span><br><span class="line">       <span class="keyword">int</span> rightHeight=height(treeNode.right);</span><br><span class="line">       <span class="keyword">if</span>(leftHeight==-<span class="number">1</span> || rightHeight==-<span class="number">1</span> || Math.abs(leftHeight-rightHeight)&gt;<span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> Math.max(leftHeight,rightHeight)+<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>首先掌握平衡树的判断标准，不能用最大深度减去最小深度来进行计算。需要递归判断左右子树的高度差，当递归到高度差大于1的时候递归往上返回-1值。递归到null时，说明到达了叶子结点的下的空节点，返回0。其他情况都返回左右节点的最大高度加1。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度简单-110）&quot;&gt;&lt;a href=&quot;#问题描述（难度简单-110）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度简单-110）&quot;&gt;&lt;/a&gt;问题描述（难度简单-110）&lt;/h3&gt;&lt;p&gt;Given a binary tree, d
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Single Number</title>
    <link href="http://jianghao.wang/2019/leetCode%E7%AE%97%E6%B3%95/P136%20Single%20Number/"/>
    <id>http://jianghao.wang/2019/leetCode算法/P136 Single Number/</id>
    <published>2019-09-20T07:00:07.169Z</published>
    <updated>2019-09-30T06:15:52.530Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度简单-136）"><a href="#问题描述（难度简单-136）" class="headerlink" title="问题描述（难度简单-136）"></a>问题描述（难度简单-136）</h3><p>Given a <strong>non-empty</strong> array of integers, every element appears <em>twice</em> except for one. Find that single one.</p><p><strong>Note:</strong></p><p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,1,2,1,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><h3 id="XOR（异或）"><a href="#XOR（异或）" class="headerlink" title="XOR（异或）"></a>XOR（异或）</h3><p>如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。</p><h3 id="方法一：一边遍历Map"><a href="#方法一：一边遍历Map" class="headerlink" title="方法一：一边遍历Map"></a>方法一：一边遍历Map</h3><p>一遍遍历保留只出现一次的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map= <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(nums[i])==<span class="keyword">null</span>)&#123;</span><br><span class="line">                map.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                map.remove(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (Integer) map.keySet().toArray()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：XOR"><a href="#方法二：XOR" class="headerlink" title="方法二：XOR"></a>方法二：XOR</h3><p>first , we have to know the bitwise XOR in java:</p><ul><li><strong>0 ^ N = N</strong></li><li><strong>N ^ N = 0</strong></li></ul><p>So….. if N is the single number:</p><p>N1 ^ N1 ^ N2 ^ N2 ^…………..^ Nx ^ Nx ^ N= (N1^N1) ^ (N2^N2) ^…………..^ (Nx^Nx) ^ N= 0 ^ 0 ^ ……….^ 0 ^ N</p><p>= N</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans =<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;i++)</span><br><span class="line">        ans ^= nums[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>采用XOR（异或）的方式，相同的数字都相互抵消了，最后留下单一的不同的数字。也就是方法二的精髓。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度简单-136）&quot;&gt;&lt;a href=&quot;#问题描述（难度简单-136）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度简单-136）&quot;&gt;&lt;/a&gt;问题描述（难度简单-136）&lt;/h3&gt;&lt;p&gt;Given a &lt;strong&gt;non-em
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java中的阻塞队列</title>
    <link href="http://jianghao.wang/2019/%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/Java%E4%B8%AD%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>http://jianghao.wang/2019/并发学习/Java中的阻塞队列/</id>
    <published>2019-07-30T05:00:06.328Z</published>
    <updated>2019-10-16T09:28:54.719Z</updated>
    
    <content type="html"><![CDATA[<p>Java中的阻塞队列，可以基于BlockingQueue接口自定义实现多种自定义阻塞队列。阻塞队列最经典的应用主要是帮助线程池管理任务，是一个经典的等待/通知（生产者/消费者）模型。这里根据源码主要介绍几种比较经典的实现，并提炼出一些经典范式。</p><table><br><tr><br>    <th>add</th><br>    <th>remove</th><br>    <th>抛出异常</th><br></tr><br><tr><br>    <th>put</th><br>    <th>take</th><br>    <th>等待直到中断</th><br></tr><br><tr><br>    <th>offer</th><br>    <th>poll</th><br>    <th>直接返回</th><br></tr><br><tr><br>    <th>offer(time)</th><br>    <th>poll(time)</th><br>    <th>设定等待时间</th><br></tr><br></table><h3 id="LinkedBlockingQueue（基于链表的有界阻塞队列）"><a href="#LinkedBlockingQueue（基于链表的有界阻塞队列）" class="headerlink" title="LinkedBlockingQueue（基于链表的有界阻塞队列）"></a>LinkedBlockingQueue（基于链表的有界阻塞队列）</h3><p>Executors.newFixedThreadPool（根据需要可重用部分消费者线程数）和Executors.newSingledThreadPool（单个消费者线程）都使用了LinkedBlockingQueue无界队列来管理任务。</p><h4 id="put-take（double-lock-wait-notify）"><a href="#put-take（double-lock-wait-notify）" class="headerlink" title="put/take（double lock+wait/notify）"></a>put/take（double lock+wait/notify）</h4><p>通过双锁来增加队列的并发度，通过wait/notify进行等待/通知。因为通常无界队列默认可以容下Integer.MAX_VALUE的任务。</p><h3 id="Design-Bounded-Blocking-Queue"><a href="#Design-Bounded-Blocking-Queue" class="headerlink" title="Design Bounded Blocking Queue"></a>Design Bounded Blocking Queue</h3><p>设计一个阻塞队列，通过等待通知机制设计一个阻塞队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P1188;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设计一个有界阻塞队列</span></span><br><span class="line"><span class="comment"> * Design Bounded Blocking Queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-10-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个队列</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="comment">//队列的capacity 限制容量</span></span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="comment">//定义一个lock</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock reentrantLock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义两个队列</span></span><br><span class="line">    <span class="keyword">private</span> Condition notEmpty=reentrantLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Condition notFull=reentrantLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(Integer size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue=<span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">this</span>.size=size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        reentrantLock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size()==size)&#123;</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(integer);</span><br><span class="line">            notEmpty.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        reentrantLock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.remove();</span><br><span class="line">            notFull.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java中的阻塞队列，可以基于BlockingQueue接口自定义实现多种自定义阻塞队列。阻塞队列最经典的应用主要是帮助线程池管理任务，是一个经典的等待/通知（生产者/消费者）模型。这里根据源码主要介绍几种比较经典的实现，并提炼出一些经典范式。&lt;/p&gt;
&lt;table&gt;&lt;br
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://jianghao.wang/2019/%E9%9D%A2%E8%AF%95/%E7%AE%80%E5%8E%86/"/>
    <id>http://jianghao.wang/2019/面试/简历/</id>
    <published>2019-07-22T08:13:50.299Z</published>
    <updated>2019-09-23T15:11:15.993Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本资料"><a href="#基本资料" class="headerlink" title="基本资料"></a>基本资料</h3><p>姓名 : 叶乔柱                                                       联系电话：18668486087   </p><p>电子邮箱： <a href="mailto:yqz_zjut@aliyun.com" target="_blank" rel="noopener">yqz_zjut@aliyun.com</a>                           毕业院校：浙江工业大学计算机学院</p><p>出生年月：1993年8月                                         专业：计算机科学与技术</p><p>求职意向：Java/全栈                                          技术博客：<a href="http://arthornye.github.io" target="_blank" rel="noopener">http://arthornye.github.io</a> </p><h3 id="职业技能"><a href="#职业技能" class="headerlink" title="职业技能"></a>职业技能</h3><ul><li>专业技能 综合能力： 演讲能力 | 责任心 | 团队精神 | 英语 | 数据库软件 。</li><li>熟悉基于 Mysql 的数据库设计，Sql 性能调优，对数据库引擎有一定的了解。</li><li>熟悉 Spring, Mybatis 框架的使用，且对其原理有一定的理解。</li><li>熟悉 Java 编程基础，熟悉多线程并发，反射，集合等高级特性，并且对 Jvm 有一定的理解。</li><li>了解分布式消息服务，分布式存储缓存，分布式服务框架。 </li><li>熟悉 ReactJS，Jquery，AngularJS，Jsx，Html 标准语法，具备一定的前端开发能力。 </li><li>熟悉 Git 管理代码，Maven 项目管理。  </li></ul><h3 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h3><p><strong>杭州大搜车汽车服务有限公司（新车新零售）</strong>    2017.07 - 2019.09</p><p>先后独立负责线上 App 和 PC 签署汽车销售合同模块搭建，对接公司内部基础服务和支付宝开放平台。参与和阿里天猫共同合作的汽车新零售项目，对接公司内部支付网关和外部天猫平台。负责公司后台运营系统 Web 页面以及后台搭建。对小组内部已有业务做 Sql 性能优化改造。运用 Dubbo，MQ 支付消息，通过 Swagger 为前端提供文档。  </p><p><strong>浙江远图互联科技股份有限公司（互联网医疗）</strong>    2016.06 - 2017.06 </p><p>搭建医院系统 His，Lis 以及 Pacs 适配器，为公司自助终端和移动终端服务提供统一医院内部系统入口，包括挂号，缴费，充值，医保等服务。系统采用 Springmvc+Ibatis+Mysql 实现，通过 Socket，Websevice，存储过程，视图以及 Http 等多种方式与医院内部系统交互，实现复杂的医疗服务逻辑。对接公司内部支付系统和结算系统，实现医院内部的各种支付以及对账。 </p><p><strong>杭州博克软件有限公司（外企实习）</strong>    2015.03 – 2016.01</p><p>任职于公司研发部门，设计实现内部提名系统，全程采用scrum敏捷开发方式和英文汇报交流工作，供内部人员使用。整套系统通过Html+Bootstrap+Jquery+AngularJS框架搭建前端页面，Mysql做数据存储。</p><h3 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h3><h4 id="订单交易模块"><a href="#订单交易模块" class="headerlink" title="订单交易模块"></a>订单交易模块</h4><p>功能： 新车交易采购和零售，为4s店和二网等B端提供订单交易Api服务，对接天猫券中心C端购买优惠券后线下进行核销，客户在天猫上签署合同支付尾款。                </p><p>技术： Dubbo 、Redis 、RocketMQ 、Spring 、Mysql         </p><p>简述： </p><ul><li><p>交易模块主要基于Mysql和Redis集群做数据存储，使用RocketMQ做消息队列，通过Dubbo微服务化， 基于ZK集群搭建高可用系统。                   </p></li><li><p>前期我们整个交易前台模块的设计面向过程编程，服务耦合性较高，后期对部分业务引入基于观察者模式的 Spring状态机和事件监听机制。                          </p></li><li><p>前期订单管理分页基于Sql优化分页查询，后期引入ESSearch。            </p></li></ul><h4 id="运营后台管理系统"><a href="#运营后台管理系统" class="headerlink" title="运营后台管理系统"></a>运营后台管理系统</h4><p>功能： 运营订单管理，订单搜索，详情页展示，报表导出，针对部门各个业务线。 </p><p>技术： React 、Ant Design、Webpack、 Dubbo 、 ESSearch、Mysql </p><p>简述：</p><ul><li><p>通过 React+Antd Design搭建订单管理、详情、审核以及导出页面。              </p></li><li><p>基于简单工厂和策略模式改善运营后台订单导出功能，便于扩展各个业务。                                              </p></li><li><p>前期基于Sql优化分页查询，后期引入ESSearch。 </p></li><li><p>链接： <a href="http://arthornye.github.io/2019/ShowPages/" target="_blank" rel="noopener">http://arthornye.github.io/2019/ShowPages/</a> </p></li></ul><h4 id="网关适配系统"><a href="#网关适配系统" class="headerlink" title="网关适配系统"></a>网关适配系统</h4><p>功能： 适配医院内部复杂系统，为客户端提供统一Api入口。</p><p>技术： WebService、SpringMVC、Mysql、Ibatis、Nginx </p><p>简述： </p><ul><li>系统主要部署在医院内部，Nginx做负载均衡，Mysql做数据存储，通过令牌进行高峰限流。           </li><li>后期通过简单工厂和策略模式针对不同的医院逻辑提供不同实现，支持WebService，Socket，存储过程等多种 适配方式。  </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本资料&quot;&gt;&lt;a href=&quot;#基本资料&quot; class=&quot;headerlink&quot; title=&quot;基本资料&quot;&gt;&lt;/a&gt;基本资料&lt;/h3&gt;&lt;p&gt;姓名 : 叶乔柱                                                      
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Show Pages</title>
    <link href="http://jianghao.wang/2019/%E5%89%8D%E7%AB%AF/ShowPages/"/>
    <id>http://jianghao.wang/2019/前端/ShowPages/</id>
    <published>2019-07-22T04:52:17.228Z</published>
    <updated>2019-07-22T08:13:39.022Z</updated>
    
    <content type="html"><![CDATA[<h3 id="订单详情"><a href="#订单详情" class="headerlink" title="订单详情"></a>订单详情</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="http://arthornye.github.io/images/detail.png" alt="cmd-markdown-logo"></h3><h3 id="订单列表"><a href="#订单列表" class="headerlink" title="订单列表"></a>订单列表</h3><p><img src="http://arthornye.github.io/images/manager.png" alt="cmd-markdown-logo"></p><h3 id="订单导出"><a href="#订单导出" class="headerlink" title="订单导出"></a>订单导出</h3><p><img src="http://arthornye.github.io/images/export.png" alt="cmd-markdown-logo"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;订单详情&quot;&gt;&lt;a href=&quot;#订单详情&quot; class=&quot;headerlink&quot; title=&quot;订单详情&quot;&gt;&lt;/a&gt;订单详情&lt;/h3&gt;&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;img src=&quot;h
      
    
    </summary>
    
    
      <category term="大搜车的点滴记录" scheme="http://jianghao.wang/tags/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%9A%84%E7%82%B9%E6%BB%B4%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>CopyOnWriteArrayList</title>
    <link href="http://jianghao.wang/2019/%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/CopyOnWriteArrayList%E4%BB%8B%E7%BB%8D/"/>
    <id>http://jianghao.wang/2019/并发学习/CopyOnWriteArrayList介绍/</id>
    <published>2019-07-01T07:56:26.260Z</published>
    <updated>2019-10-16T09:22:44.111Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要介绍juc内部针对数组提供的并发容器<strong>CopyOnWriteArrayList</strong>，主要的思想是针对增删改等修改操作都将原数组拷贝一份新数组，然后做完修改操作后，通过原子的方式写入到原数组的引用，通知到其他线程。</p><h3 id="CopyOnWriteArrayList实现"><a href="#CopyOnWriteArrayList实现" class="headerlink" title="CopyOnWriteArrayList实现"></a>CopyOnWriteArrayList实现</h3><p>设计一个线程安全的容器主要针对改（增删改）和查操作，<strong>CopyOnWriteArrayList</strong>对put操作通过RetrantLock加锁，将数组定义为volatile类型，再通过加锁完成新数组的生成之后，将新数组赋值给volatile数组，通知到其他线程。这里的lock同样我们可以用synchronized关键字或者cas来实现。put操作源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Object[] elements = getArray();</span><br><span class="line">           <span class="keyword">int</span> len = elements.length;</span><br><span class="line">           Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">           newElements[len] = e;</span><br><span class="line">           setArray(newElements);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="Iterating过程中不允许修改"><a href="#Iterating过程中不允许修改" class="headerlink" title="Iterating过程中不允许修改"></a>Iterating过程中不允许修改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.study.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayListTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] integers=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        DefinedCopyOnWirteArrayList list=<span class="keyword">new</span> DefinedCopyOnWirteArrayList(integers);</span><br><span class="line"></span><br><span class="line">        Iterator iterator=list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            <span class="comment">//不允许操作，抛出异常</span></span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器浅拷贝，不允许修改，只能查询而且是临时快照</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"remove"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过CAS改写CopyOnWriteArrayList"><a href="#通过CAS改写CopyOnWriteArrayList" class="headerlink" title="通过CAS改写CopyOnWriteArrayList"></a>通过CAS改写CopyOnWriteArrayList</h3><p>继承CopyOnWriteArrayList进行方法的重写，重新实现的add方法供参考：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.study.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义CopyOnWriteArrayList的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefinedCopyOnWirteArrayList</span> <span class="keyword">extends</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Integer[]&gt; atomicIntegers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefinedCopyOnWirteArrayList</span><span class="params">(Integer[] integers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.atomicIntegers = <span class="keyword">new</span> AtomicReference&lt;&gt;(integers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">(Integer index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;atomicIntegers.get().length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"数组越界"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> atomicIntegers.get()[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Integer insertData)</span></span>&#123;</span><br><span class="line">        <span class="comment">//step 1:拷贝一份数组</span></span><br><span class="line">        Integer[] integers=atomicIntegers.get();</span><br><span class="line">        <span class="keyword">int</span> length=integers.length;</span><br><span class="line">        Integer[] newIntegers=Arrays.copyOf(integers,length+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//step 2:将新值添加到新的数组中</span></span><br><span class="line">        newIntegers[length]=insertData;</span><br><span class="line">        <span class="comment">//step 3:采用cas替换引用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.atomicIntegers.compareAndSet(integers,newIntegers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CopyOnWriteArrayList设计-vs-RetrantWriteReadLock"><a href="#CopyOnWriteArrayList设计-vs-RetrantWriteReadLock" class="headerlink" title="CopyOnWriteArrayList设计 vs RetrantWriteReadLock"></a>CopyOnWriteArrayList设计 vs RetrantWriteReadLock</h3><p>对比一下<strong>CopyOnWriteArrayList设计</strong>和<strong>RetrantWriteReadLock</strong>的实现。</p><ul><li><strong>CopyOnWriteArrayList设计读不加锁，写加锁。RetrantWriteReadLock读和写都加锁。</strong></li><li><strong>CopyOnWriteArrayList设计针对读多写少场景表现优。RetrantWriteReadLock虽然针对读锁做了共享，读多写少依旧阻塞。</strong></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>感觉CopyOnWriteArrayList的设计还是蛮巧妙的，之前在了解读写锁的这种设计时还是蛮质疑这个设计的实际意义的。类比innodb的MDL表锁（如果一个写操作（修改表结构）获取到写锁前面有一个长事务获取读锁，那么所有的ddl操作（读锁）都有被阻塞），inndb因此设计了更小粒度的行锁。行锁同时设计了写锁，但是取消了读锁，用MVCC多版本并发控制取代，类比CopyOnWriteArrayList保留了写锁，通过线程通信的方式取消了读锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇主要介绍juc内部针对数组提供的并发容器&lt;strong&gt;CopyOnWriteArrayList&lt;/strong&gt;，主要的思想是针对增删改等修改操作都将原数组拷贝一份新数组，然后做完修改操作后，通过原子的方式写入到原数组的引用，通知到其他线程。&lt;/p&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
