<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TizzyT&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/9dde1b9d65b89035e235650923e5811e</icon>
  <subtitle>即使是拖后腿的，拼死努力的话，也是可以超越精英的。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jianghao.wang/"/>
  <updated>2019-01-03T14:10:24.218Z</updated>
  <id>http://jianghao.wang/</id>
  
  <author>
    <name>yeqiaozhu</name>
    <email>yqz_zjut@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql加锁分析实践</title>
    <link href="http://jianghao.wang/2019/mysql%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90%E5%AE%9E%E8%B7%B5/"/>
    <id>http://jianghao.wang/2019/mysql加锁分析实践/</id>
    <published>2019-01-02T01:58:10.893Z</published>
    <updated>2019-01-03T14:10:24.218Z</updated>
    
    <content type="html"><![CDATA[<p>实践基于以下表结构，分析各个情况下加锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tablet` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  `d` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into t values(0,0,0),(5,5,5),</span><br><span class="line">(10,10,10),(15,15,15),(20,20,20),(25,25,25);</span><br></pre></td></tr></table></figure><h4 id="唯一主键加锁"><a href="#唯一主键加锁" class="headerlink" title="唯一主键加锁"></a>唯一主键加锁</h4><p>先执行session1，query ok :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line"> /*主键等值查询gap锁 */</span><br><span class="line">begin;</span><br><span class="line">select * from tablet where id=10 lock in share mode;</span><br></pre></td></tr></table></figure><p>再执行session2，query ok:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">/*可以正常插入判定没有gap锁，针对唯一索引优化*/</span><br><span class="line">insert into tablet values(9,8,8);</span><br></pre></td></tr></table></figure><p>再执行session3，query blocked：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">update tablet set c=11 where id =10;</span><br></pre></td></tr></table></figure><blockquote><p><strong>唯一主键等值查询不加gap间隙锁，只加对应值的行锁。</strong></p></blockquote><p>这里将session1换成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line"> /*主键范围查询gap锁 */</span><br><span class="line">begin;</span><br><span class="line">select * from tablet where id&gt;=10 and id&lt;15 lock in share mode;</span><br></pre></td></tr></table></figure><p>session2，query ok：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">insert into tablet values(16,8,8);</span><br></pre></td></tr></table></figure><p>session3，query blocked：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">/*gap锁*/</span><br><span class="line">insert into tablet values(12,8,8);</span><br></pre></td></tr></table></figure><p>session4，query blocked：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">/*这里范围查询会多加一个行锁，实际上会感觉比较多余,因为并没有筛选到这个值,但是从逻辑上理解在索引上扫描一个范围并不知道什么时候结束，所以会有多出来的一个行锁，可能为了不违背两阶段锁的协议*/</span><br><span class="line">update tablet set c =0 where id=15;</span><br></pre></td></tr></table></figure><p>这里如果我们将session1中id&lt;15加上一个等号条件也就是id&lt;=15，mysql后在id=20这行也加上锁，同时多了一个gap锁也就是多了一整个<strong>next key lock (15,20]</strong>，这是相当奇怪的 ，因为扫描到15的时候可以确定不再往后进行扫描。这种貌似可以优化的场景但是并没有进行优化。</p><p><strong>最终上面的test发现会加id为10记录的行锁+(10,15]的next key lock。总结下，mysql在唯一主键索引查询的条件为范围索引的条件下会默认向后多加一个next key lock，等值查询直加行锁。</strong></p><blockquote><p><strong>lock in share mode 这种方式只会在索引上加锁，在不回表的情况下不会锁主键索引记录。for update 的方式不管是否回表都会锁主键记录。</strong></p></blockquote><h4 id="唯一普通索引加范围锁"><a href="#唯一普通索引加范围锁" class="headerlink" title="唯一普通索引加范围锁"></a>唯一普通索引加范围锁</h4><p>唯一普通索引有独立的树结构，在加锁上跟主键的索引是有区别的，防止根据主键更新造成不一致读会加行锁。</p><p>将c修改为唯一索引，执行下面的session1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line"></span><br><span class="line">alter table tablet drop index c;</span><br><span class="line">alter table tablet add unique index c(c);</span><br><span class="line">show index from tablet;</span><br><span class="line"></span><br><span class="line">begin;</span><br><span class="line">/* 普通唯一索引加范围锁 */</span><br><span class="line">select * from tablet where c &gt;10 and c &lt;=15 lock in share mode;</span><br><span class="line">/* == select d from tablet where c &gt;10 and c&lt;=15 for update; */</span><br></pre></td></tr></table></figure><p>然后执行session2，query blocked :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">-- 唯一普通索引c加锁范围(10,15],(15,20]，跟上面保持一致，需要多扫描一行数据并加锁（虽然感觉完全没有必要），主键索引加id=15行锁。</span><br><span class="line">-- query ok c=21</span><br><span class="line">insert into tablet values(16,21,8);</span><br><span class="line">-- query blocked c=16 gap间隙锁 </span><br><span class="line">insert into tablet values(19,16,8);</span><br><span class="line">-- blocked c=15 行锁</span><br><span class="line">update tablet set d=111 where c=15;</span><br><span class="line">-- query ok，没有加锁，回表的时候做了优化</span><br><span class="line">update tablet set d=111 where id=20;</span><br><span class="line">-- blocked 加了行锁</span><br><span class="line">update tablet set d=111 where id=15;</span><br></pre></td></tr></table></figure><blockquote><p><strong>唯一索引范围锁搜索到不符合预期范围的第一个值，以该值为最终值进行加锁，上面的语句如果改成c&lt;15那么锁范围变成(10,15]。</strong></p></blockquote><h4 id="非唯一普通索引加范围锁"><a href="#非唯一普通索引加范围锁" class="headerlink" title="非唯一普通索引加范围锁"></a>非唯一普通索引加范围锁</h4><p>类比上面的情况多了一个next key lock，执行session1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">begin;</span><br><span class="line">-- select * from  tablet where d&gt;10 and d&lt;=15 for update;</span><br><span class="line">/* 非唯一索引加范围锁 */</span><br><span class="line">select * from tablet where d &gt;10 and d &lt;=15 lock in share mode;</span><br></pre></td></tr></table></figure><p>执行session2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">-- 同样的情况变成了非唯一索引，加锁情况一致(10,15]，(15,20]（这里并没有多加个间隙锁，作了优化），主键索引加id=15行锁</span><br><span class="line">-- query ok d=8</span><br><span class="line">insert into tablet values(11,8,8)</span><br><span class="line">-- query ok d=23</span><br><span class="line">insert  into tablet values(13,7,23);</span><br><span class="line">-- blocked  d=20行锁</span><br><span class="line">update tablet set c=22 where d=20;</span><br><span class="line">-- query blocked  d=16间隙锁</span><br><span class="line">insert into tablet values(14,16,16);</span><br><span class="line">-- query ok </span><br><span class="line">update tablet set c =24 where id =20;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><blockquote><p><strong>非唯一索引范围锁搜索到不符合预期范围的第一个值，以该值为最终值进行加锁，上面的语句如果改成c&lt;15那么锁范围变成(10,15]。这里并不会在右边多加间隙锁。</strong></p></blockquote><p>#### </p><h4 id="非唯一普通索引加范围锁倒序"><a href="#非唯一普通索引加范围锁倒序" class="headerlink" title="非唯一普通索引加范围锁倒序"></a>非唯一普通索引加范围锁倒序</h4><p>倒序排序默认会从后往前扫描索引，mysql默认多加一个间隙锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- session1</span><br><span class="line">use souche_study;</span><br><span class="line">begin;</span><br><span class="line">-- 锁了(5,10],(10,15],(15,20],(20,25)</span><br><span class="line">select * from tablet where d&gt;=15 and d&lt;=20 order by d desc lock in share mode;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- session2</span><br><span class="line">use souche_study;</span><br><span class="line">-- query ok</span><br><span class="line">update tablet set c=14 where d =25;</span><br><span class="line">-- blocked</span><br><span class="line">insert into tablet values(17,17,6);</span><br><span class="line">-- query ok</span><br><span class="line">update tablet set c = 18 where d=5;</span><br><span class="line">-- blocked 唯一索引不存在(20,25)间隙锁</span><br><span class="line">insert into tablet values(16,16,21);</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总结一下，分析加锁情况主要需要区分出唯一索引和非唯一索引。唯一索引是左半区或者右半区可能插入，非唯一索引是左右半区都可能插入。并且有几个原则和几个优化，原则：</p><blockquote><p>1.加锁的基本单位是next key lock，前开后闭区间。</p><p>2.mysql扫描到的对象才会进行加锁。</p></blockquote><p>优化：</p><blockquote><p>1.索引的唯一等值查询，next key lock退化为行锁。（非唯一等值查询不退化）</p><p>2.等值查询或者范围查询向右遍历到最后一个不符合期望的值，即使是非唯一索引也不会在该值的右侧加一个间隙锁。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实践基于以下表结构，分析各个情况下加锁：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://jianghao.wang/2018/mysql%E6%9F%A5%E8%AF%A2%E6%A3%80%E7%B4%A2%E6%80%A7%E8%83%BD%E8%AF%AD%E5%8F%A5%E8%AE%B0%E5%BD%95/"/>
    <id>http://jianghao.wang/2018/mysql查询检索性能语句记录/</id>
    <published>2018-12-28T09:30:02.605Z</published>
    <updated>2019-01-04T05:03:27.432Z</updated>
    
    <content type="html"><![CDATA[<h4 id="查询长时间不返回"><a href="#查询长时间不返回" class="headerlink" title="查询长时间不返回"></a>查询长时间不返回</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.processlist;//这条语句跟下面的语句相同</span><br><span class="line">show processlist;//展示出当前的进程信息</span><br></pre></td></tr></table></figure><p>特殊的，在模拟一种MDL写锁阻塞的情况可以通过该命令查到阻塞的查询，这种情况一般第一时间执行该语句：</p><p>通过kill指令杀掉线程，恢复执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill 4;//kill pid,通过上面的命令查询到可以查询到对应线程的pid</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.innodb_locks;//可以查看死锁，注意锁等待信息不会在这里显示出来，除非发生死锁。包括gap锁和x锁可能导致的死锁等待，数据库开启了死锁等待机制可以检测死锁。</span><br></pre></td></tr></table></figure><h4 id="开启慢查询"><a href="#开启慢查询" class="headerlink" title="开启慢查询"></a>开启慢查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &quot;%query%&quot;</span><br></pre></td></tr></table></figure><p>result:</p><p><img src="https://arthornye.github.io/images/querylog.jpg" alt="cmd-markdown-logo"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 会在当前session立即生效</span><br><span class="line">set global slow_query_log=&apos;ON&apos;;</span><br><span class="line">-- 不会在当前的session生效，很坑，需要开启另一个session才会查询到设置效果</span><br><span class="line">set global long_query_time=0;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;查询长时间不返回&quot;&gt;&lt;a href=&quot;#查询长时间不返回&quot; class=&quot;headerlink&quot; title=&quot;查询长时间不返回&quot;&gt;&lt;/a&gt;查询长时间不返回&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://jianghao.wang/2018/React%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianghao.wang/2018/React学习/</id>
    <published>2018-12-17T11:01:38.088Z</published>
    <updated>2018-12-26T13:02:30.499Z</updated>
    
    <content type="html"><![CDATA[<h4 id="setState异步执行"><a href="#setState异步执行" class="headerlink" title="setState异步执行"></a>setState异步执行</h4><p>在实践的过程中发现一个奇怪的现象，我们如果先进行setState在进行网络请求，那么网络请求很可能提前进行，也就是setState是异步的，正确的同步写法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">onPageChange = (page) =&gt; &#123;</span><br><span class="line">       if(this.state.isSaleOrder)&#123;</span><br><span class="line">           this.setState(&#123;</span><br><span class="line">               sale_page:page,</span><br><span class="line">           &#125;,() =&gt;&#123;//这要采用回调的方式，更新完state再继续进行网络请求，不然会造成异常情况</span><br><span class="line">               this.getOrderManageList();</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           this.setState(&#123;</span><br><span class="line">               purchase_page:page,</span><br><span class="line">           &#125;,() =&gt;&#123;</span><br><span class="line">               this.getOrderManageList();</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;setState异步执行&quot;&gt;&lt;a href=&quot;#setState异步执行&quot; class=&quot;headerlink&quot; title=&quot;setState异步执行&quot;&gt;&lt;/a&gt;setState异步执行&lt;/h4&gt;&lt;p&gt;在实践的过程中发现一个奇怪的现象，我们如果先进行setSta
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://jianghao.wang/2018/mysql%E4%B8%AD%E7%9A%84%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://jianghao.wang/2018/mysql中的隐式类型转换/</id>
    <published>2018-12-04T04:52:03.232Z</published>
    <updated>2019-01-02T01:57:17.337Z</updated>
    
    <content type="html"><![CDATA[<h4 id="mysql中的隐式类型转换？"><a href="#mysql中的隐式类型转换？" class="headerlink" title="mysql中的隐式类型转换？"></a>mysql中的隐式类型转换？</h4><p>mysql innodb有行锁的实现，一般乐观锁的使用场景针对没有行锁的场景，行锁会针对当前读进行加排他锁。</p><p><strong>1.对索引字段做函数操作会导致索引失效，破坏索引的有序性，优化器不走b+树搜索</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from trade_log where month(t_modify)=7;</span><br></pre></td></tr></table></figure><p>上面的语句没办法使用到索引，不可以在索引的字段上加函数操作，这里复杂的函数操作导致了破坏索引的扫描，但是即使类似where id+1=1000这种操作优化器也并不会做优化操作，需要写成where id= 1000-1。</p><h4 id="隐式字符编码转换导致索引失效"><a href="#隐式字符编码转换导致索引失效" class="headerlink" title="隐式字符编码转换导致索引失效"></a>隐式字符编码转换导致索引失效</h4><p>在应用过程中通常会有字段字符集不统一的问题，如a表字段order_code为utf8mb4，关联 b表retail_order_code字段字符集为utf8。utf8mb4为utf8的超集合，也就是如果用a表取关联b表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from a,b where a.order_code=b.retail_order_code;</span><br></pre></td></tr></table></figure><p>实际上这句话在被连接的表上的逻辑==：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from b where convert(b.retail_order_code using utf8mb4) =a.value;</span><br></pre></td></tr></table></figure><p>所以隐式字符编码转换索引失效的条件：<strong>连接过程中被驱动的表的索引字段加函数操作。</strong></p><p>解决的方法：</p><p>1.改字符集，改成同样的字符集。</p><p>2.将驱动表的字符集用函数操作改为被驱动表的字符集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from a,b where convert(a.order_code using utf8) = b.retail_order_code;</span><br></pre></td></tr></table></figure><p>上面的语句在被连接表的逻辑变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from b where b.retail_order_code=a.value;//字符集一致，不需要做索引函数操作</span><br></pre></td></tr></table></figure><h4 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h4><p>在mysql的数据结构中，varchar和int的类型转换级别是不一样的，参考上面的分析方法，我们通过实践语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &quot;10&quot;&gt;9;//输出 1代表将字符串转成了数字</span><br></pre></td></tr></table></figure><p>那么我们可以得出结论，如果一个表a中有个varchar(32)的字段为索引字段order_code, 但是我们执行语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from a where order_code=1111;//会导致全表扫描。</span><br></pre></td></tr></table></figure><p><strong>便于理解，我们将其定义为一个父集一个子集，子集可以自动convert转换为父集。上面utf8为父集，utf8mb4为子集，int为子集，varchar为父集。如果父集为索引字段，子集为查询的字段，那么会出现索引失效。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;mysql中的隐式类型转换？&quot;&gt;&lt;a href=&quot;#mysql中的隐式类型转换？&quot; class=&quot;headerlink&quot; title=&quot;mysql中的隐式类型转换？&quot;&gt;&lt;/a&gt;mysql中的隐式类型转换？&lt;/h4&gt;&lt;p&gt;mysql innodb有行锁的实现，一般乐
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mysql索引介绍</title>
    <link href="http://jianghao.wang/2018/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/"/>
    <id>http://jianghao.wang/2018/mysql索引介绍/</id>
    <published>2018-11-24T07:16:28.373Z</published>
    <updated>2018-11-30T07:52:53.534Z</updated>
    
    <content type="html"><![CDATA[<h4 id="索引的几种数据模型"><a href="#索引的几种数据模型" class="headerlink" title="索引的几种数据模型"></a>索引的几种数据模型</h4><p>数据库引擎在设计索引结构的时候首先需要数据结构，怎样的数据结构能够兼容查询和更新，在不同的场景下选择也有所不同。下面主要介绍几种模型以及数据结构上的利弊。</p><h5 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h5><p>哈希索引数据模型类似HashMap，KV结构，通过数组+链表的方式去存储。<strong>利于等值查询（单值查询），不利于多值查询（范围查询），利于更新。</strong></p><p>应用：主要是应用在memcache，nosql等。主要为单值查询比较多的场景，更新性能也不差，不考虑IO。</p><h5 id="有序数组索引"><a href="#有序数组索引" class="headerlink" title="有序数组索引"></a>有序数组索引</h5><p>有序数组数据模型类比数组，有序的记录。<strong>利于查询（单值查询和多值查询表现都比较优秀），复杂度O(log n)，不利于更新（需要移动位置）。</strong></p><p>应用：有序数组索引只适用于静态存储引擎，比如你要保存的是某一年某个城市所有的人口信息。多为查询，更新比较少。</p><h5 id="N叉树索引"><a href="#N叉树索引" class="headerlink" title="N叉树索引"></a>N叉树索引</h5><p>N叉树索引数据模型，类比mysql中的B+TREE。<strong>利于IO，查询和更新的表现比较平衡。数据库数据存储在磁盘，多叉树可以减少大量IO。</strong></p><p>应用：mysql innodb采用的b+tree，相较于我们通常看到的平衡二叉树（查询O(log n)，更新O(log n)）兼容了磁盘IO，在大数据存储查询上更有优势。</p><h4 id="innodb的索引模型"><a href="#innodb的索引模型" class="headerlink" title="innodb的索引模型"></a>innodb的索引模型</h4><p>innodb采用b+tree维护每个索引，每个索引对应的都是一个b+tree多叉树的数据结构，其中mysql会为每个表默认生成一个字自增的primary key，作为表的唯一主键。那么我们将mysql的索引类型可以简单的分为主键索引的普通索引。</p><h5 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h5><p>mysql的主键索引我们又可以称之为聚簇索引，索引叶子结点记录了所有的字段信息。</p><p><img src="http://arthornye.github.io/images/mysql.png" alt="cmd-markdown-logo"></p><h5 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h5><p>普通索引只存储了索引的值+主键的值。普通索引查询之后，如果需要取出主键之外的信息，只要索引中不包含，就需要进行一个<strong>“回表”</strong>的操作。这里衍生出一种索引，叫做覆盖索引，意思是不需要回表，所查询的信息已经在普通索引中维护好了。例如我们上面建立的person表，card这个字段上是有一个普通索引的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from person where card=&apos;330...&apos;;//覆盖索引（不会进行回表）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from person where card=&apos;330...&apos;;//用不到覆盖索引（找到id后回表，在主键索引中再执行一次查询）</span><br></pre></td></tr></table></figure><h5 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h5><p>覆盖索引，上面的表中，我们如果根据单个字段的值建立索引，在根据索引遍历到记录之后需要进行回表操作。那么如果我们加索引index（name,card），数据在根据身份证去找名字的时候的查询语句就不需要回表，这个就叫<strong>覆盖索引</strong>。</p><p>可以看到覆盖索引其实也就是在我们通常称为<strong>联合索引</strong>的基础之上的。联合索引会导致一些失效的情况：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;索引的几种数据模型&quot;&gt;&lt;a href=&quot;#索引的几种数据模型&quot; class=&quot;headerlink&quot; title=&quot;索引的几种数据模型&quot;&gt;&lt;/a&gt;索引的几种数据模型&lt;/h4&gt;&lt;p&gt;数据库引擎在设计索引结构的时候首先需要数据结构，怎样的数据结构能够兼容查询和更新，在
      
    
    </summary>
    
    
      <category term="-mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql innodb日志模块介绍</title>
    <link href="http://jianghao.wang/2018/mysql%20innodb%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/"/>
    <id>http://jianghao.wang/2018/mysql innodb日志模块介绍/</id>
    <published>2018-11-17T14:45:21.552Z</published>
    <updated>2018-11-18T02:52:35.993Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍一下mysql的日志系统。我们都知道在数据库的生产环境上，可能会发生一些事故。例如之前有个同事在执行数据订正的时候，不小心将很多的订单数据中的凭证数据覆盖成了空。这样的操作第一时间肯定是想通过数据库备份的形式将数据恢复出来，这个时候你的DBA可能会告诉你，有一周的数据的备份。不幸的是，这个事故发生的情况并没有在一星期之内定位到原因。所幸，有一份较久的备份，DBA可以根据这个备份恢复到丢失前的那个节点。那么这里就需要提到mysql的日志系统是如何实现的，只介绍一下概念，具体的实践由伟大的DBA完成。</p><h4 id="mysql的日志模块以及如何保证一致性"><a href="#mysql的日志模块以及如何保证一致性" class="headerlink" title="mysql的日志模块以及如何保证一致性"></a>mysql的日志模块以及如何保证一致性</h4><p>mysql的日志主要分为物理日志redo log（重做日志）和bin log（归档日志）。这两种日志都是只针对更新操作进行记录，针对查询的记录不会记录到mysql的日志模块。更新语句执行的主要流程：</p><p><img src="http://arthornye.github.io/images/twostep.png" alt="cmd-markdown-logo"></p><h5 id="redo-log（重做日志）"><a href="#redo-log（重做日志）" class="headerlink" title="redo log（重做日志）"></a>redo log（重做日志）</h5><p>这个是只针对数据库引擎innodb才有的日志模块。我们可以类比我们在记账的时候，我们有一个账本，记录了每个顾客的账户余额记录，但是如果人特别多的时候我们很难找到每个顾客的记录然后做个更新操作（这里一次查询io一次更新io），最好的办法是将这次的消费记录更新计算的结果记录到一个“白板”上面，等到空闲的时候再去写账本（sync同步到数据库磁盘）。这个“白板”的功能就是redo log。当然这个“白板”也会有写完的时候，实际情况下redo log文件是存在物理文件中的，假设我们有四个redo log文件总共大小为4g，那么每个文件的容量为1g。</p><p><img src="http://arthornye.github.io/images/pointmove.png" alt="cmd-markdown-logo"></p><p>粉板和账本配合的整个过程，其实就是 MySQL 里经常说到WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。</p><h5 id="bin-log（归档日志）"><a href="#bin-log（归档日志）" class="headerlink" title="bin log（归档日志）"></a>bin log（归档日志）</h5><p>可以简单理解为是记录了又一句的更新sql语句，当你需要进行恢复的时候可以先将表恢复到某个历史时间点，然后通过bin log中的记录一个个去执行到丢失数据前的时间点。那么这两种日志有什么不同，为什么要做区分？</p><p><strong>1.redo log是物理日志，记录了在某行做了修改的结果（修改后的记录）。而bin log是逻辑日志，记录了在某行做了什么操作（执行修改的操作）。</strong></p><p><strong>2.redo log是InnoDB 引擎特有的，而bin log是基于mysql的server引擎的，所有的引擎都有选择启用或者关闭这个日志功能。</strong></p><p><strong>3.redo log是循环写的，如果point重合的话是会强制sync到磁盘的，但是bin log是会一直往下写的。</strong></p><h5 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h5><p>介绍了两种日志模块的功能，我们再来分析开头为什么要做两阶段提交。我们在系统交互的过程中有没有碰到一种情况就是两个任务需要同时完成才算是完成，如果由于异常失败了其中一个，那么整个过程是不成功的，这里我们通常会用一个中间状态来控制整个事务。也就是两阶段提交日志的概念，将写bin log和redo log整个当成一个事务去处理。</p><p><strong>redo log更新成功，binlog更新的时候mysql重启，重启机制检测到之后回滚该事务。redo log更新和bin log更新都成功，提交的时候mysql重启，重启之后检测到该事务已经完成自动提交。那么两个日志模块的数据是始终一致的。</strong></p><p>如果不进行两阶段提交，数据库在异常重启之后恢复的正是库可能和通过bin log恢复的备份数据是不一致的。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>主要介绍了mysql innodb在更新操作的时候是如果记录日志，防止突然的重启以及后续的数据备份恢复。即时突然重启，redo log也记录了原始的物理修改信息。当然如果想要恢复到历史的某一个点，也可以通过bin log的形式在历史某一个版本的数据上进行迭代执行。两个日志模块通过了中间状态进行两阶段提交，同时也保证了数据的一致性（这里如果是分各自提交会有问题，数据不一致）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单介绍一下mysql的日志系统。我们都知道在数据库的生产环境上，可能会发生一些事故。例如之前有个同事在执行数据订正的时候，不小心将很多的订单数据中的凭证数据覆盖成了空。这样的操作第一时间肯定是想通过数据库备份的形式将数据恢复出来，这个时候你的DBA可能会告诉你，有一周的数
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql加锁处理分析</title>
    <link href="http://jianghao.wang/2018/mysql%E5%8A%A0%E9%94%81%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://jianghao.wang/2018/mysql加锁处理分析/</id>
    <published>2018-11-12T06:07:22.527Z</published>
    <updated>2018-12-29T10:02:23.466Z</updated>
    
    <content type="html"><![CDATA[<p>之前的一篇文章介绍了mysql的四种隔离级别，本篇主要介绍一下mysql是如何进行加锁处理的。主要想了解mysql在处理高并发情况下的读写以及可能遇到的并发问题之间是如何去兼容的。我们都知道加锁是比较资源的操作，但是不加锁也会面临一些并发的问题，本篇文章将基于四种隔离级别去介绍mysql是如何进行加锁的处理的。</p><h4 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h4><p>我们需要先了解一下当前读和快照读的区别，实际上在mysql中是区分这两种读的，看两个sql语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from test_test where ? for update;//这一整个事务是一个当前读（实际上是一个写操作）</span><br><span class="line">select * from test_test where ?;//这个事务是一个快照读（实际上只是一个从数据库获取数据的操作）</span><br></pre></td></tr></table></figure><p><strong>当前读：delete，insert，update操作都可以视为当前读，从语义上可以理解为select for udpate，都是先读再写，需要保证并发的读写数据一致性。</strong></p><p><strong>快照读：单纯的select操作，数据库读取操作，不同的数据库隔离级别可能面临重复读的不一致问题和幻读问题。</strong></p><p>在mysql中，针对快照读只有在最高的隔离级别serializable级别下才会对快照读进行加锁，其他的级别下都是不加锁的。针对当前读，mysql在各个级别下为了防止并发的数据不一致问题都会进行加锁，加排他锁，也可以理解为写锁。</p><h4 id="各种隔离级别下的加锁机制"><a href="#各种隔离级别下的加锁机制" class="headerlink" title="各种隔离级别下的加锁机制"></a>各种隔离级别下的加锁机制</h4><p>我们探讨一下RC隔离级别下的几种索引遍历加锁处理的情况：</p><h5 id="RC-UUK（不可重复读-非唯一索引）"><a href="#RC-UUK（不可重复读-非唯一索引）" class="headerlink" title="RC+UUK（不可重复读+非唯一索引）"></a>RC+UUK（不可重复读+非唯一索引）</h5><p>我们将mysql的隔离级别调整为RC，建立一个test_test表，其中id是primary key，code是unique key。分别执行下面的sql：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=5 for update;</span><br><span class="line">//先在session1中执行该sql1</span><br><span class="line">id  name code</span><br><span class="line">13yqz   5</span><br><span class="line">14yqz   5</span><br><span class="line"></span><br><span class="line">update test_test set test_test.name=&apos;pyx&apos; where code =5;</span><br><span class="line">//然后在session2中执行该sql2</span><br><span class="line"></span><br><span class="line">执行结果，sql2获取锁超时。</span><br></pre></td></tr></table></figure><p>结论：RC隔离级别下对快照读不加锁，会存在重复读的数据不一致问题+幻读问题。对当前读，RC隔离级别会加锁，其他事务不允许修改已经被当前读锁定的修改记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=5 for update;</span><br><span class="line">//先在session1中执行该sql1</span><br><span class="line">id  name code</span><br><span class="line">13yqz   5</span><br><span class="line">14yqz   5</span><br><span class="line"></span><br><span class="line">insert into test_test values(20,&apos;yqz&apos;,7);//session2可以正常插入</span><br><span class="line">insert into test_test values(20,&apos;yqz&apos;,5);//session2不能插入，锁竞争</span><br><span class="line">update test_test set code=1 where id=13;//session2不能插入，锁竞争</span><br></pre></td></tr></table></figure><p>做了个图，分析下这里的加锁：</p><p>​    <img src="http://arthornye.github.io/images/lock.png" alt="cmd-markdown-logo"></p><p>结论：RC隔离级别对当前读会加锁，也会加GAP间隙锁防止两次当前读之间发生后幻读。但是两次快照读之前还是不能防止幻读的（这个在mysql事务和事务隔离机制文章中可以看到相关的介绍）。</p><p>分析，insert into test_test values(20,’yqz’,5)语句碰到了GAP间隙锁导致了锁竞争，update test_test set code=1 where id=13语句碰到了主键的记录导致了锁竞争。这也是为什么在根据un unique key遍历的时候我们要加两次锁的原因，因为可能有别的sql udpate是根据primary key来进行的。这里不熟悉mysql的索引的朋友们可以了解下mysql的索引结构，primary key对应的是聚族索引（innodb数据库引擎），基于B+TREE结构，在每个叶子结点都保存了完整的信息。但是建立的所有unuque key只保存了索引相关的信息，我们可以根据un unique key建立的B+TREE去遍历到primary key，再根据这个primary key去遍历主键索引。</p><h5 id="RC-UK（不可重复读-唯一索引）"><a href="#RC-UK（不可重复读-唯一索引）" class="headerlink" title="RC+UK（不可重复读+唯一索引）"></a>RC+UK（不可重复读+唯一索引）</h5><p>基于上面的分析，我们可以类比得到，这种情况下当前读也会在unique key对应的结果加排他锁，同时也加两个间隙锁。在对应的主键记录的叶子节点位置加排他锁，不存在幻读问题。但是针对快照读在RC隔离级别下还是会存在不可重复读+幻读问题。</p><h5 id="RR-UK（可重复读-唯一索引）"><a href="#RR-UK（可重复读-唯一索引）" class="headerlink" title="RR+UK（可重复读+唯一索引）"></a>RR+UK（可重复读+唯一索引）</h5><p>类比RC+UK，在当前读上的加锁处理没有什么区别，都不会存在重复读的问题和幻读问题。但是在快照读上，RR是通过了事务版本号和数据库记录版本号来限制了重复读不一致的问题的，也是旧版本的事务永远读不到新版本的事务提交的更改，删除以及新增记录。有的博客在介绍的时候会说是GAP间隙锁防止了幻读的发生，这个也有一定的道理，但是这个是针对当前读的，并不是针对快照读，快照读除非在串行的前提下才加锁，其他的情况都不加锁。</p><h5 id="RC-RR-NK（不可重复读-可重复读-无索引）"><a href="#RC-RR-NK（不可重复读-可重复读-无索引）" class="headerlink" title="RC/RR+NK（不可重复读/可重复读 +无索引）"></a>RC/RR+NK（不可重复读/可重复读 +无索引）</h5><p>无索引会直接根据主键进行全表扫描，同时会将整个表锁住，这种情况是及其低效的。</p><h4 id="分析一条复杂sql加锁"><a href="#分析一条复杂sql加锁" class="headerlink" title="分析一条复杂sql加锁"></a>分析一条复杂sql加锁</h4><p>通过上面的学习，我们尝试去分析一条sql的加锁情况：</p><p><img src="http://arthornye.github.io/images/sqllock.png" alt="cmd-markdown-logo"></p><p><strong><em>tips:这里有一种场景，mysql innodb默认会在这种查询的时候正向加锁（next-key lock===gap锁+右边的行锁），如果是倒序排序的话，会在倒序的末尾再加一个点。这是比较诡异的地方。</em></strong></p><h4 id="mysql死锁的发生"><a href="#mysql死锁的发生" class="headerlink" title="mysql死锁的发生"></a>mysql死锁的发生</h4><p>在mysql中也会发生一些死锁的情况，我们熟知发生死锁的条件能够帮助我们避免写出死锁。下面几种情况会发生死锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">session1</span><br><span class="line">select * from test_test where code=5 for udpate;</span><br><span class="line">select * from test_test where id=1 for update;</span><br><span class="line"></span><br><span class="line">session2</span><br><span class="line">select * from test_test where id=1 for update;</span><br><span class="line">select * from test_test where code=5 for udpate;</span><br><span class="line">//这种是比较简单的情况，循环加锁导致死锁</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">session1</span><br><span class="line">select * from test_test where code=5 for udpate;</span><br><span class="line">id  name code</span><br><span class="line">13yqz   5</span><br><span class="line">select * from test_test where code=4 for udpate;</span><br><span class="line">id  name code</span><br><span class="line">12yqz   4</span><br><span class="line"></span><br><span class="line">session2</span><br><span class="line">select * from test_test where id=12 for udpate;</span><br><span class="line">select * from test_test where id=13 for udpate;</span><br><span class="line"></span><br><span class="line">//这里虽然不是直接的进行了循环加锁，但是由于在聚簇索引的节点处也加了锁，实际上是有一个加锁的闭环的。我们通过mysql的加锁处理分析可以更准确的得到加锁信息，从而分析出死锁</span><br></pre></td></tr></table></figure><h4 id="MDL表级锁"><a href="#MDL表级锁" class="headerlink" title="MDL表级锁"></a>MDL表级锁</h4><p>mysql事务在执行的过程中，对表级别的操作分为两部分：表数据的增删改查，以及表结构的增删改查。表数据的增删改查需要获取MDL读锁，表结构的增删改查需要获取MDL写锁。MDL表级锁具备如下特性：</p><p><strong>1.MDL读锁是共享锁，不同事务不阻塞。</strong></p><p><strong>2.MDL写锁是独占锁，会阻塞在读锁和写锁上。</strong></p><p>表级锁在实际操作过程中，可能因为不恰当的操作导致业务发生异常，这里给个实例，下面三个事务依次执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">session a:</span><br><span class="line">begin;</span><br><span class="line">select * from test_test where code=2;//事务a获取到mdl表级锁的读锁</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session b:</span><br><span class="line">alter table add column city varchar(16);//事务b获取mdl写锁被block</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session c:</span><br><span class="line">select * from test_test where code=1;//事务c获取mdl读锁被block</span><br></pre></td></tr></table></figure><p>这里我们看到读锁和读锁之间虽然是共享锁，但是如果中间穿插了一个写锁的block，还是会有序被block住的。这里我们如果将事务a提交，mysql会依次执行b，c。所以我们在实际 操作过程中如果要对线上的数据的表进行变更，需要保证没有长事务，如果当前正有个长事务在对表数据进行操作，那么执行表结构变更的写操作会被block导致其他的读操作也被block。可以考虑在执行表结构变更的时候：</p><ul><li>查看执行中是否有长事务，kill长事务</li><li>alter等修改操作设置等待时间（需要引擎支持）</li></ul><h4 id="mysql行锁"><a href="#mysql行锁" class="headerlink" title="mysql行锁"></a>mysql行锁</h4><p>mysql中仅innodb支持行锁，其他引擎不支持行锁。我们通过一个实例来进行介绍mysql的行锁。假如A在B影院买了一张电影票，C也在B影院买了一张电影票。那么这两个事务都需要对客户账户余额做-操作，同时对影院的余额也做+操作。先介绍一些主要的概念再进行展开。</p><ul><li><strong>减少客户的账户余额</strong></li><li><strong>增加商家的账户余额</strong></li><li><strong>增加一条交易记录</strong></li></ul><p>上面的整个过程需要保证原子性。我们通常称之为一个事务，要么全部成功要么全部失败。</p><p><strong>两阶段锁协议</strong>：innodb中的行锁是需要的时候会进行加锁，但是并不是不需要的时候就会释放锁，需要事务提交之后才会释放锁。</p><p><strong>死锁：</strong>行锁发生了循环引用导致发生死锁，线程在锁上持续等待。</p><p><strong>如何解决死锁：</strong>代码中避免循环引用；可以通过设置超时时间和开启数据库死锁检测防止死锁。设置超时时间可能导致部分正常业务也就是没有发生死锁的事务被回滚，对业务是有损的；开启数据库死锁检测对业务是无损的，但是死锁的检测机制会占用大量的cpu。</p><p><strong>热点更新：</strong>这里我们讨论的热点更新，可以假设在上面的事务过程中，出现了双11类似的疯狂买票操作。那么这个场景下对商家余额的记录的写操作是非常频繁的。如果开始了死锁检测，那么等待的线程假设是1000个，那么这些线程会不断去检测死锁也就是1000*1000的复杂度，这个占用大量的cpu。</p><p><strong>如何解决热点更新：</strong> 在并发量比较大的情况下，我们可以通过增加热点更新记录的条数来减少锁的竞争。例如我们可以维护十条B账户余额的记录，在更新的时候随机取其中的某一条去更新，之后将所有的余额数据进行累加。这样的设计也是可以直接减少锁的竞争提高并发量。但是这样的设计需要考虑逆向操作，也就是如果发生退款操作导致其中的某条记录变成了0，代码需要特殊处理。</p><p><strong>并发量如何提高：</strong>尽量将一个事务中可能发生锁竞争的语句往后靠，前面的事务过程中增加商家的余额，这种热点更新其实可以放在后面，减少占有锁之后的锁持有时间。</p><p><strong>死锁检测：</strong>这里需要注意的是死锁检测是当前线程在发现锁阻塞之后就回去扫描别的线程，所以在并发量非常高的时候这个检测影响的性能也就更加明显。通常在秒杀的场景下，单个热点更新会导致不停的进行死锁检测，极大的降低了性能。 </p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本篇主要分析了mysql是如何进行加锁的处理的。mysql在RR隔离级别及以下对快照读是比较友好的，不会加锁，这样也极大地提高了数据库处理并发的能力。但是针对快照读RC隔离级别下还是不能防止幻读，也不能重复读。值得注意的是，mysql在RR,RC的隔离级别下都是有对当前读防止幻读的，通过加排他锁和间隙锁的共同使用。针对RR隔离级别的快照读，通过加版本号达到可重复读和防止幻读的目的。通过总结希望从sql语句，结合隔离级别以及索引判断出在执行过程中可能发生的加锁和锁竞争。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前的一篇文章介绍了mysql的四种隔离级别，本篇主要介绍一下mysql是如何进行加锁处理的。主要想了解mysql在处理高并发情况下的读写以及可能遇到的并发问题之间是如何去兼容的。我们都知道加锁是比较资源的操作，但是不加锁也会面临一些并发的问题，本篇文章将基于四种隔离级别去
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql事务和事务隔离机制</title>
    <link href="http://jianghao.wang/2018/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6/"/>
    <id>http://jianghao.wang/2018/mysql事务和事务隔离机制/</id>
    <published>2018-11-07T09:36:02.887Z</published>
    <updated>2018-11-21T02:06:56.503Z</updated>
    
    <content type="html"><![CDATA[<p>在学习mysql的事务隔离机制的过程中，对mysql的会话和事务的概念有点模糊不清，这里主要通过mysql可视化工具sequel pro来记录在实践过程中遇到的问题以及思考。</p><h4 id="mysql会话begin自动提交事务"><a href="#mysql会话begin自动提交事务" class="headerlink" title="mysql会话begin自动提交事务"></a>mysql会话begin自动提交事务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">update retail_order set order_status=111 where order_code=&apos;899120869590&apos;;</span><br></pre></td></tr></table></figure><p>我们建立一个mysql连接，然后开启一个会话session1，执行上面的sql。这条sql会在行记录上加锁。但是当前的事务是没有提交的，mysql的默认事务隔离机制是RR（可重复读）。我们在另一个会话session2中执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">update retail_order set order_status=111 where order_code=&apos;899120869590&apos;;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>会话2会报超时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure><p>通过这种方式我们成功验证了session1的事务还在执行中，数据库的记录已经上锁。</p><p>那么我们再去验证，当前会话的某个事务还在执行中，当前会话是不是可以继续执行其他事务，执行下面的select</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select order_status from retail_order where order_code=&apos;899120869590&apos;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">111</span><br></pre></td></tr></table></figure><p>实际上这个事务没有被提交上去，但是在本会话中再提交select却可以读取到这个值。这里其实我们应该将其理解为实际上本事务并没有提交，数据库会检测是同一个会话提交的sql，将其整合为一个未提交的事务。所以这里的变更对其他会话的事务依旧是不可见的。</p><p>那么什么时候这个事务什么时候会被提交？我们可以联想到是不是在执行一个commit本会话的事务便会被提交，对其他的会话可见。我们在session1单独执行一句commit，在session2中执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select order_status from retail_order where order_code=&apos;899120869590&apos;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">111</span><br></pre></td></tr></table></figure><p>可见我们的事务已经被提交了，同样的，我们发现在session1中执行一句begin，看session2同样查询的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">111</span><br></pre></td></tr></table></figure><p>做个总结：</p><p><code>当我们忘了对一个事务进行提交的时候，该会话接下来执行的事务也会叠加，直到我们显示的去进去提交或者开启一个新的事务。一个会话的事务没有提交可能导致另一个会话获取不到锁。</code></p><h4 id="mysql事务隔离机制"><a href="#mysql事务隔离机制" class="headerlink" title="mysql事务隔离机制"></a>mysql事务隔离机制</h4><p>熟悉了我们的可视化工具，我们尝试分析mysql的事务隔离机制，相信对mysql有基本了解的都知道，mysql的四种隔离机制。这四种隔离机制是我们分析数据库锁机制的基本，我也将会在本篇介绍隔离机制之后介绍一下mysql的锁机制。接下来的介绍需要我们去改变mysql的事务隔离机制，我们可以通过语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@global.tx_isolation,@@tx_isolation;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPEATABLE-READREPEATABLE-READ</span><br></pre></td></tr></table></figure><p>mysql的默认隔离机制RR,前一个是全局session的隔离级别，后一个是当前会话的隔离级别，我们可以在当前会话中设置隔离级别，通过sql语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level read committed; </span><br><span class="line">set session transaction isolation level repeatable read;</span><br></pre></td></tr></table></figure><h5 id="Read-Uncommited"><a href="#Read-Uncommited" class="headerlink" title="Read Uncommited"></a>Read Uncommited</h5><p>这个基本不用考虑，因为如果事务没有被提交就被其他的事务看到这样的设计从逻辑上来看是不合理的，会造成大量的脏读。</p><h5 id="Read-Commited-不可重复读"><a href="#Read-Commited-不可重复读" class="headerlink" title="Read Commited(不可重复读)"></a>Read Commited(不可重复读)</h5><p>在这个隔离机制下，事务在提交之后对另一个事务可见。如果在一个事务A的执行过程中进行了两次查询，事务B在查询间隙进行了数据更新，这个隔离级别会存在脏读+幻读的可能。我们新建一个test_test表，开启session1，执行事务A，不提交，模拟不可重复读：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1wmm1</span><br><span class="line">2wmm1</span><br><span class="line">3wmm1</span><br><span class="line">4wmm1</span><br><span class="line">5wmm1</span><br></pre></td></tr></table></figure><p>开启session2，执行事务B，直接提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update test_test set name=&apos;wmm&apos; where code=1;</span><br></pre></td></tr></table></figure><p>回到session1，执行查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br></pre></td></tr></table></figure><p>RC隔离级别下不可重复读，两次读的结果不一致。</p><p>用同样的方式，测试该隔离模式下会不会存在幻读：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert test_test values(6,&apos;yqz&apos;,1);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6yqz1</span><br></pre></td></tr></table></figure><p>该模式下存在幻读（如果没有显式begin开始一个事务，事务都默认自动提交，部分语句没有加begin，commit，自动提交）。</p><h4 id="Repeatable-Read-可重复读"><a href="#Repeatable-Read-可重复读" class="headerlink" title="Repeatable Read(可重复读)"></a>Repeatable Read(可重复读)</h4><p>首先通过恢复到该数据库隔离级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level repeatable read;</span><br></pre></td></tr></table></figure><p>模拟是否存在脏读，session1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6yqz1</span><br></pre></td></tr></table></figure><p>session2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update test_test set name=&apos;pyx&apos; where code=1;</span><br></pre></td></tr></table></figure><p>session1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6yqz1</span><br></pre></td></tr></table></figure><p>RR隔离模式下不存在脏读，那么mysql是如何实现该隔离模式下的避免脏读？了解过juc的cas的都知道我们可以通过在共享内存标记一个版本号，来防止aba问题。那么类比mysql也是通过在每行的记录后面添加一列标记版本号，读的时候不会修改这个版本号，但是更新删除都会版本号+1。参考上面的例子，session1在执行事务A的时候，假设当前事务的版本号为1，当前事务并没有提交，然后session2执行了更新事务B，提交之后数据库该行记录的版本号变成了2。在该隔离模式下事务A只会读取到版本号不大于当前事务版本号的记录，也就是说，虽然这条记录的更改已经在数据库真实存在，但是事务A并不能读取到这条记录的变更。</p><ul><li>SELECT时，读取创建版本号&lt;=当前事务版本号，删除版本号为空或&gt;当前事务版本号。</li><li>INSERT时，保存当前事务版本号为行的创建版本号。</li><li>DELETE时，保存当前事务版本号为行的删除版本号。</li><li>UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行。</li></ul><p><strong>2018.11.20增加对MVCC多版本并发控制的理解：</strong>如果我们数据库中某一条记录的值经历的版本变化为4-&gt;3-&gt;2-&gt;1，那么数据库引擎同时会记录一个回滚日志，根据对应事务的版本号去回滚到事务对应的值。</p><p><img src="http://arthornye.github.io/images/mvcc.png" alt="cmd-markdown-logo"></p><p>同样的方式看该该隔离级别下是否存在幻读，session1，事务A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6pyx1</span><br></pre></td></tr></table></figure><p>session2，事务B：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert test_test values(7,&apos;yqz&apos;,1);</span><br></pre></td></tr></table></figure><p>session1，事务A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6pyx1</span><br></pre></td></tr></table></figure><p>session1，事务A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit;</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6pyx1</span><br><span class="line">7yqz1</span><br></pre></td></tr></table></figure><p>可以看到这里是不存在幻读的，很多博客在介绍mysql的四种隔离级别的时候会说RR隔离模式下可以避免脏读但是不能避免幻读，我们通过实践看到这个级别是可以避免幻读的。</p><h4 id="Serializable-串行化"><a href="#Serializable-串行化" class="headerlink" title="Serializable(串行化)"></a>Serializable(串行化)</h4><p>这个隔离级别，个人的理解可以类比RetrantWriteReadLock的设计。事务在执行的时候如果数据行存在写锁（排他锁），读锁是共享锁，这种情况下会等待写锁释放。同样的如果是事务尝试去获取某个数据行的写锁，发现共享锁的读锁没有完全释放开，也需要等待读锁全部释放完才可以获取到写锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level serializable;</span><br></pre></td></tr></table></figure><p>将数据库隔离级别调整为串行，然后分别执行事务，session1，事务A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6pyx1</span><br><span class="line">7yqz1</span><br><span class="line">8yqz1</span><br></pre></td></tr></table></figure><p>session2，事务B：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update test_test set name=&apos;pyx&apos; where id=1</span><br></pre></td></tr></table></figure><p>执行结果，事务B，获取锁超时，Lock wait timeout exceeded; try restarting transaction。通过下面的语句也可以查看到当前存在锁竞争。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.innodb_locks</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5930258879:6688936:3:35930258879XRECORD`souche_retail`.`test_test`PRIMARY668893633NULL</span><br><span class="line">5930501833:6688936:3:35930501833SRECORD`souche_retail`.`test_test`PRIMARY668893633NULL</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本篇主要介绍了mysql的四种事务隔离级别，这里终结下它们的特点：</p><table><br><tr><br>    <th>Read Uncommited</th><br>    <th>不可重复读</th><br>    <th>幻读</th><br></tr><br><tr><br>    <th>Read Commited </th><br>    <th>不可重复读</th><br>    <th>幻读</th><br></tr><br><tr><br>    <th>Repeatable Read</th><br>    <th>可重复读</th><br>    <th>不存在幻读</th><br></tr><br><tr><br>    <th>Serializable</th><br>    <th>不可重复读</th><br>    <th>不存在幻读</th><br></tr><br></table><p>接下来的博客将会主要介绍mysql在这几种隔离机制下是如何加锁保持高并发情况下的数据一致性的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习mysql的事务隔离机制的过程中，对mysql的会话和事务的概念有点模糊不清，这里主要通过mysql可视化工具sequel pro来记录在实践过程中遇到的问题以及思考。&lt;/p&gt;
&lt;h4 id=&quot;mysql会话begin自动提交事务&quot;&gt;&lt;a href=&quot;#mysql会话
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Semaphore控制并发的信号量</title>
    <link href="http://jianghao.wang/2018/Semaphore%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <id>http://jianghao.wang/2018/Semaphore控制并发的信号量/</id>
    <published>2018-11-05T02:07:12.193Z</published>
    <updated>2018-11-07T03:10:35.130Z</updated>
    
    <content type="html"><![CDATA[<p>在面试的时候被问到关于java信号量，并没有很了解这个并发同步器，这里学习之后做一点简单的记录。Semaphore我们通常称之为信号量，这是用来控制同时访问某个资源的线程数量的一个同步器。比如数据库连接，如果数据库连接的数量只有10个，但是此时在执行的线程数量大于10个，那么线程会报错，获取不到数据库连接。为了防止这样的情况，我们可以通过信号量Semaphore来进行流量的控制。</p><h4 id="使用Semaphore控制并发流量"><a href="#使用Semaphore控制并发流量" class="headerlink" title="使用Semaphore控制并发流量"></a>使用Semaphore控制并发流量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 10/25/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个线程池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService threadPoolExecutor= Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="comment">//这里用信号量尝试控制流量</span></span><br><span class="line">            Semaphore semaphore =<span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//public static volatile int count=0;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++)&#123;</span><br><span class="line">            threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        semaphore.acquire();</span><br><span class="line">                        <span class="comment">//模拟获取数据库连接</span></span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">"   get database link : "</span>);</span><br><span class="line">                        semaphore.release();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Semaphore-API介绍"><a href="#Semaphore-API介绍" class="headerlink" title="Semaphore API介绍"></a>Semaphore API介绍</h4><p>Semaphore对每一个进入获取令牌的线程，都会尝试给予令牌，但是如果出现了供不应求的情况，每个线程需要的处理方式可能是不同的：</p><h5 id="semaphore-acquire"><a href="#semaphore-acquire" class="headerlink" title="semaphore.acquire()"></a>semaphore.acquire()</h5><p><strong>线程选择直接获取（非阻塞），进入等待队列，循环等待没获取到线程挂起</strong>。</p><p>通过源码分析在底层的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">               <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                   <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                   <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                       setHeadAndPropagate(node, r);</span><br><span class="line">                       p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                       failed = <span class="keyword">false</span>;</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<span class="comment">//公平加入等待队列，如果没获取到直接触发中断，直接抛出中断异常</span></span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>##### </p><h5 id="semaphore-tryAcquire"><a href="#semaphore-tryAcquire" class="headerlink" title="semaphore.tryAcquire()"></a>semaphore.tryAcquire()</h5><p><strong>线程可以选择等待一段时间（非阻塞），如果超时获取不到返回false，检测到中断信号线程中断</strong>。</p><p>贴上源码的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">               <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//如果超时了返回获取锁失败</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())<span class="comment">//将中断信号标志位复位，同时抛出中断异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();<span class="comment">//检测到当前线程已经被中断，执行自我中断，抛出异常。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="semaphore-acquireUninterruptibly"><a href="#semaphore-acquireUninterruptibly" class="headerlink" title="semaphore.acquireUninterruptibly()"></a>semaphore.acquireUninterruptibly()</h5><p>获取锁的过程中不允许中断，线程会一直处于获取锁的状态，只会在失败之后将标志位置为true。</p><p>贴上源码的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Acquires in shared uninterruptible mode.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">               <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                   <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                   <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                       setHeadAndPropagate(node, r);</span><br><span class="line">                       p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                       <span class="keyword">if</span> (interrupted)</span><br><span class="line">                           selfInterrupt();</span><br><span class="line">                       failed = <span class="keyword">false</span>;</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   interrupted = <span class="keyword">true</span>;<span class="comment">//不抛出异常，方法不支持中断抛出异常</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="Semaphore的两种实现（公平or非公平）"><a href="#Semaphore的两种实现（公平or非公平）" class="headerlink" title="Semaphore的两种实现（公平or非公平）"></a>Semaphore的两种实现（公平or非公平）</h4><p>Semaphore信号量提供了两种实现，公平和非公平的方式，这个可以类比retrantlock的公平非公平机制。一个会加入等待队列，一个不会加入等待队列。我们看下两个的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">//不会中断哦，一直循环占用cpu</span></span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;<span class="comment">//非公平的方式也会一直循环直到获取成功，少了的话也会返回一个负值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasQueuedPredecessors())<span class="comment">//公平的方式这里多维护了一个队列，如果已经加入了队列，直接返回，队列中的线程会被调度。</span></span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>我们看到公平和非公平的方式只是多了一个方法，那么看下这个方法到底实现了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* <span class="meta">@return</span> &#123;<span class="meta">@code</span> <span class="keyword">true</span>&#125; <span class="keyword">if</span> there is a queued thread preceding the</span><br><span class="line">     *         current thread, and &#123;<span class="meta">@code</span> <span class="keyword">false</span>&#125; <span class="keyword">if</span> the current thread</span><br><span class="line">     *         is at the head of the queue or the queue is empty</span><br><span class="line">     * <span class="meta">@since</span> <span class="number">1.7</span></span><br><span class="line">     */</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">        <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">        <span class="comment">// thread is first in queue.</span></span><br><span class="line">        Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//这里是维护的node队列，node是记录一个线程信息的对象。该方法主要判断当前线程是否已经维护进了公平等待的队列中，如果维护进去了，就返回false，没有维护进去就返回true。也就是公平锁会直接返回一个-1，线程继续执行，进入等待队列中调度执行。</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在面试的时候被问到信号量当时也是蛮懵逼的，觉得自己深入了解过AQS队列同步器，但是对java原生实现的一些同步器了解并不是特别多。信号量这个名字并不是特别好理解，可以更形象的称之为令牌管理器。在并发线程比较多的时候，一些有限的资源类似数据库连接数不能及时供应，那么我们需要进行一个流量控制。对于客户端的请求来说，可以在一段时间获取不到这个令牌之后选择不再等待，也可以在获取令牌的方法一直等待直到被中断，或者干脆一直等下去，死磕。网上搜索的时候发现一篇介绍同样内容的[博客]还不错，可以mark下<a href="https://blog.csdn.net/hanchao5272/article/details/79780045。" target="_blank" rel="noopener">https://blog.csdn.net/hanchao5272/article/details/79780045。</a></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在面试的时候被问到关于java信号量，并没有很了解这个并发同步器，这里学习之后做一点简单的记录。Semaphore我们通常称之为信号量，这是用来控制同时访问某个资源的线程数量的一个同步器。比如数据库连接，如果数据库连接的数量只有10个，但是此时在执行的线程数量大于10个，那
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>动态规划经典案例</title>
    <link href="http://jianghao.wang/2018/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B/"/>
    <id>http://jianghao.wang/2018/动态规划经典案例/</id>
    <published>2018-08-22T03:45:39.000Z</published>
    <updated>2018-08-22T06:40:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>​    动态规划是算法中比较重要的一课，是一种典型的空间换取时间的算法。通常是可以用分治法取考虑一个动态规划问题，用递归实现代码上看起来更加浅显易懂。但是基于递归的实现都是n2的复杂度，这样的复杂度在递归栈到达一定深度的时候会变的非常慢，并且有非常多的重复操作。动态规划致力于将这类递归问题，通过空间换取时间，用容器的方式记录递归结果，减少了重复递归，同时降低了时间复杂度。</p><h4 id="最长子数组问题"><a href="#最长子数组问题" class="headerlink" title="最长子数组问题"></a>最长子数组问题</h4><p>​    找出一个数组的连续子数组的最大和。最先想到的solution应该是n2的两次遍历。但是这样的循环是非常耗时的。我们尝试用分治的方式去思考一个复杂的问题，这是算法设计过程中常用的思维。当我们考虑一个任意数组比如{10,-1,2,-4,3,-5,10}，找出最长的子数组。可以先找出{10,-1,2,-4,3,-5}的最长子数组，那么我们可以得到一个数学函数公式（今天想偷个懒，明早去公司画一画）：</p><p>​    <img src="http://arthornye.github.io/images/%E5%AD%90%E4%B8%B2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png" alt="cmd-markdown-logo"></p><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>​    通常得出递归数学公式之后我们可以直接写出一个直观的递归程序。递归程序如下，这里需要维护一个Sum类，需要记录最长子数组的起始元素位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> MaxSubArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 8/21/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer startIndex;</span><br><span class="line">    <span class="keyword">private</span> Integer sum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getStartIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStartIndex</span><span class="params">(Integer startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.startIndex = startIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSum</span><span class="params">(Integer sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sum = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxSubArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Integer[] integerArray=&#123;<span class="number">10</span>,-<span class="number">1</span>,<span class="number">2</span>,-<span class="number">4</span>,<span class="number">3</span>,-<span class="number">5</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        System.out.println(maxSubArray(integerArray,<span class="number">6</span>).getSum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Sum <span class="title">maxSubArray</span><span class="params">(Integer[] integers, Integer index)</span></span>&#123;</span><br><span class="line">        Sum sum=<span class="keyword">new</span> Sum();</span><br><span class="line">        <span class="keyword">if</span>(integers==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(integers!=<span class="keyword">null</span> &amp;&amp; index==<span class="number">0</span>)&#123;</span><br><span class="line">            sum.setStartIndex(<span class="number">0</span>);</span><br><span class="line">            sum.setSum(integers[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Sum tempSum=maxSubArray(integers,index-<span class="number">1</span>);<span class="comment">//一个递归嘛,调用栈在上面的地方pop哦，没问题哦（在这里递归到0的时候pop执行下面的方法栈）。这里获取到子集的最长子串</span></span><br><span class="line">            Integer tempSumValue=<span class="number">0</span>;</span><br><span class="line">            Integer tempIndex=<span class="number">0</span>;<span class="comment">//最长子串的起始元素。必须记录这个元素，不然无法计算最长子数组到integer[i]的和</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=tempSum.getStartIndex();i&lt;=index;i++)&#123;</span><br><span class="line">                tempSumValue+=integers[i];</span><br><span class="line">            &#125;<span class="comment">//计算最长子数组到integer[i]的和</span></span><br><span class="line">            <span class="keyword">if</span>(tempSumValue&lt;integers[index])&#123;</span><br><span class="line">                tempIndex=index;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tempIndex=tempSum.getStartIndex();</span><br><span class="line">            &#125;</span><br><span class="line">            Integer maxSum=max(max(tempSumValue,integers[index]),tempSum.getSum());<span class="comment">//取三种情况的最大值</span></span><br><span class="line">            sum.setStartIndex(tempIndex);<span class="comment">//设置当前递归数组的起始元素和最大数组和</span></span><br><span class="line">            sum.setSum(maxSum);</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="动态规划（DP）"><a href="#动态规划（DP）" class="headerlink" title="动态规划（DP）"></a>动态规划（DP）</h5><p>​    分析上面的递归程序，n2的效率+递归调用栈，空间和时间利用率都不高。我们通过动态规划进行优化，动态规划的精髓可以用空间去换取空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxSubArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Integer[] integerArray=&#123;<span class="number">10</span>,-<span class="number">1</span>,<span class="number">2</span>,-<span class="number">4</span>,<span class="number">3</span>,-<span class="number">5</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> MaxSum = integerArray[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> TempMaxSum = integerArray[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; integerArray.length;i++)<span class="comment">//n的复杂度</span></span><br><span class="line">        &#123;</span><br><span class="line">          TempMaxSum = max(integerArray[i],TempMaxSum + integerArray[i]);<span class="comment">//决定当前最大子数组以哪个元素开头</span></span><br><span class="line">          MaxSum = max(MaxSum,TempMaxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(MaxSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="斐波那契数列问题"><a href="#斐波那契数列问题" class="headerlink" title="斐波那契数列问题"></a>斐波那契数列问题</h4><p>​    斐波那契数列的性质可以得到如下的数学递推公式，同样，我们提供递归和动态规划两种实现方式，这里我们看一下递推的公式：</p><p>​    <img src="http://arthornye.github.io/images/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.png" alt="cmd-markdown-logo"></p><h5 id="递归-DP"><a href="#递归-DP" class="headerlink" title="递归+DP"></a>递归+DP</h5> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Fobi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 8/22/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FoboNaCiArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(fiboNaciDigui(<span class="number">6</span>));<span class="comment">//递归的求斐波那契数列</span></span><br><span class="line">        <span class="comment">//DP求斐波那契数列</span></span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        arrayList.add(<span class="number">0</span>);</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(fiboNaciDP(<span class="number">6</span>,arrayList));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Integer <span class="title">fiboNaciDigui</span><span class="params">(Integer i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fiboNaciDigui(i-<span class="number">1</span>)+fiboNaciDigui(i-<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Integer <span class="title">fiboNaciDP</span><span class="params">(Integer index,ArrayList&lt;Integer&gt; arrayList)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;index;i++)&#123;</span><br><span class="line">            arrayList.add(arrayList.get(i-<span class="number">1</span>)+arrayList.get(i-<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrayList.get(index-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    动态规划是算法中比较重要的一课，是一种典型的空间换取时间的算法。通常是可以用分治法取考虑一个动态规划问题，用递归实现代码上看起来更加浅显易懂。但是基于递归的实现都是n2的复杂度，这样的复杂度在递归栈到达一定深度的时候会变的非常慢，并且有非常多的重复操作。动态规划致
      
    
    </summary>
    
    
      <category term="大搜车的点滴记录" scheme="http://jianghao.wang/tags/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%9A%84%E7%82%B9%E6%BB%B4%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Java 8中的Stream API 详解</title>
    <link href="http://jianghao.wang/2018/Java-8%E4%B8%AD%E7%9A%84Streams-API-%E8%AF%A6%E8%A7%A3/"/>
    <id>http://jianghao.wang/2018/Java-8中的Streams-API-详解/</id>
    <published>2018-08-14T10:07:19.000Z</published>
    <updated>2018-08-15T07:23:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Stream-API概述"><a href="#Stream-API概述" class="headerlink" title="Stream API概述"></a>Stream API概述</h3><p>​    Stream是Java8中的一大亮点，它为容器集合的操作提供了一系列函数式编程方式，节省了大量的重复代码，同时也让代码变得更加简洁精炼。相信在运用java8之前的版本中，我们需要对容器进行操作，手写遍历手写赋值的过程使得代码十分臃肿并且可读性极差。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。可以说stream api是函数式+多核的结合物。</p><h3 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h3><p>​    在之前的工作中，曾经有个需求需要构造一个双层的map结构。我们拿到的是一个仓库的全列表，需要根据城市首字母去聚合所有的城市，然后根据城市去聚合这个城市的仓库列表。从复杂度上考虑，需要两次聚合操作，要有两次循环。这里贴一段java8之前的代码实现（相当繁琐，可读性极差）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TruckStoreDTO&gt; <span class="title">getStorageList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       StorageQO storageQO=<span class="keyword">new</span> StorageQO();</span><br><span class="line">       Page&lt;StorageDTO&gt; storageDTOPage=remoteStorageService.query(storageQO,<span class="number">1</span>,<span class="number">200</span>);</span><br><span class="line">       <span class="keyword">if</span>(storageDTOPage!=<span class="keyword">null</span> &amp;&amp; storageDTOPage.getTotalNumber()!=<span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//获取到原始仓库列表数据</span></span><br><span class="line">           List&lt;StorageDTO&gt; storageDTOList=storageDTOPage.getItems();</span><br><span class="line">           <span class="comment">//根据城市首字母建立一个聚合列表，treemap遍历有序,查询匹配logn复杂度</span></span><br><span class="line">           TreeMap&lt;String,Map&lt;String,List&lt;StorageDetailDTO&gt;&gt;&gt; cityTreeMap=<span class="keyword">new</span> TreeMap();</span><br><span class="line">           <span class="keyword">for</span>(StorageDTO storageDTO:storageDTOList)&#123;</span><br><span class="line">               String pinyinCity= PingYingUtils.getPinYinFirstHeadChar(storageDTO.getCity());</span><br><span class="line">               <span class="comment">//获取到城市名拼音的首字母大写（同拼音城市列表map&lt;cityCode,list&lt;bean&gt;&gt;）</span></span><br><span class="line">               String firstPinyin=pinyinCity.toUpperCase();</span><br><span class="line"></span><br><span class="line">               <span class="comment">//根据城市的code聚合仓库列表，treemap匹配logn复杂度</span></span><br><span class="line">               Map&lt;String,List&lt;StorageDetailDTO&gt;&gt; cityStorageDTOMap;</span><br><span class="line">               List&lt;StorageDetailDTO&gt; storageDetailDTOList;</span><br><span class="line">               <span class="comment">//判断是否包含了该拼音的map&lt;cityCode,List&lt;StorageDetailDTO&gt;</span></span><br><span class="line">               <span class="keyword">if</span> (cityTreeMap.containsKey(firstPinyin)) &#123;</span><br><span class="line">                   cityStorageDTOMap=cityTreeMap.get(firstPinyin);</span><br><span class="line"></span><br><span class="line">                   StorageDetailDTO storageDetailDTO=<span class="keyword">new</span> StorageDetailDTO();</span><br><span class="line">                   storageDetailDTO.setStorageCode(storageDTO.getStorageCode());</span><br><span class="line">                   storageDetailDTO.setStorageName(storageDTO.getStorageName());</span><br><span class="line">                   storageDetailDTO.setCityName(storageDTO.getCity());</span><br><span class="line">                   storageDetailDTO.setAddress(storageDTO.getPlace());</span><br><span class="line">                   <span class="comment">//如果当前城市已经被插入(同城市列表list&lt;bean&gt;)</span></span><br><span class="line">                   <span class="keyword">if</span>(cityStorageDTOMap.containsKey(storageDTO.getCityCode()))&#123;</span><br><span class="line">                       <span class="comment">//在城市中插入多个仓库</span></span><br><span class="line">                       storageDetailDTOList=cityStorageDTOMap.get(storageDTO.getCityCode());</span><br><span class="line">                       storageDetailDTOList.add(storageDetailDTO);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//当前城市未被插入过</span></span><br><span class="line">                   <span class="keyword">else</span> &#123;</span><br><span class="line">                       storageDetailDTOList =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                       storageDetailDTOList.add(storageDetailDTO);</span><br><span class="line">                       cityStorageDTOMap.put(storageDTO.getCityCode(),storageDetailDTOList);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//当前首字母未被插入过</span></span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   cityStorageDTOMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">                   cityTreeMap.put(firstPinyin,cityStorageDTOMap);</span><br><span class="line"></span><br><span class="line">                   storageDetailDTOList =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                   StorageDetailDTO storageDetailDTO=<span class="keyword">new</span> StorageDetailDTO();</span><br><span class="line">                   storageDetailDTO.setStorageCode(storageDTO.getStorageCode());</span><br><span class="line">                   storageDetailDTO.setStorageName(storageDTO.getStorageName());</span><br><span class="line">                   storageDetailDTO.setCityName(storageDTO.getCity());</span><br><span class="line">                   storageDetailDTO.setAddress(storageDTO.getPlace());</span><br><span class="line">                   storageDetailDTOList.add(storageDetailDTO);</span><br><span class="line">                   cityStorageDTOMap.put(storageDTO.getCityCode(),storageDetailDTOList);</span><br><span class="line">                   cityTreeMap.put(firstPinyin,cityStorageDTOMap);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           List&lt;TruckStoreDTO&gt; truckStoreDTOList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span>(Map.Entry cityEntry:cityTreeMap.entrySet())&#123;</span><br><span class="line">               TruckStoreDTO truckStoreDTO=<span class="keyword">new</span> TruckStoreDTO();</span><br><span class="line">               Map&lt;String,List&lt;StorageDetailDTO&gt;&gt; storageDetailListMap=(Map&lt;String,List&lt;StorageDetailDTO&gt;&gt;)cityEntry.getValue();</span><br><span class="line">               List&lt;CityStorageDTO&gt; cityStorageDTOList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">               <span class="keyword">for</span>(Map.Entry storageEntry:storageDetailListMap.entrySet() )&#123;</span><br><span class="line">                   List&lt;StorageDetailDTO&gt; storageDetailDTOList=(List&lt;StorageDetailDTO&gt;)storageEntry.getValue();</span><br><span class="line">                   CityStorageDTO cityStorageDTO=<span class="keyword">new</span> CityStorageDTO();</span><br><span class="line">                   cityStorageDTO.setCityName(storageDetailDTOList.get(<span class="number">0</span>).getCityName());</span><br><span class="line">                   cityStorageDTO.setCityCode((String)storageEntry.getKey());</span><br><span class="line">                   cityStorageDTO.setStorageDetailDTOList(storageDetailDTOList);</span><br><span class="line">                   cityStorageDTOList.add(cityStorageDTO);</span><br><span class="line">               &#125;</span><br><span class="line">               truckStoreDTO.setCityStorageDTOList(cityStorageDTOList);</span><br><span class="line">               truckStoreDTO.setCityListKey((String)cityEntry.getKey());</span><br><span class="line">               truckStoreDTOList.add(truckStoreDTO);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> truckStoreDTOList;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这种实现的弊端：</p><p><strong><em>1.太多的循环导致可读性极差</em></strong></p><p><strong><em>2.重复冗余的代码过多</em></strong></p><p>那么我们希望通过Stream API去改善和优化这段代码，因为这段是之前在项目中的一段代码，我在这里进行模拟操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> StreamAPI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 8/14/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StorageTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;StorageDTO&gt; arrayList=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">27</span>;i++)&#123;</span><br><span class="line">            StorageDTO storageDTO=<span class="keyword">new</span> StorageDTO();</span><br><span class="line">            <span class="keyword">char</span> firstKey=(<span class="keyword">char</span>) (i+<span class="number">65</span>);</span><br><span class="line">            storageDTO.setCityFirstKey(String.valueOf(firstKey));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++) &#123;</span><br><span class="line">                String cityName=<span class="string">"city:"</span>+(<span class="keyword">char</span>) (j+<span class="number">65</span>);</span><br><span class="line">                storageDTO.setCityName(cityName);</span><br><span class="line">                storageDTO.setStorageName(<span class="string">"storage:"</span>+j);</span><br><span class="line">                arrayList.add(storageDTO);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//构造一个两次聚合的仓库数组列表</span></span><br><span class="line">        Stream stream= arrayList.stream();</span><br><span class="line">        Map&lt;String,Map&lt;String,List&lt;StorageDTO&gt;&gt;&gt;storageListMap=(Map&lt;String,Map&lt;String,List&lt;StorageDTO&gt;&gt;&gt;)stream.collect(Collectors.groupingBy(StorageDTO::getCityFirstKey,Collectors.groupingBy(StorageDTO::getCityName)));</span><br><span class="line">        <span class="comment">//通过stream的聚合操作可以直接完成上面的一堆代码的操作，一句代码vs一堆代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到这两种方式的对比是非常明显的，使用Stream API的聚合操作，代码可读性更强。</p><h3 id="流的使用详解"><a href="#流的使用详解" class="headerlink" title="流的使用详解"></a>流的使用详解</h3><p>​    一个流在处理的过程中可能有<strong>Intermediate</strong>（对原数据创建流这个过程会对数据进行过滤和筛选，这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历）。<strong>Terminal</strong>操作会开始真实的遍历过程，会将先前的lazy的遍历条件全部执行。</p><p>​    lazy操作的意思是我们在进行类似filter操作以及limit等操作，实际上并没有开始执行，因为这样如果执行会面临比较大的效率问题。一次循环执行所有的lazy条件，这是对函数式编程的一种技能上的提升。</p><h4 id="流是如何构造"><a href="#流是如何构造" class="headerlink" title="流是如何构造"></a>流是如何构造</h4><p>​    当我们需要去获取或者构造一个流的时候，因为流提供的是一种聚合操作，所以流的数据源是不分层的，类似于简单的对象列表，是没有维度的。那么我们可以通过数组去构造或者通过数组去获得流。常见的几种流的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stream stream = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);<span class="comment">//单纯通过数组去构造流</span></span><br><span class="line"></span><br><span class="line">String [] strArray = <span class="keyword">new</span> String[] &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">stream = Stream.of(strArray);</span><br><span class="line">stream = Arrays.stream(strArray);</span><br><span class="line"><span class="comment">//通过数组容器直接获取到流应该是最常用的一种方式</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(strArray);</span><br><span class="line">stream = list.stream();</span><br></pre></td></tr></table></figure><h4 id="流的主要API"><a href="#流的主要API" class="headerlink" title="流的主要API"></a>流的主要API</h4><p>​    这个模块会主要展示流的几种主要的api，这里根据<strong>Intermediate</strong>，<strong>Short-circuiting</strong>，<strong>Terminal</strong>进行分类：</p><ul><li><p>Intermediate：</p><p>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered</p></li><li><p>Terminal：</p><p>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</p></li><li><p>Short-circuiting：</p><p>anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</p><p>我们下面看一下 Stream 的比较典型用法：</p></li></ul><h5 id="map-flatMap"><a href="#map-flatMap" class="headerlink" title="map/flatMap"></a>map/flatMap</h5><p>map提供流数据一对一的映射操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       arrayList.add(<span class="string">"I"</span>);</span><br><span class="line">       arrayList.add(<span class="string">"LOVE"</span>);</span><br><span class="line">       arrayList.add(<span class="string">"U"</span>);</span><br><span class="line">       arrayList.add(<span class="string">"TOO"</span>);</span><br><span class="line">       arrayList.add(<span class="string">"MUCH"</span>);</span><br><span class="line">       Stream&lt;String&gt; stream=arrayList.stream();</span><br><span class="line">       <span class="comment">//用map将字段映射成小写</span></span><br><span class="line">       List&lt;String&gt; stringList=stream.map(String::toLowerCase).collect(Collectors.toList());</span><br><span class="line">       System.out.println(stringList);</span><br></pre></td></tr></table></figure><p>flatMap提供流数据的一对多映射操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(</span><br><span class="line"> Arrays.asList(<span class="number">1</span>),</span><br><span class="line"> Arrays.asList(<span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line"> Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"> );</span><br><span class="line">Stream&lt;Integer&gt; outputStream = inputStream.</span><br><span class="line">flatMap((childList) -&gt; childList.stream());</span><br><span class="line"><span class="comment">//将一个数组列表的数据扁平化，一对多映射操作</span></span><br></pre></td></tr></table></figure><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><p>filter操作进行进行过滤流数据。例如我们可以对数据急性偶数和奇数的过滤，类似的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer[] sixNums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">Integer[] evens =</span><br><span class="line">Stream.of(sixNums).filter(n -&gt; n%<span class="number">2</span> == <span class="number">0</span>).toArray(Integer[]::<span class="keyword">new</span>);</span><br><span class="line"><span class="comment">//过滤数据</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; output = reader.lines().</span><br><span class="line"> flatMap(line -&gt; Stream.of(line.split(REGEXP))).</span><br><span class="line"> filter(word -&gt; word.length() &gt; <span class="number">0</span>).</span><br><span class="line"> collect(Collectors.toList());</span><br><span class="line"><span class="comment">//过滤单词，flatMap将一行单词转换为一个单词列表</span></span><br></pre></td></tr></table></figure><h5 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h5><p>forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roster.stream()</span><br><span class="line"> .filter(p -&gt; p.getGender() == Person.Sex.MALE)</span><br><span class="line"> .forEach(p -&gt; System.out.println(p.getName()));</span><br></pre></td></tr></table></figure><p>另外需要注意的是如果对一个stream进行两次terminal操作，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stream.forEach(element -&gt; doOneThing(element));</span><br><span class="line">stream.forEach(element -&gt; doAnotherThing(element));</span><br></pre></td></tr></table></figure><p>运行时会报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.IllegalStateException: stream has already been operated upon or closed </span><br><span class="line">at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:<span class="number">229</span>)</span><br><span class="line">at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:<span class="number">499</span>)</span><br><span class="line">at StreamAPI.StreamAPITest.main(StreamAPITest.java:<span class="number">33</span>)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:<span class="number">497</span>)</span><br><span class="line">at com.intellij.rt.execution.application.AppMain.main(AppMain.java:<span class="number">144</span>)</span><br></pre></td></tr></table></figure><p>那么如果我们需要在流数据过滤的过程中进行打印，可以不用terminal操作，采用Intermediate操作，上面的代码可以通过peek操作达到打印的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>)</span><br><span class="line"> .filter(e -&gt; e.length() &gt; <span class="number">3</span>)</span><br><span class="line"> .peek(e -&gt; System.out.println(<span class="string">"Filtered value: "</span> + e))</span><br><span class="line"> .map(String::toUpperCase)</span><br><span class="line"> .peek(e -&gt; System.out.println(<span class="string">"Mapped value: "</span> + e))<span class="comment">//不是teminal操作，Intermediate操作不会报错</span></span><br><span class="line"> .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><p>字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce，例如 Stream 的 sum 就相当于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer sum = integers.reduce(<span class="number">0</span>, (a, b) -&gt; a+b); <span class="comment">//前面是是初始值，右边是操作的元素的函数</span></span><br><span class="line">Integer sum = integers.reduce(<span class="number">0</span>, Integer::sum);:<span class="comment">//sum的简写方式</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找出最长的单词用reduce</span></span><br><span class="line">Optional&lt;String&gt; longest=stream.reduce((s1, s2)-&gt;s1.length()&gt;s2.length()?s1:s2);</span><br><span class="line">System.out.println(<span class="string">"reduce操作找出最长的单词字符串:"</span>);</span><br><span class="line">System.out.println(longest.get());</span><br><span class="line"><span class="comment">//reduce操作拼接字符串</span></span><br><span class="line">String concatStr=stream.reduce(<span class="string">""</span>,String::concat);</span><br><span class="line">System.out.println(<span class="string">"reduce操作拼接字符串"</span>+concatStr);</span><br></pre></td></tr></table></figure><h5 id="limit-skip-sorted"><a href="#limit-skip-sorted" class="headerlink" title="limit/skip/sorted"></a>limit/skip/sorted</h5><p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来），正常的sorted操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; personList=persons.stream().sorted((p1,p2)-&gt;p1.getAge().compareTo(p2.getAge())).limit(<span class="number">3</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>讲到这里可能大家比较好奇的是，这个自带的api是如何保证执行效率的，或者说它内部的时间效率如果是n2那作为调用方其实是未知的。那么实际上排序的时间复杂度是 O(n log n)</p><h5 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h5><p>Stream 有三个 match 方法，从语义上说：</p><ul><li>allMatch：Stream 中全部元素符合传入的 predicate，返回 true</li><li>anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true</li><li>noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList();</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"name"</span> + <span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">2</span>, <span class="string">"name"</span> + <span class="number">2</span>, <span class="number">21</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">3</span>, <span class="string">"name"</span> + <span class="number">3</span>, <span class="number">34</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">4</span>, <span class="string">"name"</span> + <span class="number">4</span>, <span class="number">6</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">5</span>, <span class="string">"name"</span> + <span class="number">5</span>, <span class="number">55</span>));</span><br><span class="line"><span class="keyword">boolean</span> isAllAdult = persons.stream().</span><br><span class="line"> allMatch(p -&gt; p.getAge() &gt; <span class="number">18</span>);</span><br><span class="line">System.out.println(<span class="string">"All are adult? "</span> + isAllAdult);</span><br><span class="line"><span class="keyword">boolean</span> isThereAnyChild = persons.stream().</span><br><span class="line"> anyMatch(p -&gt; p.getAge() &lt; <span class="number">12</span>);</span><br><span class="line">System.out.println(<span class="string">"Any child? "</span> + isThereAnyChild);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">All are adult? <span class="keyword">false</span></span><br><span class="line">Any child? <span class="keyword">true</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>运用Stream API最明显的感觉是提供了类似c++提供的一系列STL容器操作。帮主我们对容器进行更方便可读性更强的处理，减少了很多常用的重复代码。之后在工作种可以用这种写法，这里做一个总结stream的特性：</p><ul><li>不是数据结构</li></ul><ul><li>它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。</li><li>它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。</li></ul><ul><li>所有 Stream 的操作必须以 lambda 表达式为参数</li><li>不支持索引访问</li></ul><ul><li>你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。</li></ul><ul><li>很容易生成数组或者 List</li><li>惰性化</li></ul><ul><li>很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。</li><li>Intermediate 操作永远是惰性化的。</li></ul><ul><li>并行能力</li></ul><ul><li>当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。</li></ul><ul><li>集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Stream-API概述&quot;&gt;&lt;a href=&quot;#Stream-API概述&quot; class=&quot;headerlink&quot; title=&quot;Stream API概述&quot;&gt;&lt;/a&gt;Stream API概述&lt;/h3&gt;&lt;p&gt;​    Stream是Java8中的一大亮点，它为容器集合
      
    
    </summary>
    
    
      <category term="大搜车的点滴记录" scheme="http://jianghao.wang/tags/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%9A%84%E7%82%B9%E6%BB%B4%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>ReetrantWriteReadLock读写锁</title>
    <link href="http://jianghao.wang/2018/ReetrantWriteReadLock%E8%AF%BB%E5%86%99%E9%94%81/"/>
    <id>http://jianghao.wang/2018/ReetrantWriteReadLock读写锁/</id>
    <published>2018-08-09T10:23:29.000Z</published>
    <updated>2018-08-14T08:02:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>####ReetrantWriteReadLock读写锁</p><p>​    Java的同步器，都基于AQS自定义同步器，那么如果设计一个自定义同步器。需要去适应不同的场景，例如我们在讲到ReetrantLock的实现时，它是基于AQS实现的一个可重入，可中断的锁，获取到锁的线程可以在同步块进行竞争对象的读写操作。但是我们可以设想，如果当前请求的线程多为读操作，那么加锁，释放锁的操作就会非常频繁，A线程在读的时候，B线程只能循环等待A线程释放锁（实际上此时此刻并没有线程进行写操作，并不会造城脏读），这样的话实际上是极大的牺牲了程序响应读的性能。</p><h4 id="等待／通知机制"><a href="#等待／通知机制" class="headerlink" title="等待／通知机制"></a>等待／通知机制</h4><p>​    在介绍读写锁的实现之前，介绍下java的线程通信机制wait／notify机制。之前有一篇博客，对比了CountDownLatch和CyclicBarrier，其中一个区别便是CountDownLatch 的主线程需要所有等待子线程完成。而CyclicBarrier建立在等待／通知机制上，实现了线程在等待之后重新被唤醒。</p><p>​    这里我们主要介绍synchronized+object的等待通知机制，建立在两个线程（等待线程和通知线程），可以类比为消费者线程和生产者线程。等待线程（消费者）在生产者完成生产操作之后从wait处继续执行。这里提供一种实现。定义一个消费者线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> NotifyWait;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 8/7/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String threadName;<span class="comment">//线程名</span></span><br><span class="line">    Object object;<span class="comment">//加锁</span></span><br><span class="line">    WaitThread(String threadName,Object object)&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadName=threadName;</span><br><span class="line">        <span class="keyword">this</span>.object=object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            <span class="comment">//看下是否执行了两次</span></span><br><span class="line">            System.out.println(<span class="string">"消费者线程进入同步块,flag:"</span>+NotifyWaitThread.flag);</span><br><span class="line">            <span class="keyword">while</span> (!NotifyWaitThread.flag) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(threadName+<span class="string">"消费者检测到生产者数据未生产完毕，开始等待...."</span>);</span><br><span class="line">                    object.wait();<span class="comment">//从同步队列中被唤醒的时候会重新从这里开始执行</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(threadName+<span class="string">"消费者检测到生产者得数据已经生产完毕，开始执行生产者线程..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个生产者线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> NotifyWait;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 8/7/18. 通知线程（类比生产者，去通知消费者，线程已经执行完毕，获取到所要的结果）</span></span><br><span class="line"><span class="comment"> * 通常在多个网络请求的过程中我们可以通过异步的方式分别去执行请求线程</span></span><br><span class="line"><span class="comment"> * 线程之间如果有数据结果依赖可以基于这种模型去等待通知（消费者等待生产者的数据请求结果）</span></span><br><span class="line"><span class="comment"> * 这里通过flag来模拟标示生产者是否已经将数据生产完毕</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    String threadName;<span class="comment">//线程名</span></span><br><span class="line">    Object object;<span class="comment">//加锁</span></span><br><span class="line">    NotifyThread(String threadName,Object object)&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadName=threadName;</span><br><span class="line">        <span class="keyword">this</span>.object=object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">            <span class="comment">//执行数据的生产过程，过程结束之后进行内存刷新，更新数据刷新成功标志</span></span><br><span class="line">            System.out.println(threadName+<span class="string">"开始生产数据"</span>);</span><br><span class="line">            NotifyWaitThread.flag=<span class="keyword">true</span>;</span><br><span class="line">            object.notifyAll();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.currentThread().sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(threadName+<span class="string">"生产者再次尝试获取锁"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启主线程启动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> NotifyWait;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 8/7/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyWaitThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object object=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> WaitThread(<span class="string">"WaitThread"</span>,object)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> NotifyThread(<span class="string">"NotifyThread"</span>,object)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程启动之后看下执行的结果，消费线程休眠10s，生产者线程先获得锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NotifyThread开始生产数据</span><br><span class="line">NotifyThread生产者再次尝试获取锁</span><br><span class="line">消费者线程进入同步块,flag:<span class="keyword">true</span></span><br><span class="line">WaitThread消费者检测到生产者得数据已经生产完毕，开始执行生产者线程...</span><br></pre></td></tr></table></figure><p>消费线程先获得锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">消费者线程进入同步块,flag:<span class="keyword">false</span></span><br><span class="line">WaitThread消费者检测到生产者数据未生产完毕，开始等待....</span><br><span class="line">NotifyThread开始生产数据</span><br><span class="line">NotifyThread生产者再次尝试获取锁</span><br><span class="line">WaitThread消费者检测到生产者得数据已经生产完毕，开始执行生产者线程...</span><br></pre></td></tr></table></figure><p>​    这里需要注意的一点是，在java的等待通知机制中是必须结合synchronized关键字的（锁的获取和释放）。调用object.wait()，object.notify()，object.notifyAll()，这些方法需要先对object对象进行加锁。下面总结一个经典的等待通知机制范式，等待方（消费者）需要遵循如下原则：</p><p>​    <strong>1.获取对象的锁。</strong></p><p>​    <strong>2.如果条件不满足，那么调用对象的wait方法，被通知到再次进行条件检查。</strong></p><p>​    <strong>3.条件满足之后执行相应的逻辑。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">  <span class="keyword">while</span>(条件不满足)&#123;<span class="comment">//volatile修饰，保证变量的线程可见性</span></span><br><span class="line">    对象.wait();</span><br><span class="line">  &#125;</span><br><span class="line">  对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通知方需要遵循如下原则：</p><p>​        <strong>1.获得对象的锁。</strong></p><p>​    <strong>2.改变判断条件。</strong></p><p>​    <strong>3.通知所有等待在对象上的线程重新开始执行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sychronized(对象)&#123;</span><br><span class="line">  改变条件</span><br><span class="line">    对象.notiryAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到java的等待通知机制完成了单个线程与单个线程的通信，控制代码的执行顺序。这在我们设计一个读写锁的时候，写的时候不能读，读的时候不能写，在写操作完成之后是可以通过这种方式通知读线程可以继续读的。但是基于这种范式的局限性，实际上通过sychronized关键字去修饰的代码块已经是串行执行。而我们的读写锁最终需要保证的是读锁（共享锁）多个线程可重入，而写锁（独占锁）不可重入。获取读锁需要判断当前没有写线程，获取写锁需要保证当前无读线程。</p><h4 id="ReetrantWriteReadLock的应用"><a href="#ReetrantWriteReadLock的应用" class="headerlink" title="ReetrantWriteReadLock的应用"></a>ReetrantWriteReadLock的应用</h4><p>根据ReetrantWriteReadLock的特性，我们可以封装一个线程不安全的hashMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ReetrantWriteAndReadLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于读写锁封装一个hashmap</span></span><br><span class="line"><span class="comment"> * Created by yqz on 8/9/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReetrantWriteAndReadLockExp</span> </span>&#123;</span><br><span class="line">    <span class="comment">//还是定义为volatile吧，不然在ReetrantWriteAndReadLockExp.get触发类加载，创建对象还未完成，就已经被另一个线程空指针调用。volatile的内存屏障可以保证new成功一个对象，写成功之后才被读。</span></span><br><span class="line">    <span class="comment">//这种模式在定义一个可能被并发获取的单例模式对象的时候，也需要定义为volatile，用内存屏障保证不会空指针。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> HashMap&lt;String,String&gt; hashMap=<span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ReadWriteLock readWriteLock=<span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Lock readLock=readWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Lock writeLock=readWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> hashMap.get(key);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key,String value)</span></span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hashMap.put(key,value);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读写锁的设计"><a href="#读写锁的设计" class="headerlink" title="读写锁的设计"></a>读写锁的设计</h4><p>​    读写锁需要在一个int类型的变量（AQS中的state变量）上维护读锁的状态和写锁的状态。按位分割，高十六位表示读锁的状态，低十六位表示写锁的状态，这两部分在判断读锁和写锁状态的时候需要按位去取。这样只需要保证整个int变量的线程可见性即可。可以看下jdk源码是如何去获取读锁和写锁的，获取读锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Walkthrough:</span></span><br><span class="line"><span class="comment">            * 1. If write lock held by another thread, fail.//如果写锁被其他线程持有，获取读锁失败</span></span><br><span class="line"><span class="comment">            * 2. Otherwise, this thread is eligible for</span></span><br><span class="line"><span class="comment">            *    lock wrt state, so ask if it should block</span></span><br><span class="line"><span class="comment">            *    because of queue policy. If not, try</span></span><br><span class="line"><span class="comment">            *    to grant by CASing state and updating count.</span></span><br><span class="line"><span class="comment">            *    Note that step does not check for reentrant</span></span><br><span class="line"><span class="comment">            *    acquires, which is postponed to full version</span></span><br><span class="line"><span class="comment">            *    to avoid having to check hold count in</span></span><br><span class="line"><span class="comment">            *    the more typical non-reentrant case.//读线程不阻塞，线程通过cas去累加读锁的count</span></span><br><span class="line"><span class="comment">            * 3. If step 2 fails either because thread</span></span><br><span class="line"><span class="comment">            *    apparently not eligible or CAS fails or count</span></span><br><span class="line"><span class="comment">            *    saturated, chain to version with full retry loop.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           Thread current = Thread.currentThread();</span><br><span class="line">           <span class="keyword">int</span> c = getState();</span><br><span class="line">           <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">               getExclusiveOwnerThread() != current)<span class="comment">//如果当前写锁的状态不为零，并且不是当前的线程持有锁（那么该读锁即使是共享锁，也是获取失败的）</span></span><br><span class="line">               <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">           <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;<span class="comment">//readerShouldBlock是判断当前锁是不是公平锁，如果是公平锁的话需要等待前置的线程队列，也就是会完全阻塞掉，循环等待调用。如果获取成功了读锁则增加读锁计数状态。</span></span><br><span class="line">               r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">               compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                   firstReader = current;</span><br><span class="line">                   firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                   firstReaderHoldCount++;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                   <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                       cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                       readHolds.set(rh);</span><br><span class="line">                   rh.count++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line"> <span class="comment">//这里循环阻塞，循环获取读锁，循环cas。</span></span><br><span class="line">           <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>获取写锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Walkthrough:</span></span><br><span class="line"><span class="comment">            * 1. If read count nonzero or write count nonzero</span></span><br><span class="line"><span class="comment">            *    and owner is a different thread, fail.//如果读锁的数量不为零或者写锁的数量不为零并且不是当前的线程持有这个写锁。</span></span><br><span class="line"><span class="comment">            * 2. If count would saturate, fail. (This can only</span></span><br><span class="line"><span class="comment">            *    happen if count is already nonzero.)//如果持有写锁的线程可重入最大次数，获取失败。</span></span><br><span class="line"><span class="comment">            * 3. Otherwise, this thread is eligible for lock if</span></span><br><span class="line"><span class="comment">            *    it is either a reentrant acquire or</span></span><br><span class="line"><span class="comment">            *    queue policy allows it. If so, update state</span></span><br><span class="line"><span class="comment">            *    and set owner.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           Thread current = Thread.currentThread();</span><br><span class="line">           <span class="keyword">int</span> c = getState();</span><br><span class="line">           <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">           <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">               <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">               <span class="comment">// Reentrant acquire</span></span><br><span class="line">               setState(c + acquires);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">  <span class="comment">//如果当前写锁的状态为零，并且是非公平锁，而且通过cas成功获取到了锁。那么将写锁的持有线程改写为当前线程。</span></span><br><span class="line">           <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">               !compareAndSetState(c, c + acquires))</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           setExclusiveOwnerThread(current);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    读写锁通过将读写分离，读锁作为一个共享锁，写锁作为一个独占锁，两个锁同时由一个volatile的int state维护，高位维护读锁，低位维护写锁。同时读锁和写锁都可以设置为公平和非公平。通过运用读写锁，可以在并发过程中保证读的正确性以及响应速度。读写锁非常适用于读的频率很高，但是写的频率很小的场景。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;####ReetrantWriteReadLock读写锁&lt;/p&gt;
&lt;p&gt;​    Java的同步器，都基于AQS自定义同步器，那么如果设计一个自定义同步器。需要去适应不同的场景，例如我们在讲到ReetrantLock的实现时，它是基于AQS实现的一个可重入，可中断的锁，获取
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch和CyclicBarrier</title>
    <link href="http://jianghao.wang/2018/CountDownLatch%E5%92%8CCyclicBarrier/"/>
    <id>http://jianghao.wang/2018/CountDownLatch和CyclicBarrier/</id>
    <published>2018-04-04T06:59:44.000Z</published>
    <updated>2018-04-04T06:59:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>CountDownLatch和CyclicBarrier都是给予AQS队列同步器实现的共享锁。</p><p>CountDownLatch是单纯通过维持一个state的计数数值，这个数值在线程调用countDownLatch.countDown()的时候会减1，当计数器的值为零的时候，等待的线程会向前执行。假如我们需要保证在主线程继续往前执行的时候，子任务都已经被启动，可以通过CountDownLatch来进行控制。实际上和ReetrantLock是基于同样的原理实现，不过是实现和覆盖了tryAccquireShare和tryReleaseShare的区别。</p><p>CyclicBarrier则和CountDownLatch以及ReetrantLock不相同，它是通过lock和等待／通知机制实现的，在CountDownLatch实现的多线程模型中，各个线程之间是没办法进行通信的，只能保证一个happens-before，但是CyclicBarrier通过lock+Condition来维持一个同步队列和等待队列（通常将等待在同步块外面的队列称之为同步队列，将等待在某个对象上的队列称之为等待队列），lock中的Condition对象可以有多个，也就是维护多个等待队列。我们观察CyclicBarrier的实现可以看到它的内部只维持了一个等待队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The lock for guarding barrier entry */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/** Condition to wait on until tripped */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();<span class="comment">//维持了一个等待队列，可以通过trip.signal唤醒等待队列中所有的节点加入到同步队列中。</span></span><br><span class="line">    <span class="comment">/** The number of parties */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line">    <span class="comment">/* The command to run when tripped */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line">    <span class="comment">/** The current generation */</span></span><br><span class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br></pre></td></tr></table></figure><h3 id="CountDownLatch的使用"><a href="#CountDownLatch的使用" class="headerlink" title="CountDownLatch的使用"></a>CountDownLatch的使用</h3><p>我们通过一段代码查看CountDownLatch的主要使用方式，我们定义一个woker线程，作为子任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 4/3/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String workerName;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(String workerName,CountDownLatch countDownLatch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.workerName=workerName;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch=countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doWorker();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWorker</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getWorkerName()+<span class="string">"释放一次共享锁"</span>);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWorkerName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> workerName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWorkerName</span><span class="params">(String workerName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.workerName = workerName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过main方法调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 4/3/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line">        ArrayList&lt;Thread&gt; arrayListWorker=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            arrayListWorker.add(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(<span class="string">"worker_"</span>+(i+<span class="number">1</span>),countDownLatch)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread worker:arrayListWorker)&#123;</span><br><span class="line">            worker.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"countDownLatch结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">worker_1释放一次共享锁</span><br><span class="line">worker_4释放一次共享锁</span><br><span class="line">worker_2释放一次共享锁</span><br><span class="line">worker_5释放一次共享锁</span><br><span class="line">worker_3释放一次共享锁</span><br><span class="line">countDownLatch结束</span><br></pre></td></tr></table></figure><p>这样的使用方式我们可以看到CountDownLatch实际上保证了当前主线程会等待所有的线程都启动，我们可以通过countDownLatch.countDown()这个方法去动态更改state的数值，主线程只有在state的数值变成0之后才会选择继续向前执行。这样的处理似乎很像thread.join这种等待当前线程执行结束在执行主线程的方式，不同的是使用CountDownLatch你不一定要保证线程已经执行结束进入死亡状态，你可以在线程执行栈中通过countDownLatch.countDown()手动更改这个state的数值，只要这个数值为0，主线程便可以开始运行。</p><h3 id="CountDownLatch源代码分析"><a href="#CountDownLatch源代码分析" class="headerlink" title="CountDownLatch源代码分析"></a>CountDownLatch源代码分析</h3><p>CountDownLatch实现的几个主要方法，通过内部的sync重写了AQS队列同步器中的获取和释放共享锁的方法。我们通过CountDownLatch的构造方法去设置state的数值。getCount可以获得当前的state值。通过countDown去循环cas减少state的数值，最后的await方法实现循环等待state的值，直到变为零。这里看下await方法的主要源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">  <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">      <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          setHeadAndPropagate(node, r);</span><br><span class="line">          p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">          failed = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">          parkAndCheckInterrupt())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">      cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CyclicBarrier的使用"><a href="#CyclicBarrier的使用" class="headerlink" title="CyclicBarrier的使用"></a>CyclicBarrier的使用</h3><p>对比CountDownLatch的使用我们可以发现CountDownLatch的缺陷是线程是完全互不干扰的，也就是没有相互的协同工作。CyclicBarrier通过lock维护一个同步队列，再通过locks.newCondition获取到的condition对象维护一个等待队列，形成等待／通知机制，conditon的await和signal类似于object的wait和notify。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 4/4/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    CyclicBarrier cyclicBarrier;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrierWorker</span><span class="params">(CyclicBarrier cyclicBarrier,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        <span class="keyword">this</span>.index=index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 用户开始抽奖，持续"</span>+(index+<span class="number">1</span>)+<span class="string">"秒"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((index+<span class="number">1</span>) * <span class="number">1000</span>);</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"所有用户抽奖完毕，颁发奖项。为用户"</span> + Thread.currentThread().getName() + <span class="string">"颁奖。"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数启动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 4/3/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"5个用户开始抽奖"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread(<span class="keyword">new</span> CyclicBarrierWorker(cyclicBarrier,index)), <span class="string">"Thread-"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>个用户开始抽奖Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">18</span> CST <span class="number">2018</span></span><br><span class="line">Thread-<span class="number">0</span> 用户开始抽奖，持续<span class="number">1</span>秒Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">19</span> CST <span class="number">2018</span></span><br><span class="line">Thread-<span class="number">1</span> 用户开始抽奖，持续<span class="number">2</span>秒Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">19</span> CST <span class="number">2018</span></span><br><span class="line">Thread-<span class="number">2</span> 用户开始抽奖，持续<span class="number">3</span>秒Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">19</span> CST <span class="number">2018</span></span><br><span class="line">Thread-<span class="number">3</span> 用户开始抽奖，持续<span class="number">4</span>秒Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">19</span> CST <span class="number">2018</span></span><br><span class="line">Thread-<span class="number">4</span> 用户开始抽奖，持续<span class="number">5</span>秒Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">19</span> CST <span class="number">2018</span></span><br><span class="line">所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">4</span>颁奖。Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">24</span> CST <span class="number">2018</span></span><br><span class="line">所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">0</span>颁奖。Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">24</span> CST <span class="number">2018</span></span><br><span class="line">所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">1</span>颁奖。Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">24</span> CST <span class="number">2018</span></span><br><span class="line">所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">2</span>颁奖。Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">24</span> CST <span class="number">2018</span></span><br><span class="line">所有用户抽奖完毕，颁发奖项。为用户Thread-<span class="number">3</span>颁奖。Wed Apr <span class="number">04</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">24</span> CST <span class="number">2018</span></span><br></pre></td></tr></table></figure><h3 id="CyclicBarrier源码分析"><a href="#CyclicBarrier源码分析" class="headerlink" title="CyclicBarrier源码分析"></a>CyclicBarrier源码分析</h3><p>这里主要分析cyclicBarrier.await方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Main barrier code, covering the various policies.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">TimeoutException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  lock.lock();<span class="comment">//所有进入同步队列获取锁</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g.broken)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">      breakBarrier();</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = --count;<span class="comment">//计数器的值减1</span></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped，如果计数值已经为零代表所有的线程都已经进入了condition对象的等待队列，可以开始通知等待队列进入同步队列。</span></span><br><span class="line">      <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">        <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">          command.run();</span><br><span class="line">        ranAction = <span class="keyword">true</span>;</span><br><span class="line">        nextGeneration();<span class="comment">//内部会调用signalAll方法通知等待队列。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ranAction)</span><br><span class="line">          breakBarrier();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timed)</span><br><span class="line">          trip.await(); <span class="comment">//放到Conditon的等待队列里，同时释放锁，让其他线程执行await方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">          nanos = trip.awaitNanos(nanos);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">          breakBarrier();</span><br><span class="line">          <span class="keyword">throw</span> ie;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">          <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">          <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">          Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (g.broken)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (g != generation)<span class="comment">//说明执行了nextGeneration方法，计数器到了0</span></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">        breakBarrier();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 唤醒Conditon等待队列上的所有线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// 计数器值变成原始值，重新开始</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// generation被重新构造</span></span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个执行的过程，线程在调用了await方法之后，会通过lock方式上锁，然后线程将计数器的值减1。如果计数器的值到达0，说明conditon维护的等待队列已满，调用nextGeneration唤醒condition等待队列上的所有线程。加入到同步队列中，然后返回index，释放锁，之后同步队列中的节点线程就可以被唤醒了。如果线程的计数器没有到达0，那更简单，这个时候其他线程会调用condition的await方法进入等待队列。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里总结下两者的主要区别：</p><ol><li>CountDownLatch用完之后就不能再次使用了，CyclicBarrier用完之后可以再次使用，CyclicBarrier还可以做reset操作</li><li>CountDownLatch底层使用的是共享锁，CyclicBarrier底层使用的是ReentrantLock和这个lock的条件对象Condition</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CountDownLatch和CyclicBarrier都是给予AQS队列同步器实现的共享锁。&lt;/p&gt;
&lt;p&gt;CountDownLatch是单纯通过维持一个state的计数数值，这个数值在线程调用countDownLatch.countDown()的时候会减1，当计数器的值
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>理解Java线程中断</title>
    <link href="http://jianghao.wang/2018/%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/"/>
    <id>http://jianghao.wang/2018/理解Java线程中断/</id>
    <published>2018-03-22T03:09:30.000Z</published>
    <updated>2018-03-22T08:19:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道lock和synchronized在同步运用上的显著区别之一就是lock支持可中断，而synchronized不支持可中断。那么可中断实际上是怎么实现的，或者说我们怎么去理解中断这个概念。在lock的实现ReetrantLock中其实我们可以看到很多中断的运用。我们都知道死锁，作为一种独占的互斥锁，通过中断我们可以保证线程在阻塞的过程中可以响应中断，也就是结束当前线程对cpu的占用，通过向上层抛出异常来结束当前线程。</p><h3 id="ReetrantLock中断的应用"><a href="#ReetrantLock中断的应用" class="headerlink" title="ReetrantLock中断的应用"></a>ReetrantLock中断的应用</h3><p>我们看到ReetrantLock是如何实现中断的，这里主要看到三种中断的运用：</p><h4 id="selfInterrupt"><a href="#selfInterrupt" class="headerlink" title="selfInterrupt()"></a>selfInterrupt()</h4><p>ReetrantLock提供了lock和lockIntteruptibly两种上锁方式，那么他们有什么本质的区别，我们看到lock的一段源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">      acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们分析这段代码，lock默认非公平锁的情况下在tryAcquire(arg)时并不会排队，如果获取不到会去 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)进行排队，如果该方法返回ture则进入线程自我中断。那么我们可以看下这段代码是如何实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())<span class="comment">//这里我们检验了中断标志是否被改变通过currentThread().isInterrupted(true)方法</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 这里的interrupted是我们定义的一个中断变量，可以看到这只是一个临时变量。当我们在队列中循环cas的时候，如果没有收到中断请求，那么最终会在第一组判断内进入并获取到锁，这是的中断标志为false，不中断，那么线程获取到锁之后开始执行同步代码块。但是如果在循环cas获取锁的过程中感知到了中断，中断的标志会被置为true，然后直接返回上层执行selfInterrupt()，我们再看下selfInterrupt()执行了什么操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Convenience method to interrupt current thread.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Thread.currentThread().interrupt();<span class="comment">//当前线程执行自我中断</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>总结：我们可以在获取锁的过程中记录一个临时变量，如果检测到当前执行线程被别的线程进行了某中断操作。将该临时变量置为true然后触发线程的自我中断。</p><h4 id="抛出InterruptedException-异常"><a href="#抛出InterruptedException-异常" class="headerlink" title="抛出InterruptedException()异常"></a>抛出InterruptedException()异常</h4><p>线程在检测到被中断的请求时，不会立即响应这个中断请求，因为它仅仅是改变了中断标示位，但是并不会直接触发中断，是否进行中断还是看当前线程什么时候去检测这个中断标示位。一般在阻塞锁的设计中，我们在循环等待的过程中会进行中断标志位的检测，从而进行InterruptedException()异常的抛出。这个中断异常的过程就好比，你妈妈会交代你好好吃饭，但是具体你是不是要好好吃饭，还是得由你自己决定，也就是我们在设计一个线程的run方法时，同样可以自定义一个volatile类型的中断标志位，来同步记录这个系统的标志位，然后在我们想要抛出异常的时候来检测这个标志位的变化，从而抛出相应的异常。这里看一段lockInterruptibly中的处理：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Acquires in exclusive interruptible mode.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">               <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                   setHead(node);</span><br><span class="line">                   p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                   failed = <span class="keyword">false</span>;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())<span class="comment">//检测到中断标示位被修改为true的时候直接向上层抛出异常。</span></span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="中断的相关方法"><a href="#中断的相关方法" class="headerlink" title="中断的相关方法"></a>中断的相关方法</h3><p>这里记录一下几个关键的调用中断的方法：</p><ul><li>public void interrupt()<br>将调用者线程的中断状态设为true。</li><li>public boolean isInterrupted()<br>判断调用者线程的中断状态。</li><li>public static boolean interrupted<br>只能通过Thread.interrupted()调用。<br>它会做两步操作：返回<strong>当前线程</strong>的中断状态同时将当前线程的中断状态设为false。</li></ul><p>线程通过检查自身是否被中断来进行响应，线程通过方法isInterrupted()来进行判断是否被中断，也可以通过调用静态方法Thread.interrupted()对当前线程的中断标示位进行复位。如果该线程已经处于终结状态，那么即使该线程被中断过，在调用该线程该线程对象的isInterrrupted()时会返回false。</p><p>我们查看java的api可以看到，很多会抛出中断异常的方法都会在抛出异常之前，java虚拟机首先将该线程的中断标示位清除。那么此时我们调用isInterrrupted()时会返回false。</p><h3 id="中断异常代码示例"><a href="#中断异常代码示例" class="headerlink" title="中断异常代码示例"></a>中断异常代码示例</h3><p>我们创建两个线程sleepThread和busyThread，第一个不停的执行休眠，第二个不停的执行循环代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Interrupted;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 3/22/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interrupted</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//新建一个睡眠线程</span></span><br><span class="line">        Thread sleepThread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"sleepThread"</span>);</span><br><span class="line">        <span class="comment">//新建一个忙碌的线程</span></span><br><span class="line">        Thread busyThread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"busyThread"</span>);</span><br><span class="line">        sleepThread.start();</span><br><span class="line">        busyThread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);<span class="comment">//线程休眠十秒</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        sleepThread.interrupt();</span><br><span class="line">        busyThread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"sleepThread的中断标志为："</span>+sleepThread.isInterrupted());</span><br><span class="line">        System.out.println(<span class="string">"busyThread的中断标志为："</span>+busyThread.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果为：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at Interrupted.Interrupted<span class="formula">$1.run(Interrupted.java:14)</span></span><br><span class="line"><span class="formula">at java.lang.Thread.run(Thread.java:745)</span></span><br><span class="line"><span class="formula">sleepThread的中断标志为：false</span></span><br><span class="line"><span class="formula">busyThread的中断标志为：true</span></span><br></pre></td></tr></table></figure><p>可以看到，抛出异常的线程的中断标示位被清除了，但是一直忙碌的线程因为并没有去判断中断标示位，所以即使中断标示位已经是true也不会执行中断操作。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>线程中断是一种是可以理解为一个线程对另一个线程做出了一个标示位的改变，通过触发线程中断会将中断标示位置为true，被中断的线程可以选择忽略这个标志，也可以选择在某个时刻校验标志位抛出异常，同时将标志位清除。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道lock和synchronized在同步运用上的显著区别之一就是lock支持可中断，而synchronized不支持可中断。那么可中断实际上是怎么实现的，或者说我们怎么去理解中断这个概念。在lock的实现ReetrantLock中其实我们可以看到很多中断的运用。我们
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>ReetrantLock实现源码</title>
    <link href="http://jianghao.wang/2018/ReetrantLock%E5%AE%9E%E7%8E%B0%E6%BA%90%E7%A0%81/"/>
    <id>http://jianghao.wang/2018/ReetrantLock实现源码/</id>
    <published>2018-03-19T12:52:17.000Z</published>
    <updated>2018-03-21T09:21:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>ReetrantLock是基于AQS（AbtractQueuedSynchronizer）实现的。本文将逐渐展开分析ReetrantLock的实现机制以及使用场景。</p><h3 id="AQS实现源码"><a href="#AQS实现源码" class="headerlink" title="AQS实现源码"></a>AQS实现源码</h3><p> AQS提供了一个框架，用于实现阻塞锁和相关的同步器(semaphores, events等)，它们依赖于先入先出(FIFO)等待队列。这个类被设计成大多数类型的同步器的基础，它们依赖于单个原子<strong>{@ code int}</strong>值来表示同步状态。子类必须定义更改此状态的受保护方法（重写相关的方法），并重新定义该状态值在实现类中的定义。考虑到这些，这个类中的其他方法需要控制所有队列的进出和阻塞机制。子类可以维护其他的状态字段，但是只有通过使用方法<strong>{@ link # get state}、{@ link # set state}和{@ link # compare和set state}</strong>的原子更新<strong>{@ code int}</strong>值，才会对同步进行跟踪。</p><p>AQS框架要么支持默认的独占模式，要么支持共享模式。当以独占模式获得时，试图通过其他线程获取的尝试无法成功。多个线程的共享模式可以(但不需要)成功。共享模式获得成功时，下一个等待线程(如果存在)还必须确定它是否也能获得。在不同模式中等待的线程共享相同的FIFO队列。通常，实现子类只支持其中一种模式，但都可以在<strong>{@ link Read Write Lock}</strong>中发挥作用。支持唯一或仅共享模式的子类不必定义支持未使用模式的方法。本文分析的ReetrantLock是一种独占模式的实现，同一时间只能有一个线程执行同步代码块，其它线程将被阻塞在队列中，等待state也就是锁释放之后从队列中释放出来执行代码块。</p><h4 id="AQS的使用"><a href="#AQS的使用" class="headerlink" title="AQS的使用"></a>AQS的使用</h4><p>使用这个类作为一个同步器的基础，通过state的暴露方法来同步修改状态，同时需要定义下列方法：</p><ul><li><strong>{@link #tryAcquire}</strong>，获取锁，cas修改state状态。</li><li><strong>{@link #tryRelease}</strong>，释放锁，修改state状态同时将线程移除队列。</li><li><strong>{@link #tryAcquireShared}</strong>，获取共享锁。</li><li><strong>{@link #tryReleaseShared}</strong>，释放共享锁。</li><li><strong>{@link #isHeldExclusively}</strong>，锁是否被独占。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> Acquire:</span><br><span class="line">     <span class="keyword">while</span> (!tryAcquire(arg)) &#123;</span><br><span class="line">        &lt;em&gt;enqueue thread if it is not already queued&lt;/em&gt;;</span><br><span class="line">        &lt;em&gt;possibly block current thread&lt;/em&gt;;</span><br><span class="line">     &#125;</span><br><span class="line"> Release:</span><br><span class="line">     <span class="keyword">if</span> (tryRelease(arg))</span><br><span class="line">        &lt;em&gt;unblock the first queued thread&lt;/em&gt;;</span><br><span class="line"> &lt;/pre&gt;</span><br><span class="line">(Shared mode is similar but may involve cascading signals.)</span><br></pre></td></tr></table></figure><p>这里给一个独占锁的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Our internal helper class</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Reports whether in locked state</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Acquires the lock if state is zero</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Releases the lock by setting state to zero</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">      <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">      setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">      setState(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Provides a Condition</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject(); &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Deserializes properly</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">      s.defaultReadObject();</span><br><span class="line">      setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// The sync object does all the hard work. We just forward to it.</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>                </span>&#123; sync.acquire(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>          </span>&#123; <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>              </span>&#123; sync.release(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> sync.newCondition(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span>         </span>&#123; <span class="keyword">return</span> sync.isHeldExclusively(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sync.hasQueuedThreads(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="AQS队列同步器提供的接口分析"><a href="#AQS队列同步器提供的接口分析" class="headerlink" title="AQS队列同步器提供的接口分析"></a>AQS队列同步器提供的接口分析</h4><p>同步器提供的可供重写的方法：</p><table><thead><tr><th style="text-align:center">方法名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">protected int tryAcquireShared(int arg)</td><td style="text-align:left">共享式获取同步状态，返回&gt;=0的值，表示获取成功，反之获取失败。</td></tr><tr><td style="text-align:center">protected boolean tryReleaseShared(int arg)</td><td style="text-align:left">共享式释放同步状态。</td></tr><tr><td style="text-align:center">protected boolean isHeldExclusively()</td><td style="text-align:left">当前同步器是否在独占模式下被线程占用，一般实现会判断当前线程是否独占锁。</td></tr><tr><td style="text-align:center">protected boolean tryAcquire(int arg)</td><td style="text-align:left">独占式获取锁，该方法为获取锁操作方法。公平锁和非公平锁有不同的实现，非公平锁直接调用同步器底层实现。公平锁会先判断当前队列是否有线程在等待锁。</td></tr><tr><td style="text-align:center">protected  boolean tryRelease(int arg)</td><td style="text-align:left">独占式释放同步锁，其它队列中等待的线程将有机会获取到锁。</td></tr></tbody></table><p>我们可以根据这些可以重写的方法去自定义同步组件，类似公平锁和非公平锁的定义，实际上是对FairSync和NonfairSync对Sync的tyAcquire方法进行了不同的实现。另外队列同步器还提供了一些模板方法：</p><table><thead><tr><th style="text-align:center">方法名称</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">void acquire(int arg)</td><td>独占式获取同步状态，如果获取同步状态成功，进入同步块否则进入等待队列，然后开始循环等待当前线在等待队列中获取到锁，只会记录中断状态不会触发中断。这个方法会调用到tryAcquire方法，可以被自定义同步器重写。</td></tr><tr><td style="text-align:center">boolean tryAccquireNano(int arg,long nanos)</td><td>增加了超时时间限制，如果当前线程在限制的时间内没有获取到锁的话就返回false,否则返回true。</td></tr><tr><td style="text-align:center">void accqureInrruptibly(int arg)</td><td>支持中断模式，当前在，相较于acquire方法该方法同样会进行循环等待队列中获取到锁。但是当它可以响应中断，当其他线程中断当前线程的时候，会抛出InterruptException异常。</td></tr><tr><td style="text-align:center">Collection<thread> getQueuedThreads()</thread></td><td>获取等待在同步队列上的线程集合。</td></tr><tr><td style="text-align:center">boolean tryAccquireSharedNano(int arg,long nanos)</td><td>同样的，我们为该方法在共享锁的前提下增加了超时时间。</td></tr><tr><td style="text-align:center">void acquireShared(int arg)</td><td>共享式获取同步状态，主要区别于独占式获取同步状态，这种方式的特别之处在于同一时间可以有多个线程获得同步状态。</td></tr><tr><td style="text-align:center">void accqureSharedInrruptibly(int arg)</td><td>该方法响应中断。</td></tr><tr><td style="text-align:center">void releasShared(int arg)</td><td>共享锁释放同步状态。</td></tr></tbody></table><p>队列同步器的方法主要分为三类：</p><ul><li><strong>独占式获取与释放同步状态</strong></li><li><strong>共享式获取与释放同步状态</strong></li><li><strong>查询同步队列中线程的等待情况</strong></li></ul><p>同样的，我们提供一个共享锁的实例，类似java.util.concurrent.CountDownLatch CountDownLatch的一种实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSignalled</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> getState() != <span class="number">0</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> ignore)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> isSignalled() ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> ignore)</span> </span>&#123;</span><br><span class="line">      setState(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSignalled</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sync.isSignalled(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span>         </span>&#123; sync.releaseShared(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="ReetrantLock主要方法"><a href="#ReetrantLock主要方法" class="headerlink" title="ReetrantLock主要方法"></a>ReetrantLock主要方法</h3><p>我们通常会用定义一个ReetrantLock，通过调用lock方法和unlock方法来对同步代码块进行加锁和释放锁。我们先来看一下lock方法的调用栈。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment">    * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment">    * given fairness policy.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">       sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看到ReetrantLock提供了两种构造方法，一种会默认初始化一个非公平锁，另一个可以指定公平锁或者非公平锁。公平锁和非公平锁中都有对应的加锁和释放锁实现。观察调用栈可以看到两者的区别。</p><h4 id="lock方法调用公平锁和非公平锁"><a href="#lock方法调用公平锁和非公平锁" class="headerlink" title="lock方法调用公平锁和非公平锁"></a>lock方法调用公平锁和非公平锁</h4><p>我们可以通过源代码看到公平锁和非公平锁的实现都继承了Sync类，实际上这个类是对AQS类的一种独占锁的实现。所以我们最终实现的ReetrantLock是独占的，可重入的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Sync object for non-fair locks</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">        * acquire on failure.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))<span class="comment">//非公平锁调用时就会给一次竞争的机会，如果后来的线程刚好在锁释放的时候去获取锁，那么即使等待队列中还有其它的线程也会被直接忽略，这样的话对队列中等待的线程是不公平的。</span></span><br><span class="line">               setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               acquire(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> nonfairTryAcquire(acquires);<span class="comment">//实际上是直接调用了AQS中的nonfairTryAcquire(acquires)方法。这个方法是不会维持一个等待竞争锁的线程队列的。</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>再看下公平锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sync object for fair locks</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            acquire(<span class="number">1</span>);<span class="comment">//公平锁线程在获取锁的时候直接加入队列，等待前面的线程被执行完之后顺序调用。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">         * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们在进入acquire方法，可以看到非公平锁实际上是直接调用的Sync中nonfairTryAcquire的实现，源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<span class="comment">//ReetrantLock是可重入锁，同一个线程可以再次进入，但是会将state作累加。</span></span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>而公平锁调用的是自己实现的tryAcquire(int acquires)方法，上面关于公平锁的静态类中可以看到。对比之后发现公平锁在判断的时候多了一句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<span class="comment">//这个增加的判断也是保证公平</span></span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;<span class="comment">//这里是通过cas去写state的状态也就是去占用锁</span></span><br><span class="line">                    setExclusiveOwnerThread(current);<span class="comment">//成功获取锁之后记录独占锁线程为当前线程</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>hasQueuedPredecessors()的实现如下，如果当前线程在队列中还有前置线程返回true，不获得准入条件。如果当前线程处于队列的头部，或者队列为空，则返回false，获得准入条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @return &#123;@code true&#125; if there is a queued thread preceding the</span></span><br><span class="line"><span class="comment">     *         current thread, and &#123;@code false&#125; if the current thread</span></span><br><span class="line"><span class="comment">     *         is at the head of the queue or the queue is empty</span></span><br><span class="line"><span class="comment">     * @since 1.7</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">        <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">        <span class="comment">// thread is first in queue.</span></span><br><span class="line">        Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结一下，公平锁和非公平锁相比，保证了FIFO的原则，但是代价是进行了大量的线程切换。而非公平锁虽然可能造成线程 “饥饿”，但是极少的线程切换，同样也保证了更大的吞吐量。</p><h3 id="tryLock-方法和lock方法"><a href="#tryLock-方法和lock方法" class="headerlink" title="tryLock()方法和lock方法"></a>tryLock()方法和lock方法</h3><p>看一下tryLock()方法，实际上调用Sync的nonfairTryAcquire方法，该方法相较于lock方法精简了一些。对比，一下，少了一段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<span class="comment">//这里如果获取失败会尝试将线程加入等待队列</span></span><br><span class="line">         selfInterrupt();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>tryLock()方法默认是非公平方式去调用的，只是一次简单的cas加锁尝试。如果失败了线程不会再被执行，拥有再次竞争锁的机会。</li><li>lock()方法的非公平方式如果获取锁失败会将当前线程加入等待队列。如果失败了线程等待之后还有再次获得锁的机会。</li></ul><p>这样public boolean tryLock(long timeout, TimeUnit unit)，这个方法也就更容易理解了，增加了一个timeout时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));<span class="comment">//默认unit.toNanos(timeout)时间内超时，首先会将这个线程加入队列，然后进行循环自旋，如果时间内线程没有排到队首，会返回一个false。</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>sync.tryAcquireNanos(1, unit.toNanos(timeout))，该方法具体实现如下，咋一看代码很容易将其误认为是在时间段内不断cas自旋去获取锁，如果时间内失败返回false。实际上是会将当前的线程加入等待队列的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);<span class="comment">//会将该线程作为一个node加入到等待队列。Node.EXCLUSIVE定义为独占模式。</span></span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;<span class="comment">//这里开始循环等待加入的线程排到队首，可能会在时间段内排到也可能排不到。</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面是addWaiter(Node mode)，就是生成一个独占的线程节点加入到等待队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">       Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">       <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">       Node pred = tail;</span><br><span class="line">       <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">           node.prev = pred;</span><br><span class="line">           <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">               pred.next = node;</span><br><span class="line">               <span class="keyword">return</span> node;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       enq(node);</span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="unlock方法释放锁"><a href="#unlock方法释放锁" class="headerlink" title="unlock方法释放锁"></a>unlock方法释放锁</h4><p>调用unlock方法，实际上调用的是AQS中的release(1)方法，这个只会把state的值-1，源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中tryRelease(arg)方法执行如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">  <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">  <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//如果当前state保留的值已经变为零，锁释放成功</span></span><br><span class="line">    free = <span class="keyword">true</span>;</span><br><span class="line">    setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  setState(c);</span><br><span class="line">  <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="InterruptedException可中断获取锁"><a href="#InterruptedException可中断获取锁" class="headerlink" title="InterruptedException可中断获取锁"></a>InterruptedException可中断获取锁</h4><p>ReetrantLock提供了一种可中断获取锁的方式，也是实现了定义在lock中的接口，该方法很容易理解，在获取锁的过程中会响应中断，那么这种方式和普通的lock方式有什么本质区别。我们看一下这种方式的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Acquires in exclusive interruptible mode.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">      <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">              <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                  setHead(node);</span><br><span class="line">                  p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                  failed = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                  parkAndCheckInterrupt())</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();<span class="comment">//这里会响应中断，会直接抛异常给上层，在lock中只是维护了一个状态值，进行了状态值的修改，并不会跑出异常到上层。最终回返回false</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (failed)</span><br><span class="line">              cancelAcquire(node);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>结论：ReentrantLock的中断和非中断加锁模式的区别在于：线程尝试获取锁操作失败后，在等待过程中，如果该线程被其他线程中断了，它是如何响应中断请求的。lock方法会忽略中断请求，继续获取锁直到成功；而lockInterruptibly则直接抛出中断异常来立即dsa响应中断，由上层调用者处理中断。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要对ReetrantLock的源码进行了一些分析，ReetrantLock是基于AQS实现的一种独占，可重入的锁，可以自己的定义公平锁或者非公平锁。ReetrantLock通过维护AQS类内部的一个volatile state变量来记录锁的状态，通过cas去竞争，同时记录当前持有锁的线程。支持可重入，当当前持有该锁的线程尝试再次进入的时候会通过准入条件，并将state增加1。实际上公平锁和非公平锁主要是当前线程是否会进入线程等待的队列，AQS在底层维护了一个线程的等待队列，基于先进先出的原则去调度这些等待获取锁的队列。如果非公平锁的话直接调用lock去加锁，可能面临失败的情况，如果失败了，就是一次cas自旋失败，同步代码块并不会被执行。如果用trylock方法的话可以尝试增加一个超时时间，会将当前的线程加入到等待队列中然后在超市时间内等待被调度，这种场景在某些情况下还是很适用的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ReetrantLock是基于AQS（AbtractQueuedSynchronizer）实现的。本文将逐渐展开分析ReetrantLock的实现机制以及使用场景。&lt;/p&gt;
&lt;h3 id=&quot;AQS实现源码&quot;&gt;&lt;a href=&quot;#AQS实现源码&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>AtomicInteger源码分析</title>
    <link href="http://jianghao.wang/2018/AtomicInteger%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://jianghao.wang/2018/AtomicInteger源码分析/</id>
    <published>2018-03-16T10:23:32.000Z</published>
    <updated>2018-03-16T10:23:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>在阅读ConcurrentHashMap源码的过程中，频繁使用了volatile+无锁的方式来处理并发，需要对AtomicInteger源码有更深的了解。将这个模块独立抽离出来形成更深刻的理解。</p><h3 id="AutomicInteger变量"><a href="#AutomicInteger变量" class="headerlink" title="AutomicInteger变量"></a>AutomicInteger变量</h3><p>AutomicInteger作为一个原子操作类，定义了一些变量：</p><ul><li><p>private static final Unsafe unsafe = Unsafe.getUnsafe()，定义了一个usafe类对象，主要对native方法进行调用。</p></li><li><p>private static final long valueOffset，这个值可能会被误以为是默认值，查看部分源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>了解过java虚拟机类加载机制的，类加载触发的其中一个条件是getstatic，这样其他方法在每次访问到这个值的时候都会执行一下静态代码块获取到内存中最新的值。这个值是作为内存中的值，我们在编写程序的时候会存一份拷贝在栈中，通过对比这个值和拷贝值是否一致来决定是否更新新值到内存，也就是这次操作是否成功。</p></li><li><p>private volatile int value，上面通过静态代码块儿去加载的就是内存中value的最新值。</p></li></ul><h3 id="AutomicInteger原子操作"><a href="#AutomicInteger原子操作" class="headerlink" title="AutomicInteger原子操作"></a>AutomicInteger原子操作</h3><p>这里我们通过自己写复杂操作count++对比通过调用AutomicInteger的api，可以对比结果是否保证了正确的输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CasNoLock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 3/16/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger atomicInteger=<span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Thread&gt; threadArrayList=<span class="keyword">new</span> ArrayList&lt;Thread&gt;(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5000</span>;i++)&#123;</span><br><span class="line">                        count();</span><br><span class="line">                        countAtomicInteger();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threadArrayList.add(thread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Thread t:threadArrayList)&#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Thread t:threadArrayList)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"非原子操作累加结果："</span>+count);</span><br><span class="line">        System.out.println(<span class="string">"原子操作累加结果："</span>+atomicInteger.intValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非原子类操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原子类操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countAtomicInteger</span><span class="params">()</span></span>&#123;</span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">非原子操作累加结果：461539</span><br><span class="line">原子操作累加结果：50000</span><br></pre></td></tr></table></figure><h3 id="AutomicInteger-API分析"><a href="#AutomicInteger-API分析" class="headerlink" title="AutomicInteger API分析"></a>AutomicInteger API分析</h3><p>我们查看下atomicInteger.getAndIncrement()在usafe中的实现，实际上它是调用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 查看getAndAddInt方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>compareAndSwapInt(var1, var2, var5, var5 + var4)</strong>换成<strong>compareAndSwapInt(obj, offset, expect, update)</strong>比较清楚，意思就是如果<code>obj</code>内的<code>value</code>和<code>expect</code>相等，就证明没有其他线程改变过这个变量，那么就更新它为<code>update</code>，如果这一步的<code>CAS</code>没有成功，那就采用自旋的方式继续进行<code>CAS</code>操作，取出乍一看这也是两个步骤了啊，其实在<code>JNI</code>里是借助于一个<code>CPU</code>指令完成的。所以还是原子操作。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>AutomicInteger源码最终是通过<strong>usafe.compareAndSwapInt(obj, offset, expect, update)</strong>函数实现cas原子操作的。cas中最重要的三个值，volatile value（内存中最新值），expect（拷贝值）和update（更新值），在函数中分别对应offset，expect，和update入参。对这个关键方法的了解可以帮助深入阅读ConcurrentHashMap源码，jdk1.8中大量运用cas+synchronized关键字来实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在阅读ConcurrentHashMap源码的过程中，频繁使用了volatile+无锁的方式来处理并发，需要对AtomicInteger源码有更深的了解。将这个模块独立抽离出来形成更深刻的理解。&lt;/p&gt;
&lt;h3 id=&quot;AutomicInteger变量&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap实现源码</title>
    <link href="http://jianghao.wang/2018/ConcurrentHashMap%E5%AE%9E%E7%8E%B0%E6%BA%90%E7%A0%81/"/>
    <id>http://jianghao.wang/2018/ConcurrentHashMap实现源码/</id>
    <published>2018-03-16T07:24:07.000Z</published>
    <updated>2018-06-20T02:29:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>在阅读源码的过程中，推荐一个idea的翻译插件<a href="https://github.com/YiiGuxing/TranslationPlugin" target="_blank" rel="noopener">TranslationPlugin</a>，方便阅读源码的注释。本篇主要介绍ConcurrentHashMap在JDK1.8中的实现。</p><h3 id="ConcurrentHashMap静态常量"><a href="#ConcurrentHashMap静态常量" class="headerlink" title="ConcurrentHashMap静态常量"></a>ConcurrentHashMap静态常量</h3><p>ConcurrentHashMap在设计的过程中涉及到扩容和容器收缩等策略，在静态常量中定义了一些比较关键的阈值，这里介绍几个主要的：</p><ul><li><p>private static final int DEFAULT_CAPACITY=16，默认表大小，默认初始化的时候没有传递capacity和concurrentlevel会提供16个hash桶进行映射。否则会根据capacity或者concurrentlevel来确定size的值。</p></li><li><p>private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30，最大表容量，扩容时会判断最大容量。</p></li><li><p>static final int MIN_TREEIFY_CAPACITY = 64，链表树化时的最小表（数组）容量。在列表树化的时候会检测当前的表（数组）容量，如果小于这个数值会首先进行扩容，扩容之后再进行树化。n为表（数组）长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">              tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>private static final float LOAD_FACTOR = 0.75f，装载因子，当数组中已经映射的hash桶已经达到百分之75以上时会自动扩容。代码中可以用 <strong>{@code n - (n &gt;&gt;&gt; 2)}</strong>代替运算，n为表（数组）的长度。</p></li><li><p>static final int TREEIFY_THRESHOLD = 8，链表调整为tree阈值。当链表中的节点数量超过这个数值的时候会调整为树结构。这个数量至少为2最好是大于8。</p></li><li><p>static final int UNTREEIFY_THRESHOLD = 6，当链表的长度小于这个值的时候自动调节树结构为列表结构。</p></li></ul><h3 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h3><p>分析一下数组的扩容方法tryPresize，源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tries to presize table to accommodate the given number of elements.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> size number of elements (doesn't need to be perfectly accurate)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">     <span class="comment">//判断是否为最大超过最大容量的八倍，超过了直接扩容到最大容量。最大容量为1&lt;&lt;30</span></span><br><span class="line">           tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">     <span class="comment">//这里只需要提供一个大概的size，tableSizeFor函数会根据当前的size值匹配一个最近的表大小值，因为我们规定表的大小只能是2的倍数（为了保证在取模进行hash运算的时候可以用（hashcode &amp; n-1） ）</span></span><br><span class="line">       <span class="keyword">int</span> sc;</span><br><span class="line">       <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;</span><br><span class="line">           <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="comment">//如果当前table并没有被初始化，例如在putAll方法中传入一个map，首先进行table的初始化tab</span></span><br><span class="line">               n = (sc &gt; c) ? sc : c;</span><br><span class="line">               <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                 <span class="comment">//这里采用了循环cas来替换sc的值，最后将sizeCtl赋值为sc的值</span></span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                           <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                           Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                           table = nt;</span><br><span class="line">                           sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                       sizeCtl = sc;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">               <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">               <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                   Node&lt;K,V&gt;[] nt;</span><br><span class="line">                   <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                       sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                       transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                       transfer(tab, nt);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                   transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>再看一下主要的putVal方法，源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">int</span> hash = spread(key.hashCode());<span class="comment">//获取hash映射桶，对hashcode做了扰动保证散列的均匀度</span></span><br><span class="line">       <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">           Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">           <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">               tab = initTable();<span class="comment">//如果当前未被初始化过，进行初始化。</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                            <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                   <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin,采用无锁的方式，如果无锁置换成功就直接break出循环，代表成功插入。如果失败，表明有竞争发生，继续执行后续代码，会进行插入。</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)<span class="comment">//表明当前表正在进行扩容。检测到当前映射节点正在进行扩容的时候，当前线程加入帮忙进行扩容工作。</span></span><br><span class="line">               tab = helpTransfer(tab, f);</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               V oldVal = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">synchronized</span> (f) &#123;<span class="comment">//相当于锁住一条链表，这里有一个偏向锁到轻量级锁到重量级锁的升级过程</span></span><br><span class="line">                   <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                           binCount = <span class="number">1</span>;</span><br><span class="line">                           <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                               K ek;</span><br><span class="line">                               <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                   ((ek = e.key) == key ||</span><br><span class="line">                                    (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                   oldVal = e.val;</span><br><span class="line">                                   <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                       e.val = value;</span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                               Node&lt;K,V&gt; pred = e;</span><br><span class="line">                               <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                   pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                             value, <span class="keyword">null</span>);</span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) <span class="comment">//如果已经被树化，以红黑树的方式增加一个节点。</span></span><br><span class="line">                           Node&lt;K,V&gt; p;</span><br><span class="line">                           binCount = <span class="number">2</span>;</span><br><span class="line">                           <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                          value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                               oldVal = p.val;</span><br><span class="line">                               <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                   p.val = value;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<span class="comment">//如果达到树化的阈值，将链表进行树化。</span></span><br><span class="line">                       treeifyBin(tab, i);</span><br><span class="line">                   <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                       <span class="keyword">return</span> oldVal;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    从ConcurrentHashMap的多个版本演变中，最终java9采用了synchronized和cas来实现，之后会抽写一篇对几种版本迭代过程中性能的优异比较。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在阅读源码的过程中，推荐一个idea的翻译插件&lt;a href=&quot;https://github.com/YiiGuxing/TranslationPlugin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TranslationPlugin&lt;/a&gt;，方便阅读
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>面试记录</title>
    <link href="http://jianghao.wang/2018/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <id>http://jianghao.wang/2018/面试记录/</id>
    <published>2018-03-14T10:24:15.000Z</published>
    <updated>2018-12-19T03:23:50.265Z</updated>
    
    <content type="html"><![CDATA[<h4 id="搜车的手写代码"><a href="#搜车的手写代码" class="headerlink" title="搜车的手写代码"></a>搜车的手写代码</h4><p>面试需要手写一段死锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SynchronizedLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 3/14/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MythreadA</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    Object a;</span><br><span class="line">    Object b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MythreadA</span><span class="params">(Object a,Object b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a=a;</span><br><span class="line">        <span class="keyword">this</span>.b=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (a)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程A正在等待获取下个对象的锁，已经获取到对象锁："</span>+a);</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (b)&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程A同时获取到对象A和B的锁"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>触发线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SynchronizedLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 3/14/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedLockMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object a=<span class="keyword">new</span> Object();</span><br><span class="line">        Object b=<span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MythreadA(a,b)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MythreadA(b,a)).start();<span class="comment">//调换一下ab顺序保证死锁发生的条件，否则不会发生死锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2018-10-24-天猫笔试"><a href="#2018-10-24-天猫笔试" class="headerlink" title="2018-10-24 天猫笔试"></a>2018-10-24 天猫笔试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//评测题目: 1.利用多线程有序打印（假定打印为IO阻塞耗时操作）出0~100的所有自然数(使用线程池编码）</span></span><br><span class="line"><span class="number">2</span>.利用数组实现栈的push和pop操作，以及min函数，得到栈的最小元素；</span><br><span class="line">时间：<span class="number">40</span>分钟</span><br><span class="line">说明：如API记不清楚可使用伪代码示意既可</span><br><span class="line">Class ThreadFirst implement Runable&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">ThreadPrint(<span class="keyword">int</span> from ,<span class="keyword">int</span> end)&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//先分三个线程打印吧</span></span><br><span class="line">    <span class="keyword">while</span>(PrintData.count%<span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//第一次打印的线程</span></span><br><span class="line">            printData(from,end);</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Class ThreadSecond implement Runable&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">ThreadPrint(<span class="keyword">int</span> from ,<span class="keyword">int</span> end)&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//先分三个线程打印吧</span></span><br><span class="line">    <span class="keyword">while</span>(PrintData.count%<span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//第一次打印的线程</span></span><br><span class="line">            printData(from,end);</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Class ThreadThird implement Runable&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">ThreadPrint(<span class="keyword">int</span> from ,<span class="keyword">int</span> end)&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//先分三个线程打印吧</span></span><br><span class="line">    <span class="keyword">while</span>(PrintData.count%<span class="number">3</span> == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">//第一次打印的线程</span></span><br><span class="line">            printData(from,end);</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Class PrintData&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> ThreadFirst(<span class="number">0</span>,<span class="number">30</span>).start();</span><br><span class="line">        <span class="keyword">new</span> ThreadFirst(<span class="number">31</span>,<span class="number">60</span>).start();</span><br><span class="line">        <span class="keyword">new</span> ThreadFirst(<span class="number">60</span>,<span class="number">100</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个最小的栈值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Integer&gt; data=<span class="keyword">new</span> ArrayList&lt;Integer&gt;&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; minIntegers= <span class="keyword">new</span> ArrayList&lt;Integer&gt;&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">        data.add(num);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(minIntegers.size() ==<span class="number">0</span>)&#123;</span><br><span class="line">        minIntegers.add(<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//保存一下最小值的索引</span></span><br><span class="line">            <span class="keyword">int</span> min =minOfStack();</span><br><span class="line">            <span class="keyword">if</span>(num &lt; min)&#123;</span><br><span class="line">            <span class="comment">//如果在push的时候找到了更小的值保存到最小值的列表中</span></span><br><span class="line">minIntegers.add(data.size()-<span class="number">1</span>);      </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果data pop完抛出异常</span></span><br><span class="line">        <span class="keyword">if</span>(data.size()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"栈已经没有元素"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//在pop的时候需要同步pop一下最小列表里面的索引值，什么时候出栈？</span></span><br><span class="line">        <span class="keyword">int</span> popIndex=data.size() -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> minIndex = minIntegers.get(minIntegers.size()-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(popIndex == minIndex)&#123;</span><br><span class="line">        <span class="comment">//粗zhan</span></span><br><span class="line">            minIntegers.remove(minIntegers.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minOfStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//判空</span></span><br><span class="line">        <span class="keyword">if</span>(data.size()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"zhan元素异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每次取zhan顶的元素</span></span><br><span class="line">      <span class="keyword">int</span> minIndex = minIntegers.get(minIntegers.size-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> data.get(minIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="蚂蚁金服面试两个线程交替打印1-100的整数"><a href="#蚂蚁金服面试两个线程交替打印1-100的整数" class="headerlink" title="蚂蚁金服面试两个线程交替打印1-100的整数"></a>蚂蚁金服面试两个线程交替打印1-100的整数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.study.PrintData;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这道题可以通过等待通知(wait/notify +synchronized通知模型)机制或者volatile关键字去控制线程的执行顺序</span></span><br><span class="line"><span class="comment"> * 本质上是利用java共享内存模型进行通信</span></span><br><span class="line"><span class="comment"> * 这里先给一种循环cas的解法</span></span><br><span class="line"><span class="comment"> * Created by yqz on 12/18/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String str=<span class="string">"alipay"</span>;</span><br><span class="line">    <span class="comment">//定义一个线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> threadCount=<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//记录需要打印的次数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> printCount=<span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadA()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadB()).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.study.PrintData;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 12/18/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//无锁，循环cas控制</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (PrintData.threadCount % <span class="number">2</span> == <span class="number">0</span> )&#123;</span><br><span class="line">                <span class="comment">//sout</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+(<span class="number">101</span>-PrintData.printCount));</span><br><span class="line">                PrintData.threadCount--;</span><br><span class="line">                PrintData.printCount--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(PrintData.printCount==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.study.PrintData;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 12/18/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过volatile控制</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (PrintData.threadCount % <span class="number">2</span> == <span class="number">1</span> )&#123;</span><br><span class="line">                <span class="comment">//sout</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+(<span class="number">101</span>-PrintData.printCount));</span><br><span class="line">                <span class="comment">//这里重新加回去volatile可见性保证通知到A线程</span></span><br><span class="line">                PrintData.threadCount++;</span><br><span class="line">                <span class="comment">//打印了一次之后减少一次</span></span><br><span class="line">                PrintData.printCount--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(PrintData.printCount==<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.study.PrintABC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先写的第二道，第一道没时间，暂时写个方式，那里的判断好像没有什么必要注释掉</span></span><br><span class="line"><span class="comment"> * Created by yqz on 12/18/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reverse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String str=<span class="string">"alipayy"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reverse(str);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="comment">//logger</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String str)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(str))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"字符串不能为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] chars=str.toCharArray();</span><br><span class="line">        <span class="comment">//可以取一下中间的位置，然后两边互换一下位置,但是数组不好换位置，需要一个中间的变量进行轮转</span></span><br><span class="line">        <span class="keyword">int</span> length =str.length();</span><br><span class="line">        <span class="keyword">int</span> midIndex=length/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> canquyu=length%<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/*if(canquyu==0)&#123;//偶数长度都要互换</span></span><br><span class="line"><span class="comment">            for(int i=0;i&lt;midIndex;i++)&#123;</span></span><br><span class="line"><span class="comment">                char mid =chars[i];</span></span><br><span class="line"><span class="comment">                chars[i]=chars[length-i-1];//执行赋值的过程</span></span><br><span class="line"><span class="comment">                chars[length-i-1]=mid;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;else&#123;//基数中间的不用还</span></span><br><span class="line"><span class="comment">            for(int i=0;i&lt;midIndex;i++)&#123;</span></span><br><span class="line"><span class="comment">                char mid =chars[i];</span></span><br><span class="line"><span class="comment">                chars[i]=chars[length-i-1];//执行赋值的过程</span></span><br><span class="line"><span class="comment">                chars[length-i-1]=mid;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;midIndex;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> mid =chars[i];</span><br><span class="line">            chars[i]=chars[length-i-<span class="number">1</span>];<span class="comment">//执行赋值的过程</span></span><br><span class="line">            chars[length-i-<span class="number">1</span>]=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            System.out.print(chars[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;搜车的手写代码&quot;&gt;&lt;a href=&quot;#搜车的手写代码&quot; class=&quot;headerlink&quot; title=&quot;搜车的手写代码&quot;&gt;&lt;/a&gt;搜车的手写代码&lt;/h4&gt;&lt;p&gt;面试需要手写一段死锁：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;ta
      
    
    </summary>
    
    
      <category term="面试记录" scheme="http://jianghao.wang/tags/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Java位操作</title>
    <link href="http://jianghao.wang/2018/Java%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    <id>http://jianghao.wang/2018/Java位操作/</id>
    <published>2018-03-13T11:56:58.000Z</published>
    <updated>2018-03-14T01:56:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>在阅读源码的过程中，发现很多地方会使用到位操作来提高计算的效率。我们很常见的取模操作，在源码中都会通过与操作来完成。了解和灵活运用位运算可以帮助我们快速理解源码，写出较为简洁的代码。</p><h3 id="位操作运算符"><a href="#位操作运算符" class="headerlink" title="位操作运算符"></a>位操作运算符</h3><p>针对二进制位操作运算符主要包括：</p><ul><li>与操作（&amp;），1&amp;1才为1，其它都为0.</li><li>非操作（～），简单取反.</li><li>或操作（|），当两边操作数的位有一边为1时,结果为1,否则为0.</li><li>异或操作（^），参与运算的两个值,如果两个相应位相同,则结果为0,否则为1.</li></ul><p>二进制位移动运算符：</p><ul><li>有符号的右移位运算符（&gt;&gt;），使指定值的所有位都向右移规定的次数.正数在高位插入0,负数则在高位插入1. 右移一位相当于除2, 右移n位相当于除以2的n次方.</li><li>有符号的左移动运算符（&lt;&lt;），使指定值的所有位都向左移规定的次数, 丢弃最高位, 在低位补0. 在数字没有溢出的前提下,对于正数和负数, 左移一位都相当于乘以2的1次方, 左移n位就相当于乘以2的n次方.</li><li>无符号的右移位运算符（&gt;&gt;&gt;），忽略了符号位扩展,无论正负,都在高位插入0.</li></ul><h3 id="位操作的应用"><a href="#位操作的应用" class="headerlink" title="位操作的应用"></a>位操作的应用</h3><h4 id="取模操作"><a href="#取模操作" class="headerlink" title="取模操作"></a>取模操作</h4><p>这里截取一段hash算法根据hashcode得到映射桶的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)<span class="comment">//这里的判断先映射到了table的某个桶</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>hashmap在插入元素的时候会首先根据hashcode确定映射到某个桶，注释处采用的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure><p>相当于操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash % (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这里需要注意的是，hash在扩容的都是以2的整数倍进行扩容，也就是为什么hashmap的数组长度要取2的整数次幂。因为这样（数组长度减1）正好相当于一个”低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值。以初始长度16为例，16-1=15。二进制表示为00000000 00000000 00001111。这样和某散列值进行与操作的结果如下，截取了最低的四位值，完成了取模的操作：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10100101 11000100 00100101</span><br><span class="line">&amp;  00000000 00000000 00001111</span><br><span class="line">-----------------------------------</span><br><span class="line">        00000000 00000000 00000101 //高位全部归零，只保留最后四位</span><br></pre></td></tr></table></figure><p>当然二进制&amp;的计算效率是要远远大于十进制%的计算效率。</p><h4 id="交换数字"><a href="#交换数字" class="headerlink" title="交换数字"></a>交换数字</h4><p>一般进行数字交换的操作我们会定义一个中间变量，作为交换的中转站。如果通过异或操作来进行可以省略中间变量的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 数a两次异或同一个数b(a=a^b^b)仍然为原值.*/</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">666</span>;</span><br><span class="line"></span><br><span class="line">        a = a ^ b;</span><br><span class="line">        b = b ^ a;</span><br><span class="line">        a = a ^ b;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"a: "</span> + a + <span class="string">" b "</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a: 666 b 100</span><br></pre></td></tr></table></figure><p><strong>数a两次异或同一个数b(a=a^b^b)仍然为原值.</strong></p><h3 id="HashMap扰动函数"><a href="#HashMap扰动函数" class="headerlink" title="HashMap扰动函数"></a>HashMap扰动函数</h3><p>这里我们分析一段HashMap的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class="line"><span class="comment">     * to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class="line"><span class="comment">     * hashes that vary only in bits above the current mask will</span></span><br><span class="line"><span class="comment">     * always collide. (Among known examples are sets of Float keys</span></span><br><span class="line"><span class="comment">     * holding consecutive whole numbers in small tables.)  So we</span></span><br><span class="line"><span class="comment">     * apply a transform that spreads the impact of higher bits</span></span><br><span class="line"><span class="comment">     * downward. There is a tradeoff between speed, utility, and</span></span><br><span class="line"><span class="comment">     * quality of bit-spreading. Because many common sets of hashes</span></span><br><span class="line"><span class="comment">     * are already reasonably distributed (so don't benefit from</span></span><br><span class="line"><span class="comment">     * spreading), and because we use trees to handle large sets of</span></span><br><span class="line"><span class="comment">     * collisions in bins, we just XOR some shifted bits in the</span></span><br><span class="line"><span class="comment">     * cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class="line"><span class="comment">     * to incorporate impact of the highest bits that would otherwise</span></span><br><span class="line"><span class="comment">     * never be used in index calculations because of table bounds.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里是桶映射的方法函数，针对上面取模操作的介绍，为什么还要对hashcode进行一个这样操作，为什么不直接进行散列？</p><p>这里想象一下hashcode是一个32位数，只保留最后几位的取模操作，碰撞是会相当严重的。而且我们在设计hashcode的时候不能保证是规律分布，很有可能在呈四位的跳跃状，那么很有可能会造成严重的碰撞。这样的话就很蛋疼了，这样的散列是没有任何价值的。那么我们就需要进行高低位的扰动：</p><p><img src="http://arthornye.github.io/images/raoluan.png" alt="cmd-markdown-logo"></p><p>右移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始hash码的高位和低位这样来加大低位的随机性。从而减少碰撞的概率。实验显示，当hashmap数组的长度为512的时候好，也就是用掩码取低9位的时候，在没有扰动函数的情况下发生了103次碰撞，接近百分之三十。在使用了扰动函数之后只有92次碰撞。碰撞减少了将近百分之十。</p><p>Java8只做了一次扰动，一般也可以考虑做多次的扰动，但是可能考虑到效率原因改成了一次。</p><h3 id="INT十进制转换为二进制"><a href="#INT十进制转换为二进制" class="headerlink" title="INT十进制转换为二进制"></a>INT十进制转换为二进制</h3><p>做一段测试代码的小记录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 3/13/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapStudy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">char</span>[] digits=&#123;<span class="string">'0'</span>,<span class="string">'1'</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map=<span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        String testString=<span class="string">"t3"</span>;</span><br><span class="line">        System.out.println(<span class="string">"t3的hashCode为："</span>+testString.hashCode());</span><br><span class="line">        System.out.println(testString.hashCode() ^ testString.hashCode()&gt;&gt;&gt;<span class="number">16</span>);</span><br><span class="line">        System.out.println(<span class="number">173412366</span> ^ <span class="number">8</span>);</span><br><span class="line">        System.out.println(<span class="number">12</span> &amp; <span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="number">12</span> % <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(convertIntToBinary(-<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将int类型转换为二进制字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">convertIntToBinary</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] buf=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">32</span>];<span class="comment">//int为4个Byte，32bit</span></span><br><span class="line">        <span class="keyword">int</span> pos=<span class="number">32</span>;</span><br><span class="line">        <span class="keyword">int</span> mask=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            buf[--pos]= digits[i &amp; mask];</span><br><span class="line">            i &gt;&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pos&gt;<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> String(buf,pos,<span class="number">32</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要解决自己在阅读HashMap源码过程中碰到的一些疑惑，进行记录，接下来将会介绍HashMap相关的源码实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在阅读源码的过程中，发现很多地方会使用到位操作来提高计算的效率。我们很常见的取模操作，在源码中都会通过与操作来完成。了解和灵活运用位运算可以帮助我们快速理解源码，写出较为简洁的代码。&lt;/p&gt;
&lt;h3 id=&quot;位操作运算符&quot;&gt;&lt;a href=&quot;#位操作运算符&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OpenClover提高ut覆盖率</title>
    <link href="http://jianghao.wang/2018/OpenClover%E6%8F%90%E9%AB%98ut%E8%A6%86%E7%9B%96%E7%8E%87/"/>
    <id>http://jianghao.wang/2018/OpenClover提高ut覆盖率/</id>
    <published>2018-03-09T08:59:15.000Z</published>
    <updated>2018-03-09T10:14:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>代码的单元测试覆盖率是衡量代码质量的标准之一，保证一定的ut覆盖率可以帮助提高开发人员的项目提测质量。本文将介绍如何在idea下利用openclover插件提高ut覆盖率。</p><h3 id="安装idea插件"><a href="#安装idea插件" class="headerlink" title="安装idea插件"></a>安装idea插件</h3><h4 id="Atlassian-Clover-for-IDEA"><a href="#Atlassian-Clover-for-IDEA" class="headerlink" title="Atlassian Clover for IDEA"></a>Atlassian Clover for IDEA</h4><p>从ItelliJ IDEA —&gt;Preference—&gt;plugins，idea中有自带的插件可供安装，我们可以搜索到该插件。点击安装之后成功之后我们发现该插件需要舒服注册码license。并且我们根据引导无法从Atlassian获取到对应的注册码。感谢国际友人，在一个论坛上发现该插件已经开源，我们可以通过导入插件的方式安装。</p><p><img src="http://arthornye.github.io/images/OpenClover/cloverage.png" alt="cmd-markdown-logo"></p><h4 id="OpenClover-for-IDEA"><a href="#OpenClover-for-IDEA" class="headerlink" title="OpenClover for IDEA"></a>OpenClover for IDEA</h4><p>1.进入OpenClover官网，根据<a href="http://openclover.org/doc/manual/4.2.0/idea--installation-guide.html" target="_blank" rel="noopener">快速开始OpenClover for IDEA</a>我们将下载到的jar包直接导入到idea下，ItelliJ IDEA —&gt;Preference—&gt;plugins—&gt;Install plugin from disk，如下图：</p><p>​        <img src="http://arthornye.github.io/images/OpenClover/openclover.png" alt="cmd-markdown-logo"></p><p>2.点击View -&gt; Toolbar显示插件按钮，如下图：</p><p><img src="http://arthornye.github.io/images/OpenClover/toolbar.png" alt="cmd-markdown-logo"></p><p>3.通过Preference—&gt;Build,Execution,Deployment—&gt;Clover setting(global settings)—&gt;Clover setting(project setting)我们可以进行一些插件的设置，如下图：</p><p><img src="http://arthornye.github.io/images/OpenClover/view.png" alt="cmd-markdown-logo"></p><h3 id="单元测试覆盖"><a href="#单元测试覆盖" class="headerlink" title="单元测试覆盖"></a>单元测试覆盖</h3><p>一般在开发过程中，开发会对dao层和service层进行基本的单元测试回归保证代码的交付质量，当然单元测试可能并没有覆盖到代码的全部情况。单元测试覆盖需要尽可能覆盖到我们的代码。在使用插件的过程中我们可以看到一张覆盖率的图表：</p><p>​        <img src="http://arthornye.github.io/images/OpenClover/pic.png" alt="cmd-markdown-logo"></p><p>这里主要做了service层的单元测试覆盖，覆盖率平均到了80以上，但是整个项目的覆盖率只有30不到。这里是因为插件统计项目中每个类进行的每个方法以及代码的覆盖率，包括控制层代码。代码中会显示绿色的为覆盖到的代码，红色的未覆盖的代码，包括一些异常，未被执行到的判断。判断如果是多个参数的，需要考虑到所有的情况才算是百分之100通过，可以看到覆盖代码如图：</p><p>​      <img src="http://arthornye.github.io/images/OpenClover/color.png" alt="cmd-markdown-logo"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本次单元测试覆盖率是鉴于部门对代码质量的要求，延续之前增加了sonar自定义检测代码规则。提升代码覆盖率的过程中发现其实是个体力活，这样的覆盖也许在后续补充为了达到指标也许并没有意义。这也许是为了我们可以在项目开发的过程中来补充单元测试用例保证代码交付质量，如果放到后面再来补，也就本末倒置了。希望今后的代码都能在开发过程中做到充分的单元测试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代码的单元测试覆盖率是衡量代码质量的标准之一，保证一定的ut覆盖率可以帮助提高开发人员的项目提测质量。本文将介绍如何在idea下利用openclover插件提高ut覆盖率。&lt;/p&gt;
&lt;h3 id=&quot;安装idea插件&quot;&gt;&lt;a href=&quot;#安装idea插件&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="大搜车的点滴记录" scheme="http://jianghao.wang/tags/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%9A%84%E7%82%B9%E6%BB%B4%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
</feed>
