<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TizzyT&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/9dde1b9d65b89035e235650923e5811e</icon>
  <subtitle>即使是拖后腿的，拼死努力的话，也是可以超越精英的。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jianghao.wang/"/>
  <updated>2019-03-05T02:37:57.899Z</updated>
  <id>http://jianghao.wang/</id>
  
  <author>
    <name>yeqiaozhu</name>
    <email>yqz_zjut@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分库分表</title>
    <link href="http://jianghao.wang/2019/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <id>http://jianghao.wang/2019/分库分表/</id>
    <published>2019-03-01T09:42:52.745Z</published>
    <updated>2019-03-05T02:37:57.899Z</updated>
    
    <content type="html"><![CDATA[<p>当mysql单表的数据量达到200万条以上时，建立索引和单表查询的代价较大，查询性能也会到达瓶颈，需要进行分库分表。</p><h4 id="垂直拆分-水平拆分"><a href="#垂直拆分-水平拆分" class="headerlink" title="垂直拆分+水平拆分"></a>垂直拆分+水平拆分</h4><p><strong>垂直拆分（单表字段过多）</strong>：将单表的数据量分别分散到多个库表，拆分的主要标准是热点数据vs非热点数据，热点数据mysql有buffer_pool缓存热点数据页。分别将热点字段拆分到热点表，非热点数据拆分到非热点表。</p><p><strong>水平拆分（单表数据记录过多）</strong>：将单表大量的数据分散到多个库表，表结构一直，利用数据库中间件分发到对应的库。业务上当单表的数据过多时，采用读写分离无法改善单库的性能瓶颈。分散到多个库表直接提高性能。</p><p>水平拆分一般采用下面的两种方式：</p><ul><li><strong>按照范围range拆分，例如根据创建时间将1000w条记录分散到五个表，优点是简单，当新数据来的时候不需要改表结构，只需要不断进行拆分就行。确定是一般最近的数据都是热点数据，导致查询都落在一个库表，导致分库分表并不是很彻底。</strong></li><li><strong>按照hash的方式来拆分，每一条记录的主键都对应一个hash值，映射到不同的库表，优点是数据分散较为均匀，查询压力分散，并发承载力更好。缺点是如果需要再次扩展库表，需要对所有的数据重新进行hash分配库表，代价较大。</strong></li></ul><h4 id="数据库（分库分表）中间件"><a href="#数据库（分库分表）中间件" class="headerlink" title="数据库（分库分表）中间件"></a>数据库（分库分表）中间件</h4><p>这里主要罗列两种目前用的比较多比较主流的中间件，一种是基于客户端的<strong>sharding-jdbc</strong>，一种是基于proxy代理的<strong>mycat</strong>。</p><ul><li><h4 id="mycat优点是proxy有单独的团队维护升级，业务团队客户端不需要关心，适用于大规模公司（阿里面试问了好几次分库分表）。"><a href="#mycat优点是proxy有单独的团队维护升级，业务团队客户端不需要关心，适用于大规模公司（阿里面试问了好几次分库分表）。" class="headerlink" title="mycat优点是proxy有单独的团队维护升级，业务团队客户端不需要关心，适用于大规模公司（阿里面试问了好几次分库分表）。"></a>mycat优点是proxy有单独的团队维护升级，业务团队客户端不需要关心，适用于大规模公司（阿里面试问了好几次分库分表）。</h4></li><li><h4 id="sharding-jdbc是基于客户端的模式，缺点是需要客户端主动进行版本的升级，优点是不需要团队专门维护，适用于中小规模公司。"><a href="#sharding-jdbc是基于客户端的模式，缺点是需要客户端主动进行版本的升级，优点是不需要团队专门维护，适用于中小规模公司。" class="headerlink" title="sharding-jdbc是基于客户端的模式，缺点是需要客户端主动进行版本的升级，优点是不需要团队专门维护，适用于中小规模公司。"></a>sharding-jdbc是基于客户端的模式，缺点是需要客户端主动进行版本的升级，优点是不需要团队专门维护，适用于中小规模公司。</h4></li></ul><h4 id="分库分表数据迁移"><a href="#分库分表数据迁移" class="headerlink" title="分库分表数据迁移"></a>分库分表数据迁移</h4><p>实际场景中，未分库分表状态需要支持动态切换到分库分表状态，但是后台在升级或者优化的过程中需要尽量考虑到是否对业务产生影响，如果通过停机升级的方式大部分场景下是不可以接受的，这里介绍一种<strong>双写迁移方案</strong>。</p><ul><li>1.业务团队改写配置，对于增删改操作，同时落到<strong>老数据库+分库分表数据库中间件</strong>。查询操作依旧走老数据库。</li><li>2.开始从<strong>老数据库导入数据到数据库中间件</strong>，覆盖原则为<strong>新数据覆盖老数据</strong>根据最新更新时间<strong>date_update</strong>来判断。</li><li>3.确保数据全部导入完成，业务方配置全部切换到<strong>分库分表数据库中间件</strong>。</li></ul><p><img src="https://arthornye.github.io/images/doublewrite.jpg" alt="cmd-markdown-logo"></p><h4 id="动态扩容缩容分库分表方案"><a href="#动态扩容缩容分库分表方案" class="headerlink" title="动态扩容缩容分库分表方案"></a>动态扩容缩容分库分表方案</h4><p>真实场景下对数据库做分库分表之后可能还会面临扩容的情况，需要最大程度上支持可扩展，先生成一个32*32足够使用的逻辑表，当需要扩容的时候进行动态扩容。动态扩容缩容分库分表方案步骤：</p><ol><li>设定好几台数据库服务器，每台服务器上几个库，每个库多少个表，推荐是 32库 * 32表，对于大部分公司来说，可能几年都够了。</li><li>路由的规则，orderId 模 32 = 库，orderId / 32 模 32 = 表</li><li>扩容的时候，申请增加更多的数据库服务器，装好 mysql，呈倍数扩容，4 台服务器，扩到 8 台服务器，再到 16 台服务器。</li><li>由 dba 负责将原先数据库服务器的库，迁移到新的数据库服务器上去，库迁移是有一些便捷的工具的。</li><li>我们这边就是修改一下配置，调整迁移的库所在数据库服务器的地址。</li><li>重新发布系统，上线，原先的路由规则变都不用变，直接可以基于 n 倍的数据库服务器的资源，继续进行线上系统的提供服务。</li></ol><h4 id="主键id如何设计"><a href="#主键id如何设计" class="headerlink" title="主键id如何设计"></a>主键id如何设计</h4><p>分库分表有一个问题就是自增id如何生成，唯一主键id再分布式的情况下如何生成，介绍几种方法的利弊：</p><table><br><tr><br>    <th>走单库生成主键id</th><br>    <th>比较简单</th><br>    <th>单库生成无用数据，并发承载量为单库承载量，违背分库分表的初衷</th><br></tr><br><tr><br>    <th>数据库sequence字段分段自增 </th><br>    <th>简单，分为32个模块32个表，每个表自增分别从id+1024累加</th><br>    <th>缺点是没办法进行扩展</th><br></tr><br><tr><br>    <th>UUID生成唯一主键</th><br>    <th>优点是业务方自动生成，方便</th><br>    <th>确定是这样生成比较占用空间，字符串太长</th><br></tr><br><tr><br>    <th>snowflake 算法</th><br>    <th>推荐</th><br>    <th>推荐</th><br></tr><br></table><h5 id="snowflake-算法"><a href="#snowflake-算法" class="headerlink" title="snowflake 算法"></a>snowflake 算法</h5><p>snowflake 算法是 twitter 开源的分布式 id 生成算法，采用 Scala 语言实现，是把一个 64 位的 long 型的 id，1 个 bit 是不用的，用其中的 41 bit 作为毫秒数，用 10 bit 作为工作机器 id，12 bit 作为序列号。</p><ul><li>1 bit：不用，为啥呢？因为二进制里第一个 bit 为如果是 1，那么都是负数，但是我们生成的 id 都是正数，所以第一个 bit 统一都是 0。</li><li>41 bit：表示的是时间戳，单位是毫秒。41 bit 可以表示的数字多达 <code>2^41 - 1</code>，也就是可以标识 <code>2^41 - 1</code> 个毫秒值，换算成年就是表示69年的时间。</li><li>10 bit：记录工作机器 id，代表的是这个服务最多可以部署在 2^10台机器上哪，也就是1024台机器。但是 10 bit 里 5 个 bit 代表机房 id，5 个 bit 代表机器 id。意思就是最多代表 <code>2^5</code>个机房（32个机房），每个机房里可以代表 <code>2^5</code> 个机器（32台机器）。</li><li>12 bit：这个是用来记录同一个毫秒内产生的不同 id，12 bit 可以代表的最大正整数是 <code>2^12 - 1 = 4096</code>，也就是说可以用这个 12 bit 代表的数字来区分<strong>同一个毫秒内</strong>的 4096 个不同的 id。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 | 0001100 10100010 10111110 10001001 01011100 00 | 10001 | 1 1001 | 0000 00000000</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>中间件是如何进行分库分表适配的？不管是基于proxy还是基于客户端，对客户端的查询来说，都不需要关心最终查询落到了哪个库表上，中间件会帮你全部封装好。我的理解是垂直拆分和两种水平拆分的方式，中间件会帮你维护一个映射表，某个对应的key具体映射到哪个库哪个表，然后进行统一的提交。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当mysql单表的数据量达到200万条以上时，建立索引和单表查询的代价较大，查询性能也会到达瓶颈，需要进行分库分表。&lt;/p&gt;
&lt;h4 id=&quot;垂直拆分-水平拆分&quot;&gt;&lt;a href=&quot;#垂直拆分-水平拆分&quot; class=&quot;headerlink&quot; title=&quot;垂直拆分+水平拆
      
    
    </summary>
    
    
      <category term="mysql学习" scheme="http://jianghao.wang/tags/mysql%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>mysql中的join操作算法介绍</title>
    <link href="http://jianghao.wang/2019/mysql%E4%B8%AD%E7%9A%84join%E6%93%8D%E4%BD%9C/"/>
    <id>http://jianghao.wang/2019/mysql中的join操作/</id>
    <published>2019-02-21T08:53:21.589Z</published>
    <updated>2019-02-27T07:50:29.158Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要介绍mysql在join操作上采用的一些算法，以及如何做优化。主要分为Index Nested-Loop Join（NLJ）算法和Block Nested-Loop Join（BLJ）算法，基于Multi-Range Read优化的Batched Access Key（BKA）算法。</p><h4 id="Block-Nested-Loop-Join-BNL"><a href="#Block-Nested-Loop-Join-BNL" class="headerlink" title="Block Nested-Loop Join (BNL)"></a>Block Nested-Loop Join (BNL)</h4><p>通常在explain执行的extra中会有<strong>join_buffer(Block Nested-Loop Join)</strong>表示这次join操作使用了BNL算法。算法主要步骤是：</p><ul><li>1.从驱动表批量查出数据，放到<strong>join_buffer</strong>中。</li><li>2.根据<strong>关联字段</strong>从被驱动表全表<strong>扫描数据</strong>，进行关联。</li><li>3.被关联表查到数据之后进行<strong>回表</strong>。</li><li>4.join_buffer中封装最终数据。</li></ul><p>存在的性能问题：</p><ul><li>1.buffer_pool被占用，降低了缓存命中率。buffer_pool使用<strong>LRU(最近最少使用原则)</strong>理论上M*N不断的进行全表扫描，被驱动表数据会大量缓存在buffer_pool中。</li><li>2.查询操作频繁，耗费大量cpu资源。同时会有大量的磁盘io。</li></ul><p><strong>实际运用过程中，如果出现了使用Block Nested-Loop Join(BNL)建议进行优化。对性能影响较大。</strong></p><h4 id="Index-Nested-Loop-Join-NLJ"><a href="#Index-Nested-Loop-Join-NLJ" class="headerlink" title="Index Nested-Loop Join (NLJ)"></a>Index Nested-Loop Join (NLJ)</h4><p>在上面的基础之上，采用了对被驱动表加索引的方式，极大的提升了效率，如果explain的结果extra中没有出现<strong>join_buffer(Block Nested-Loop Join)</strong>就表示这次join操作默认使用了NLJ算法。该算法有相对的优点：</p><ul><li>1.采用索引的方式定位磁盘块，减少了io次数和cpu资源的消耗。</li><li>2.不会出现BNL算法可能淘汰热点页的问题。只会缓存不同的磁盘块数据。</li></ul><h4 id="Multi-Range-Read-MRR"><a href="#Multi-Range-Read-MRR" class="headerlink" title="Multi-Range Read (MRR)"></a>Multi-Range Read (MRR)</h4><p>该优化主要针对索引回表，<strong>MRR将随机回表读通过join_buffer根据主键id排序改变为顺序回表，一定程度上提升了回表效率，减少了回表次数加快了io读。</strong>mysql中可以通过设置参数开启该算法，默认是关闭的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 通过设置参数开启mrr算法优化。mrr_cost_based=off</span><br><span class="line">set optimizer_switch=&apos;mrr=on,mrr_cost_based=off,batched_key_access=on&apos;;</span><br></pre></td></tr></table></figure><h4 id="Batched-Access-Key-BKA"><a href="#Batched-Access-Key-BKA" class="headerlink" title="Batched Access Key (BKA)"></a>Batched Access Key (BKA)</h4><p>基于Multi-Range Read优化的Batched Access Key（BKA）算法，实际上也是对<strong>NLJ算法的优化。</strong>执行流程如下：</p><ul><li>1.从驱动表中加载数据到join_buffer中得到数据块x，这里如果超出了容量，通过分段的方式加载。（可以通过调整join_buffer的大小改善）。</li><li>2.通过索引查到join_buffer中所有的被驱动表上的数据块y，放到join_buffer中。</li><li>3.通过join_buffer对数据块y进行主键id排序，得到主键id数据块z。</li><li>4.根据排序好的主键id去回表执行顺序读，得到关联查询的数据结果集。</li><li>5.在join_buffer中整合数据数据块x和z，返回结果集给客户端。</li></ul><p><strong>一般我们如果需要将BNL算法转成BKA算法，只需要在被驱动表上建立一个索引就行了。</strong></p><h4 id="特殊情况处理（无法建立索引）"><a href="#特殊情况处理（无法建立索引）" class="headerlink" title="特殊情况处理（无法建立索引）"></a>特殊情况处理（无法建立索引）</h4><p>当在被驱动表上建立索引的成本可能比较高的时候，不建议建立索引。<strong>例如，当关联的结果集实际上可以精简到一个小结果的时候，我们可以建立一个临时表，在临时表上建立索引。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 模拟一下，b字段所在的表数据量很大，但是我们只需要两千条，通过create temporary table建立临时表同时建立索引</span><br><span class="line">create temporary table temp_t(id int primary key, a int, b int, index(b))engine=innodb;</span><br><span class="line">insert into temp_t select * from t2 where b&gt;=1 and b&lt;=2000;</span><br><span class="line">select * from t1 join temp_t on (t1.b=temp_t.b);</span><br></pre></td></tr></table></figure><p>当然最好的操作方式还是数据引擎如果<strong>支持hash join</strong>就完美了，但是mysql是不支持的。如果支持hash join可以快速定位到记录，数据结构参考HashMap数据结构。如果数据引擎不支持，可以考虑在程序内存中将被驱动表的数据放在<strong>Set或者HashMap</strong>这样的数据结构中，进行关联。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇主要介绍mysql在join操作上采用的一些算法，以及如何做优化。主要分为Index Nested-Loop Join（NLJ）算法和Block Nested-Loop Join（BLJ）算法，基于Multi-Range Read优化的Batched Access Ke
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql内部临时表和分组优化</title>
    <link href="http://jianghao.wang/2019/mysql%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%92%8C%E5%88%86%E7%BB%84%E4%BC%98%E5%8C%96/"/>
    <id>http://jianghao.wang/2019/mysql内部临时表和分组优化/</id>
    <published>2019-02-16T12:54:41.867Z</published>
    <updated>2019-02-18T06:18:41.174Z</updated>
    
    <content type="html"><![CDATA[<p>mysql什么时候使用到内部临时表，通过explain可以看到extra信息里面会显示using temporary。我们知道针对mysql的order by操作，维护了一个内存空间sort_buffer，超出这个内存之后会采用磁盘辅助排序，extra信息中会有using filesort。那么mysql什么时候会有using temporary并且如何进行优化。</p><p>内部临时表，存储过程类似sort_buffer的进化过程，先存内存，后退化到磁盘辅助。可以查看到mysql为内部临时表分配的内存大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查看配置temp_table_size大小</span><br><span class="line">show variables like &quot;tmp_table%&quot;</span><br><span class="line">-- result 1KB 超过1KB之后用磁盘存储</span><br><span class="line">tmp_table_size1024</span><br><span class="line">-- 可以设定temp_table_size内存的大小,global去除只对当前session生效</span><br><span class="line">set global tmp_table_size=1024</span><br></pre></td></tr></table></figure><h4 id="union操作using-temporary"><a href="#union操作using-temporary" class="headerlink" title="union操作using temporary"></a>union操作using temporary</h4><p>union操作的语义，将两个结果集整合到一个结果集，union操作会有using temporary，用到内部临时表。主要由于union操作需要去重，如果是union all操作会直接将结果返回给客户端，不在内部临时表做去重操作。</p><h4 id="group-by操作using-temporary"><a href="#group-by操作using-temporary" class="headerlink" title="group by操作using temporary"></a>group by操作using temporary</h4><p>group by操作的过程：</p><ul><li>1.根据结果集的字段建立内部临时表，分组id，count两个字段。</li><li>2.全表扫描需要分组的表，如果内部临时表没有对应的分组id，新增一条记录。</li><li>3.如果内部临时表有对应的分组id，直接count++累加。</li><li>4.根据id进行排序order by将结果存在内存或者持久化到临时磁盘表。</li></ul><h4 id="group-by操作索引优化"><a href="#group-by操作索引优化" class="headerlink" title="group by操作索引优化"></a>group by操作索引优化</h4><p>group by操作explain如果extra信息中有using temporary和using filesort，在数据量比较大的情况下会造成慢查询。mysql 5.7以上版本提供关联列更新操作，<strong>generated column关联某列数据的更新。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 增加一列，列的值为id % 100（分组字段） ，然后为该列建立索引（建立索引避免了排序）。generated column操作会关联列，继续新增一条记录即使没有制定值也会通过关联的列的值计算。</span><br><span class="line">alter table t1 add column z int generated always as (id % 100),add index z_index(z);</span><br></pre></td></tr></table></figure><p>通过加索引，避免了使用临时表，同时避免了使用排序（取出来即为有序），也就是extra中不会出现using temporary和using filesort。那么这个过程为什么避免了？</p><ul><li>没有索引的情况下，需要临时表来记录，因为过程无序，并且最终需要排序。</li><li>有索引的情况下本身有序，不需要记录累加的结果，结果在扫描过过程中得到并且是有序的。</li></ul><h4 id="group-by操作存储优化"><a href="#group-by操作存储优化" class="headerlink" title="group by操作存储优化"></a>group by操作存储优化</h4><p>内存临时表容量，也就是tmp_table_size不够大的时候，会退化为磁盘存储，在数据量大的时候直接指定使用磁盘存储。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 通过SQL_BIG_RESULT这种方式指定不走内存内存临时表，直接用磁盘临时表。</span><br><span class="line">select SQL_BIG_RESULT id%100 as m, count(*) as c from t1 group by m;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>sort_buffer是有序数组，tmp_table_size临时表是二维表结构，具备表的语义，join_buffer是无序数组，均可查看配置大小。</p></li><li><p>执行过程中需要使用二维表结构语义的，优先使用临时表。union操作需要检验唯一约束，需要使用临时表存储。group by需要在过程中用另一个字段计算累加结果。</p></li><li><p>扫描过程中可以直接得到结果的，不需要使用临时表，需要计算的要使用临时表。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mysql什么时候使用到内部临时表，通过explain可以看到extra信息里面会显示using temporary。我们知道针对mysql的order by操作，维护了一个内存空间sort_buffer，超出这个内存之后会采用磁盘辅助排序，extra信息中会有using 
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java 8中异步处理</title>
    <link href="http://jianghao.wang/2019/Java-8%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/"/>
    <id>http://jianghao.wang/2019/Java-8异步处理/</id>
    <published>2019-01-29T06:11:08.722Z</published>
    <updated>2019-01-31T09:22:18.241Z</updated>
    
    <content type="html"><![CDATA[<p>Java8中提供了CompletableFeature工具，提供了一系列基于函数式的api。本篇主要介绍这些api的使用以及源码实现。</p><h4 id="CompletableFeature-supplyAsyc"><a href="#CompletableFeature-supplyAsyc" class="headerlink" title="CompletableFeature.supplyAsyc()"></a>CompletableFeature.supplyAsyc()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.输入一个supplier函数，输出一个CompletableFeature&lt;U&gt;引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(asyncPool, supplier);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.传入一个线程池，一个supplier函数，输出一个CompletableFeature&lt;U&gt;引用</span></span><br><span class="line"><span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">asyncSupplyStage</span><span class="params">(Executor e,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 Supplier&lt;U&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    CompletableFuture&lt;U&gt; d = <span class="keyword">new</span> CompletableFuture&lt;U&gt;();</span><br><span class="line">    <span class="comment">//异步调用之后执行return d</span></span><br><span class="line">    e.execute(<span class="keyword">new</span> AsyncSupply&lt;U&gt;(d, f));</span><br><span class="line">    <span class="comment">//主线程直接返回创建的对象</span></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.线程池中线程异步执行supplier函数</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncSupply</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">Void</span>&gt;</span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">AsynchronousCompletionTask</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;T&gt; dep; Supplier&lt;T&gt; fn;</span><br><span class="line">        <span class="comment">//初始化时用主线程CompletableFeature对象引用</span></span><br><span class="line">        AsyncSupply(CompletableFuture&lt;T&gt; dep, Supplier&lt;T&gt; fn) &#123;</span><br><span class="line">            <span class="keyword">this</span>.dep = dep; <span class="keyword">this</span>.fn = fn;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Void <span class="title">getRawResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRawResult</span><span class="params">(Void v)</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123; run(); <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里的 d引用==线程初始化对象引用dep==主线程对象引用</span></span><br><span class="line">            CompletableFuture&lt;T&gt; d; Supplier&lt;T&gt; f;</span><br><span class="line">            <span class="keyword">if</span> ((d = dep) != <span class="keyword">null</span> &amp;&amp; (f = fn) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                dep = <span class="keyword">null</span>; fn = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (d.result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//异步线程内部同步执行supplier函数，f.get返回类型和泛型类型保持一致</span></span><br><span class="line">                        d.completeValue(f.get());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="comment">//发生异常将异常作为结果对象</span></span><br><span class="line">                        d.completeThrowable(ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                d.postComplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//4.d.completeValue通过unsafe cas替换，到这里异步线程执行完成并将执行结果记录在volatile object result对象中</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">completeValue</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//入参this（object1），result（volatile object类型），null（拷贝旧值），t（返回新值）</span></span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, RESULT, <span class="keyword">null</span>,(t == <span class="keyword">null</span>) ? NIL : t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5.这里的RESULT</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"><span class="comment">// 为什么是long类型，暂时理解为内存地址吧。。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RESULT;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> STACK;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> NEXT;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> sun.misc.Unsafe u;</span><br><span class="line">        UNSAFE = u = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k = CompletableFuture.class;</span><br><span class="line">        <span class="comment">//获取声明字段的内存地址</span></span><br><span class="line">        RESULT = u.objectFieldOffset(k.getDeclaredField(<span class="string">"result"</span>));</span><br><span class="line">        STACK = u.objectFieldOffset(k.getDeclaredField(<span class="string">"stack"</span>));</span><br><span class="line">        NEXT = u.objectFieldOffset</span><br><span class="line">            (Completion.class.getDeclaredField(<span class="string">"next"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception x) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程循环等待 volatile object result返回<strong>CompletableFeature.get()。</strong>同时可以设置超时时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">waitingGet</span><span class="params">(<span class="keyword">boolean</span> interruptible)</span> </span>&#123;</span><br><span class="line">        Signaller q = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> spins = -<span class="number">1</span>;</span><br><span class="line">        Object r;</span><br><span class="line">    <span class="comment">//就这一句判断，反正就是不给我我就循环，占着cpu，你说难受不难受，如果不设置超时时间异步线程不返回，就死循环卡着了，是不是很伤。内部应该处理了一些什么东西，避免死循环占用cpu，可以换成阻塞式，让出cpu。</span></span><br><span class="line">        <span class="keyword">while</span> ((r = result) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)</span><br><span class="line">                spins = (Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span>) ?</span><br><span class="line">                    <span class="number">1</span> &lt;&lt; <span class="number">8</span> : <span class="number">0</span>; <span class="comment">// Use brief spin-wait on multiprocessors</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ThreadLocalRandom.nextSecondarySeed() &gt;= <span class="number">0</span>)</span><br><span class="line">                    --spins;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里之前死循环，spins == 1&lt;&lt;8 === 256 次，进行256次死循环。检查result，如果这段时间没有返回。执行到下面的代码。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">                q = <span class="keyword">new</span> Signaller(interruptible, <span class="number">0L</span>, <span class="number">0L</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">                <span class="comment">//这里会进入然后一直阻塞，让出cpu，知道result返回之后才返回继续执行一次循环，然后退出循环。</span></span><br><span class="line">                queued = tryPushStack(q);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (interruptible &amp;&amp; q.interruptControl &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                q.thread = <span class="keyword">null</span>;</span><br><span class="line">                cleanStack();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q.thread != <span class="keyword">null</span> &amp;&amp; result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ForkJoinPool.managedBlock(q);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    q.interruptControl = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span>) &#123;</span><br><span class="line">            q.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (q.interruptControl &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (interruptible)</span><br><span class="line">                    r = <span class="keyword">null</span>; <span class="comment">// report interruption</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        postComplete();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>附上流程图吧：</p><p><img src="http://arthornye.github.io/images/completeFeature.jpg" alt="cmd-markdown-logo"></p><p>推荐设置超时时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 11/20/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompleteFeatureTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; stringCompletableFuture=CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//定义的body，默认覆盖,定义一个supplier函数异步调用，模拟网络调用</span></span><br><span class="line">                Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"同步异常"</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//return 的类型为定义的模板类型</span></span><br><span class="line">                <span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String string= <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                string = stringCompletableFuture.get(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"getResultString:"</span>+string);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CompletableFeature-runAsync"><a href="#CompletableFeature-runAsync" class="headerlink" title="CompletableFeature.runAsync()"></a>CompletableFeature.runAsync()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.runAsync(() -&gt;</span><br><span class="line">                           System.out.println(<span class="string">"CompleteFeature runAsync..."</span>)</span><br><span class="line">                          );</span><br></pre></td></tr></table></figure><p>异步调用线程，不关心返回结果，这里入参是一个lamada表达式。Java8之前的写法是匿名内部类的方式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.runAsync(</span><br><span class="line">    <span class="comment">//java8 之后不推荐这么写，采用lamada表达式</span></span><br><span class="line">    <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"CompleteFeature runAsync..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这个函数调用不关心返回结果。</p><h4 id="CompletableFeature-runAsync-whenComplete-whenCompleteAsync"><a href="#CompletableFeature-runAsync-whenComplete-whenCompleteAsync" class="headerlink" title="CompletableFeature.runAsync().whenComplete()/.whenCompleteAsync"></a>CompletableFeature.runAsync().whenComplete()/.whenCompleteAsync</h4><ul><li><strong>1.CompletableFeature.runAsync()开辟一个异步线程a,主线程直接返回CompletableFeature<void>类型的一个引用，不关心a的执行结果。</void></strong></li><li><strong>2.主线程用CompletableFeature<void>的引用调用.whenComplete()直接返回CompletableFeature<t>的引用，a线程执行完成之后，执行whenComplete()中的BiConsumer方法，完全异步，不干扰主线程。</t></void></strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 11/20/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompleteFeatureTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CompletableFuture&lt;?&gt; completableFuture=CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getId() + <span class="string">"   CompleteFeature runAsync..."</span>);</span><br><span class="line">        &#125;).whenComplete((t, e) -&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getId() + <span class="string">"   CompleteFeature runAsync...complete"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;?&gt; completableFuture1 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getId() + <span class="string">"   CompleteFeature runAsync...1"</span>);                                                                  &#125;).whenCompleteAsync((t, u) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getId() + <span class="string">"   CompleteFeature runAsync...complete...1"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      CompletableFuture&lt;?&gt; all=CompletableFuture.allOf(completableFuture,completableFuture1);</span><br><span class="line">      all.whenComplete(</span><br><span class="line">          (v,e)-&gt;</span><br><span class="line">          System.out.println(<span class="string">"all completed"</span>)</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          all.get();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>   CompleteFeature runAsync...</span><br><span class="line"><span class="number">11</span>   CompleteFeature runAsync...<span class="number">1</span></span><br><span class="line"><span class="number">10</span>   CompleteFeature runAsync...complete</span><br><span class="line"><span class="number">11</span>   CompleteFeature runAsync...complete...<span class="number">1</span></span><br><span class="line">all completed</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java8中提供了CompletableFeature工具，提供了一系列基于函数式的api。本篇主要介绍这些api的使用以及源码实现。&lt;/p&gt;
&lt;h4 id=&quot;CompletableFeature-supplyAsyc&quot;&gt;&lt;a href=&quot;#CompletableFeatu
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>mysql大查询内存策略</title>
    <link href="http://jianghao.wang/2019/mysql%E5%A4%A7%E6%9F%A5%E8%AF%A2%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5/"/>
    <id>http://jianghao.wang/2019/mysql大查询内存策略/</id>
    <published>2019-01-28T02:15:11.571Z</published>
    <updated>2019-01-28T05:50:13.068Z</updated>
    
    <content type="html"><![CDATA[<p>mysql在处理大查询的时候需要有自己的内存策略，保证不会出现OOM（Out Of Memory）内存泄漏。我们从server层面和引擎层面剖析一下内存策略。</p><h4 id="server层处理大查询"><a href="#server层处理大查询" class="headerlink" title="server层处理大查询"></a>server层处理大查询</h4><p>server层对大查询的处理，这里针对的大查询是返回的数据量巨大。针对这种查询server层会采用<strong>边读边发</strong>策略。也就是数据由客户端分阶段整合，服务端并不需要保证一个完整的结果集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查看net_buffer_length参数，服务端会先将数据存到这个内存区域，存满之后向客户端发送，不断重复。</span><br><span class="line">show variables like &quot;net_buffer_%&quot;</span><br><span class="line">-- 结果,默认16k大小</span><br><span class="line">net_buffer_length16384</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- show processlist,在大查询执行的过程中，语句会处于sending client data的状态</span><br><span class="line">show processlist;</span><br><span class="line">-- status ，语句的对应状态，如果发现有语句处于这种状态，需要业务方确认是否需要返回如此多的信息。尽量进行优化。</span><br><span class="line">sending client data`</span><br></pre></td></tr></table></figure><p>边读边发：</p><ul><li>1.服务端从磁盘中读取数据加入net_buffer_length内存中。默认16k。</li><li>2.net_buffer_length满，触发发送到客户端操作。</li><li>3.收到Socket Send Buffer结果为发送成功，清空net_buffer_length，重新读取。</li><li>4.如果Socket Send Buffer返回EAGAIN 或 WSAEWOULDBLOCK，表示Socket Send Buffer已满，进入等待直到重新可写。</li></ul><p><img src="http://arthornye.github.io/images/bigquery.jpg" alt="cmd-markdown-logo"></p><h4 id="Innodb处理大查询"><a href="#Innodb处理大查询" class="headerlink" title="Innodb处理大查询"></a>Innodb处理大查询</h4><p>大家都知道Innodb在执行查询的之后都会将sql和对应的数据页，放置在内存中，也就是<strong>Innodb buffer pool size</strong>，这个内存区域我们之前有介绍可以通过redo log减少随机写操作，以及change buffer来减少随机读操作。但是在大查询的情况下会面对哪些问题，先看这个区域采用的<strong>LRU算法（最近最少使用算法）</strong>。</p><ul><li>1.最近最少使用算法采用链表，以一个数据页为单位P1，P2…</li><li>2.从磁盘中读出一个页Pn会放置在链表的头部。</li><li>3.访问到某个数据页Px，先返回客户端结果，然后将该页放置到链表的头部。</li><li>4.当Innodb buffer pool size已经满了，取一个最旧的页，删除数据，存入新数据并将其放置到头部。</li></ul><p><img src="http://arthornye.github.io/images/pagelink.jpg" alt="cmd-markdown-logo"></p><p>针对大查询的场景，如果不断查询出新的数据，单纯采用<strong>LRU算法（最近最少使用）</strong>查询出来的新页会直接替换老页，导致正常的业务内存缓存会被替换掉，增加了磁盘IO，而这些新增的缓存页在第一次使用之后又不会再进行使用。这种场景Innodb<strong>针对LRU做了分代优化，将这个buffer区域按照5:3划分为young和old区。这个概念其实在垃圾回收机制的分代收集的场景类似。针对不同的生命周期定制不同的淘汰方案。</strong></p><p><img src="http://arthornye.github.io/images/youngold.jpg" alt="cmd-markdown-logo"></p><p>需要注意的是，<strong>分代的主要目的还是基于提高内存命中率。</strong></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>mysql针对大查询通过server层进行边读边写的操作防止内存泄漏，如果出现sending client data并且时间特别长的情况下，可以尝试调整net_buffer_length参数。但是还是需要通过业务这边减少查询的数据量来进行优化改善。</p><p>Innodb通过Innodb_buffer_pool_size内存来进行数据页的缓存，大查询可能导致不经常使用的数据页占领这个buffer区域导致其他的查询性能下降。<strong>LRU算法（最近最少使用）基础上的分代算法的改进可以保证正常业务和大查询业务的平衡</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mysql在处理大查询的时候需要有自己的内存策略，保证不会出现OOM（Out Of Memory）内存泄漏。我们从server层面和引擎层面剖析一下内存策略。&lt;/p&gt;
&lt;h4 id=&quot;server层处理大查询&quot;&gt;&lt;a href=&quot;#server层处理大查询&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>消息队列基本介绍</title>
    <link href="http://jianghao.wang/2019/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    <id>http://jianghao.wang/2019/消息队列基本介绍/</id>
    <published>2019-01-25T01:51:12.709Z</published>
    <updated>2019-01-25T02:09:58.672Z</updated>
    
    <content type="html"><![CDATA[<h4 id="主流的消息队列中间件"><a href="#主流的消息队列中间件" class="headerlink" title="主流的消息队列中间件"></a>主流的消息队列中间件</h4><table><br><tr><br>    <th>消息队列\特点</th><br>    <th>优点</th><br>    <th>缺点</th><br></tr><br><tr><br>    <th>ActiveMQ</th><br>    <th>老牌的消息中间件，功能强大。</th><br>    <th>没法确认ActiveMQ可以支撑互联网公司的高并发、高负载以及高吞吐的复杂场景，在国内互联网公司落地较少，多用于异步调用和系统解耦。</th><br></tr><br><tr><br>    <th>RabbitMQ</th><br>    <th>高并发，高吞吐，性能很高，后台管理系统很便捷，开源社区非常活跃。</th><br>    <th>基于erlang开发，较难进行二次开发。</th><br></tr><br><tr><br>    <th>RocketMQ</th><br>    <th>阿里开源，基于java，高并发，高吞吐，支持分布式。</th><br>    <th>未知。</th><br></tr><br></table><h4 id="消息中间件的主要作用"><a href="#消息中间件的主要作用" class="headerlink" title="消息中间件的主要作用"></a>消息中间件的主要作用</h4><h5 id="系统解耦"><a href="#系统解耦" class="headerlink" title="系统解耦"></a>系统解耦</h5><p>将消息存放到消息中间件，避免大量的系统直接调用，可以由被调用方自行进行消费。调用方不用关心结果，代码解耦合。</p><h5 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h5><p>调用链路比较长的情况下，通过消息异步调用减少接口调用时长，防止超时或者等待时间过长。</p><h5 id="流量削减"><a href="#流量削减" class="headerlink" title="流量削减"></a>流量削减</h5><p>在短时间大流量的情况下，需要进行限流，作为后端集群的负载，生产者可以不断生成消息，但是后端集群只会定量消费。保护了后台系统的稳定性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;主流的消息队列中间件&quot;&gt;&lt;a href=&quot;#主流的消息队列中间件&quot; class=&quot;headerlink&quot; title=&quot;主流的消息队列中间件&quot;&gt;&lt;/a&gt;主流的消息队列中间件&lt;/h4&gt;&lt;table&gt;&lt;br&gt;&lt;tr&gt;&lt;br&gt;    &lt;th&gt;消息队列\特点&lt;/th&gt;&lt;b
      
    
    </summary>
    
    
      <category term="消息队列" scheme="http://jianghao.wang/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>sql操作记录</title>
    <link href="http://jianghao.wang/2019/sql%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
    <id>http://jianghao.wang/2019/sql操作记录/</id>
    <published>2019-01-24T07:21:00.479Z</published>
    <updated>2019-01-24T07:25:52.197Z</updated>
    
    <content type="html"><![CDATA[<p>主要记录一些sql的订正的操作。</p><h4 id="insert操作无需指定自增id"><a href="#insert操作无需指定自增id" class="headerlink" title="insert操作无需指定自增id"></a>insert操作无需指定自增id</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- insert的时候指定一个列表</span><br><span class="line">insert into error_level_conf (biz_type,error_type,error_level,handle_num_limit) value(&quot;general_b2C&quot;,&quot;CREATE_COUPON_PAYMENT&quot;,1,10);</span><br></pre></td></tr></table></figure><h4 id="从一个表拷贝数据到另一个表并订正"><a href="#从一个表拷贝数据到另一个表并订正" class="headerlink" title="从一个表拷贝数据到另一个表并订正"></a>从一个表拷贝数据到另一个表并订正</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- retail_coupon.eticket_status 已经落表的数据直接已登账的状态，定金支付完成的订单状态为已分账，这里关联订单表状态150的为已登账，大于150为已分账</span><br><span class="line">-- retail_marketing_order.entry_status 和retail_marketing_order.split_account_status中台不使用，订正到已登账和已分账状态</span><br><span class="line"></span><br><span class="line">INSERT INTO retail_coupon (retail_order_code, eticket_status, tmall_order_id, coupon_type, step_no</span><br><span class="line">, disburse_fee, discount_price, delete_mark, tmall_sku_id, date_create</span><br><span class="line">, date_update, business_type, discount_stage, entry_status, split_account_status)</span><br><span class="line">SELECT t1.retail_order_code</span><br><span class="line">, (</span><br><span class="line">SELECT CASE t2.order_status</span><br><span class="line">WHEN 150 THEN 3</span><br><span class="line">ELSE 4</span><br><span class="line">END</span><br><span class="line">), t1.tmail_order_id, 1, t1.step_count, t1.disburse_fee</span><br><span class="line">, t1.voucher_price, t1.deleted, t1.sku_id, t1.date_create, t1.date_update</span><br><span class="line">, &apos;distributor&apos;, &apos;retainge&apos;, 50, 50</span><br><span class="line">FROM retail_marketing_order t1</span><br><span class="line">LEFT JOIN retail_order t2 ON convert(t1.retail_order_code USING utf8) = t2.order_code;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要记录一些sql的订正的操作。&lt;/p&gt;
&lt;h4 id=&quot;insert操作无需指定自增id&quot;&gt;&lt;a href=&quot;#insert操作无需指定自增id&quot; class=&quot;headerlink&quot; title=&quot;insert操作无需指定自增id&quot;&gt;&lt;/a&gt;insert操作无需指定自增
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>如何处理读写分离</title>
    <link href="http://jianghao.wang/2019/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    <id>http://jianghao.wang/2019/如何处理读写分离/</id>
    <published>2019-01-16T03:09:54.910Z</published>
    <updated>2019-01-19T09:28:21.685Z</updated>
    
    <content type="html"><![CDATA[<p>mysql在读写分离的场景下，可能是一主一从，一主都从。但是在实际应用场景中需要解决一个重要的问题就是<strong>“过期读”</strong>。本篇主要介读写分离可能的架构方式以及如何解决该问题。</p><h4 id="强制从主库读取"><a href="#强制从主库读取" class="headerlink" title="强制从主库读取"></a>强制从主库读取</h4><h5 id="及时查询vs非及时查询"><a href="#及时查询vs非及时查询" class="headerlink" title="及时查询vs非及时查询"></a>及时查询vs非及时查询</h5><p>针对某些必须保证正确读的场景，我们可以设置这个请求只能走主库，例如一个场景，商家在发布了商品之后需要立即看到商品的信息，那么这个我们可以直接从主库去读。同样的场景，买家在前端去看新发布的商品时可能并不需要这么及时，可以容忍有一定时间的延迟，那么这个查询比较适合走从库。这里我们将查询分为两类：<strong>及时查询和非及时查询。</strong></p><ul><li>优点：逻辑上比较简单，易于实现和区分</li><li>缺点：可能会面临所有的查询都是及时查询的情况，例如一些金融系统对及时性要求很高。</li></ul><h5 id="及时查询优化"><a href="#及时查询优化" class="headerlink" title="及时查询优化"></a>及时查询优化</h5><p>即使是刚才讲到的可能面对的及时查询的情况，查询的时效性很高。为了减少主库的查询压力，我们可以让前端直接去跳转，看起来做了查询但是实际上没有查询。上架了商品之后直接将上架的商品信息展示在商品栏，减少了一次查询主库的压力。</p><p>实际上我们在应用中经常会采取强制从主库读取这种方式，但是很可能面对尴尬的场景。整个系统对时效性要求都比较高的时候，而又必须通过读写分离改善的场景下，可以如何解决<strong>过期读</strong>的问题？</p><h4 id="判断主备延迟"><a href="#判断主备延迟" class="headerlink" title="判断主备延迟"></a>判断主备延迟</h4><p>每次在备库执行查询请求之前，先判断下主备是否有延迟。可以通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status;</span><br></pre></td></tr></table></figure><h5 id="seconds-behind-master"><a href="#seconds-behind-master" class="headerlink" title="seconds_behind_master"></a>seconds_behind_master</h5><p>判断seconds_behind_master，通过show slave status可以在从库上查看到这个参数，如果seconds_behind_master</p><p>为零，可以走从库进行查询。缺点是精度比较难保证。</p><h5 id="对比位点和GTID集合"><a href="#对比位点和GTID集合" class="headerlink" title="对比位点和GTID集合"></a>对比位点和GTID集合</h5><p>在备库执行show slave status可以看到备库的位点和GTID集合的状态：</p><p><img src="http://arthornye.github.io/images/poslog.jpg" alt="cmd-markdown-logo"></p><ul><li><strong>Master_Log_File == Relay_Master_Log_File  &amp;&amp; Read_    Master_Log_Pos == Exec_Master_log_File  为true，表明备库已经完成接收到的主库的binlog同步。此为对比位点。</strong></li><li><strong>Retrieved_Gtid_Set(接收到的集合) == Executed_Gtid_Set(已经执行了的集合) 为true表明备库已经完成接受到的主binlog的同步。此为对比GTID。Auto_Position=1 ，表示这对主备关系使用了 GTID协议。</strong></li></ul><p>虽然这种方式都可以保证备库已经执行完了主库存传过来的binlog，但是因为binlog的传送这个过程相对客户端是异步的，那么客户端在收到更新成功的一条语句之后，这个语句可能还没有传送到备库。</p><p><img src="http://arthornye.github.io/images/asynclog.jpg" alt="cmd-markdown-logo"></p><p>这里需要引入<strong>半同步复制semi-sync</strong>:</p><ul><li>1.主库的事务提交之后，向备库发一个binlog，注意这里先不返回客户端更新成功。</li><li>2.备库收到binlog之后，向主库发一个ack，表示收到了这个binlog。</li><li>3.主库收到备库的ack之后，向客户端返回更新成功。</li></ul><p>semi-sync缺陷：<strong>目前只能支持一主一从，如果是一主多从，并不能等待所有备库都接收到binlog，而是收到一个ack就返回给客户端。这样就不能完全保证不会出现过期读。</strong></p><h4 id="业务代码如何写避免过期读？"><a href="#业务代码如何写避免过期读？" class="headerlink" title="业务代码如何写避免过期读？"></a>业务代码如何写避免过期读？</h4><p>针对上节的介绍，我们可以通过判断位点和GTID集合，结合semi-sync半同步复制，判断一主多从不会出现过期读，那么在代码中如何操作实现？</p><h5 id="等主库位点"><a href="#等主库位点" class="headerlink" title="等主库位点"></a>等主库位点</h5><p>这里需要介绍一条数据库sql指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 这里file是master主库上的log文件名，pos是执行到的文件位点，timeout是超时时间</span><br><span class="line">-- 这个的返回表示，备库执行到主库的位点经历了多少个binlog，也就是执行了多少事务，如果返回为正整数，表示同步完成，返回-1表示失败，null表示发生了异常。</span><br><span class="line">select master_pos_wait(file, pos[, timeout]);</span><br></pre></td></tr></table></figure><p>1.更新代码完成之后，查询请求进来，先到master执行show master status，查到file 和pos。</p><p>2.任意选择一个备库，执行select master_pos_wait(file, pos[, timeout])。</p><p>3.如果返回正整数表示该备库已经同步完成，将查询在该备库中进行否则到强制到主库中执行。</p><h5 id="等主库GTID集合"><a href="#等主库GTID集合" class="headerlink" title="等主库GTID集合"></a>等主库GTID集合</h5><p>如果数据库开启了GTID模式，这里同样介绍一个指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--  gtid_set理解为一个字符串，不同于位点方式的是，更新操作完成之后这种方式会返回给客户端这个gtid，客户端在继续进行查询的时候只需要把这个gtid到备库进行判断。</span><br><span class="line">-- 该命令执行逻辑，1.等待，直到该备库中记录了执行该事务的id，返回0  2.超时返回-1，由业务决定走主库还是放弃。</span><br><span class="line">select wait_for_executed_gtid_set(gtid_set, 1);</span><br></pre></td></tr></table></figure><p>1.客户端执行在主库执行更新请求，更新事务提交成功，返回给客户端gtid。</p><p>2.客户端到备库通过拿到的gtid执行select wait_for_executed_gtid_set(gtid_set, 1)。</p><p>3.返回0，表示备库中已经有执行了这个更新事务，可以进行查询。</p><h5 id="等主库位点vs等主库GTID"><a href="#等主库位点vs等主库GTID" class="headerlink" title="等主库位点vs等主库GTID"></a>等主库位点vs等主库GTID</h5><p>相对等主库位点来说，等主库GTID方式减少了一次show master status的主库查询，对主库比较友好。但是GTID方案，如何让客户端的返回中包含事务执行的gtid？</p><ul><li><strong>需要将参数 session_track_gtids 设置为OWN_GTID，然后通过 API 接口mysql_session_track_get_first从返回包解析出 GTID 的值即可。</strong></li></ul><p><img src="http://arthornye.github.io/images/gtid.jpg" alt="cmd-markdown-logo"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本篇文章主要是介绍如何在数据库一主多从类似的读写分离的架构下要如何避免过期读。虽然我们发现GTID这种方式好像能够完全避免过期读，表现比较优秀，但是实际场景下我们还是多种方式混合使用。总之我们还是需要客户端去判断，当前的请求是否可以接受过期读，如果可以接受，那完全没有必要采用等待位点或者等待GTID的方案，否则无需采用。这些都需要在实际的业务场景中去检验和选择。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mysql在读写分离的场景下，可能是一主一从，一主都从。但是在实际应用场景中需要解决一个重要的问题就是&lt;strong&gt;“过期读”&lt;/strong&gt;。本篇主要介读写分离可能的架构方式以及如何解决该问题。&lt;/p&gt;
&lt;h4 id=&quot;强制从主库读取&quot;&gt;&lt;a href=&quot;#强制从主库
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql排序工作原理</title>
    <link href="http://jianghao.wang/2019/mysql%E6%8E%92%E5%BA%8F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://jianghao.wang/2019/mysql排序工作原理/</id>
    <published>2019-01-12T08:44:08.453Z</published>
    <updated>2019-01-12T14:46:45.470Z</updated>
    
    <content type="html"><![CDATA[<p>mysql排序主要针对order by指令，本篇主要介绍mysql是如何进行排序以及性能优化的。我们从全字段排序和rowid排序两种排序方式介绍，当然这两种排序都基于基本的排序算法，归并排序。归并排序主要应用于大文件排序，内存有限的情况下，先将文件分为多个有序的小文件，然后将小文件进行排序，时间复杂度nlogn，当然文件的存储形式还有io的时间消耗，这也是数据库性能优化的主要目标，尽量减少磁盘io。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `words` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `word` varchar(64) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=2800001 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><h4 id="全字段排序-vs-rowId排序"><a href="#全字段排序-vs-rowId排序" class="headerlink" title="全字段排序 vs rowId排序"></a>全字段排序 vs rowId排序</h4><p>顾名思义，全字段排序的意思是将记录的所有行都放到内存中进行排序，排序成功之后取固定的字段或者数量返回给客户端。mysql将所有的排序记录都优先考虑放在内存中，我们通过查询指令可以查到配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- sql query</span><br><span class="line">use souche_study;</span><br><span class="line">show variables like &quot;%sort%&quot;</span><br><span class="line"></span><br><span class="line">-- result</span><br><span class="line">innodb_disable_sort_file_cacheOFF</span><br><span class="line">innodb_ft_sort_pll_degree2</span><br><span class="line">innodb_sort_buffer_size1048576//innodb默认的排序大小</span><br><span class="line">max_length_for_sort_data1024</span><br><span class="line">max_sort_length1024</span><br><span class="line">myisam_max_sort_file_size9223372036853727232</span><br><span class="line">myisam_sort_buffer_size8388608</span><br><span class="line">sort_buffer_size262144 //默认的排序内存大小</span><br></pre></td></tr></table></figure><p>排序的过程如下：</p><p><img src="https://arthornye.github.io/images/orderby.jpg" alt="cmd-markdown-logo"></p><h4 id="analyze-table-命令"><a href="#analyze-table-命令" class="headerlink" title="analyze table 命令"></a>analyze table 命令</h4><p>检测和重组表的关键字分布情况。用来分析和存储表的关键字的分布，使得系统获得准确的统计信息。在执行查询计划的时候可能会错误估计要扫描的条数，导致应用不到索引，通过analyze table命令可以使估计值更加准确。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyze table table_name;//analyze+表名</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mysql排序主要针对order by指令，本篇主要介绍mysql是如何进行排序以及性能优化的。我们从全字段排序和rowid排序两种排序方式介绍，当然这两种排序都基于基本的排序算法，归并排序。归并排序主要应用于大文件排序，内存有限的情况下，先将文件分为多个有序的小文件，然后
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql加锁分析实践</title>
    <link href="http://jianghao.wang/2019/mysql%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90%E5%AE%9E%E8%B7%B5/"/>
    <id>http://jianghao.wang/2019/mysql加锁分析实践/</id>
    <published>2019-01-02T01:58:10.893Z</published>
    <updated>2019-01-22T01:53:39.684Z</updated>
    
    <content type="html"><![CDATA[<p>实践基于以下表结构，分析各个情况下加锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tablet` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  `d` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into t values(0,0,0),(5,5,5),</span><br><span class="line">(10,10,10),(15,15,15),(20,20,20),(25,25,25);</span><br></pre></td></tr></table></figure><h4 id="唯一主键加锁"><a href="#唯一主键加锁" class="headerlink" title="唯一主键加锁"></a>唯一主键加锁</h4><p>先执行session1，query ok :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line"> /*主键等值查询gap锁 */</span><br><span class="line">begin;</span><br><span class="line">select * from tablet where id=10 lock in share mode;</span><br></pre></td></tr></table></figure><p>再执行session2，query ok:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">/*可以正常插入判定没有gap锁，针对唯一索引优化*/</span><br><span class="line">insert into tablet values(9,8,8);</span><br></pre></td></tr></table></figure><p>再执行session3，query blocked：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">update tablet set c=11 where id =10;</span><br></pre></td></tr></table></figure><blockquote><p><strong>唯一主键等值查询不加gap间隙锁，只加对应值的行锁。</strong></p></blockquote><p>这里将session1换成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line"> /*主键范围查询gap锁 */</span><br><span class="line">begin;</span><br><span class="line">select * from tablet where id&gt;=10 and id&lt;15 lock in share mode;</span><br></pre></td></tr></table></figure><p>session2，query ok：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">insert into tablet values(16,8,8);</span><br></pre></td></tr></table></figure><p>session3，query blocked：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">/*gap锁*/</span><br><span class="line">insert into tablet values(12,8,8);</span><br></pre></td></tr></table></figure><p>session4，query blocked：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">/*这里范围查询会多加一个行锁，实际上会感觉比较多余,因为并没有筛选到这个值,但是从逻辑上理解在索引上扫描一个范围并不知道什么时候结束，所以会有多出来的一个行锁，可能为了不违背两阶段锁的协议*/</span><br><span class="line">update tablet set c =0 where id=15;</span><br></pre></td></tr></table></figure><p>这里如果我们将session1中id&lt;15加上一个等号条件也就是id&lt;=15，mysql后在id=20这行也加上锁，同时多了一个gap锁也就是多了一整个<strong>next key lock (15,20]</strong>，这是相当奇怪的 ，因为扫描到15的时候可以确定不再往后进行扫描。这种貌似可以优化的场景但是并没有进行优化。</p><p><strong>最终上面的test发现会加id为10记录的行锁+(10,15]的next key lock。总结下，mysql在唯一主键索引查询的条件为范围索引的条件下会默认向后多加一个next key lock，等值查询直加行锁。</strong></p><blockquote><p><strong>lock in share mode 这种方式只会在索引上加锁，在不回表的情况下不会锁主键索引记录。for update 的方式不管是否回表都会锁主键记录。</strong></p></blockquote><h4 id="唯一普通索引加范围锁"><a href="#唯一普通索引加范围锁" class="headerlink" title="唯一普通索引加范围锁"></a>唯一普通索引加范围锁</h4><p>唯一普通索引有独立的树结构，在加锁上跟主键的索引是有区别的，防止根据主键更新造成不一致读会加行锁。</p><p>将c修改为唯一索引，执行下面的session1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line"></span><br><span class="line">alter table tablet drop index c;</span><br><span class="line">alter table tablet add unique index c(c);</span><br><span class="line">show index from tablet;</span><br><span class="line"></span><br><span class="line">begin;</span><br><span class="line">/* 普通唯一索引加范围锁 */</span><br><span class="line">select * from tablet where c &gt;10 and c &lt;=15 lock in share mode;</span><br><span class="line">/* == select d from tablet where c &gt;10 and c&lt;=15 for update; */</span><br></pre></td></tr></table></figure><p>然后执行session2，query blocked :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">-- 唯一普通索引c加锁范围(10,15],(15,20]，跟上面保持一致，需要多扫描一行数据并加锁（虽然感觉完全没有必要），主键索引加id=15行锁。</span><br><span class="line">-- query ok c=21</span><br><span class="line">insert into tablet values(16,21,8);</span><br><span class="line">-- query blocked c=16 gap间隙锁 </span><br><span class="line">insert into tablet values(19,16,8);</span><br><span class="line">-- blocked c=15 行锁</span><br><span class="line">update tablet set d=111 where c=15;</span><br><span class="line">-- query ok，没有加锁，回表的时候做了优化</span><br><span class="line">update tablet set d=111 where id=20;</span><br><span class="line">-- blocked 加了行锁</span><br><span class="line">update tablet set d=111 where id=15;</span><br></pre></td></tr></table></figure><blockquote><p><strong>唯一索引范围锁搜索到不符合预期范围的第一个值，以该值为最终值进行加锁，上面的语句如果改成c&lt;15那么锁范围变成(10,15]。</strong></p></blockquote><h4 id="非唯一普通索引加范围锁"><a href="#非唯一普通索引加范围锁" class="headerlink" title="非唯一普通索引加范围锁"></a>非唯一普通索引加范围锁</h4><p>类比上面的情况多了一个next key lock，执行session1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">begin;</span><br><span class="line">-- select * from  tablet where d&gt;10 and d&lt;=15 for update;</span><br><span class="line">/* 非唯一索引加范围锁 */</span><br><span class="line">select * from tablet where d &gt;10 and d &lt;=15 lock in share mode;</span><br></pre></td></tr></table></figure><p>执行session2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">use souche_study;</span><br><span class="line">-- 同样的情况变成了非唯一索引，加锁情况一致(10,15]，(15,20]（这里并没有多加个间隙锁，作了优化），主键索引加id=15行锁</span><br><span class="line">-- query ok d=8</span><br><span class="line">insert into tablet values(11,8,8)</span><br><span class="line">-- query ok d=23</span><br><span class="line">insert  into tablet values(13,7,23);</span><br><span class="line">-- blocked  d=20行锁</span><br><span class="line">update tablet set c=22 where d=20;</span><br><span class="line">-- query blocked  d=16间隙锁</span><br><span class="line">insert into tablet values(14,16,16);</span><br><span class="line">-- query ok </span><br><span class="line">update tablet set c =24 where id =20;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><blockquote><p><strong>非唯一索引范围锁搜索到不符合预期范围的第一个值，以该值为最终值进行加锁，上面的语句如果改成c&lt;15那么锁范围变成(10,15]。这里并不会在右边多加间隙锁。</strong></p></blockquote><p>#### </p><h4 id="非唯一普通索引加范围锁倒序"><a href="#非唯一普通索引加范围锁倒序" class="headerlink" title="非唯一普通索引加范围锁倒序"></a>非唯一普通索引加范围锁倒序</h4><p>倒序排序默认会从后往前扫描索引，mysql默认多加一个间隙锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- session1</span><br><span class="line">use souche_study;</span><br><span class="line">begin;</span><br><span class="line">-- 锁了(5,10],(10,15],(15,20],(20,25)</span><br><span class="line">select * from tablet where d&gt;=15 and d&lt;=20 order by d desc lock in share mode;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- session2</span><br><span class="line">use souche_study;</span><br><span class="line">-- query ok</span><br><span class="line">update tablet set c=14 where d =25;</span><br><span class="line">-- blocked</span><br><span class="line">insert into tablet values(17,17,6);</span><br><span class="line">-- query ok</span><br><span class="line">update tablet set c = 18 where d=5;</span><br><span class="line">-- blocked 唯一索引不存在(20,25)间隙锁</span><br><span class="line">insert into tablet values(16,16,21);</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总结一下，分析加锁情况主要需要区分出唯一索引和非唯一索引。唯一索引是左半区或者右半区可能插入，非唯一索引是左右半区都可能插入。并且有几个原则和几个优化，原则：</p><blockquote><p>1.加锁的基本单位是next key lock，前开后闭区间。</p><p>2.mysql扫描到的对象才会进行加锁。</p></blockquote><p>优化：</p><blockquote><p>1.索引的唯一等值查询，next key lock退化为行锁。（非唯一等值查询不退化）</p><p>2.等值查询或者范围查询向右遍历到最后一个不符合期望的值，即使是非唯一索引也不会在该值的右侧加一个间隙锁。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实践基于以下表结构，分析各个情况下加锁：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql查询性能优化</title>
    <link href="http://jianghao.wang/2018/mysql%E6%9F%A5%E8%AF%A2%E6%A3%80%E7%B4%A2%E6%80%A7%E8%83%BD%E8%AF%AD%E5%8F%A5%E8%AE%B0%E5%BD%95/"/>
    <id>http://jianghao.wang/2018/mysql查询检索性能语句记录/</id>
    <published>2018-12-28T09:30:02.605Z</published>
    <updated>2019-01-10T01:53:54.447Z</updated>
    
    <content type="html"><![CDATA[<h4 id="查询长时间不返回"><a href="#查询长时间不返回" class="headerlink" title="查询长时间不返回"></a>查询长时间不返回</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.processlist;//这条语句跟下面的语句相同</span><br><span class="line">show processlist;//展示出当前的进程信息</span><br></pre></td></tr></table></figure><p>特殊的，在模拟一种MDL写锁阻塞的情况可以通过该命令查到阻塞的查询，这种情况一般第一时间执行该语句：</p><p>通过kill指令杀掉线程，恢复执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill 4;//kill pid,通过上面的命令查询到可以查询到对应线程的pid</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.innodb_locks;//可以查看死锁，注意锁等待信息不会在这里显示出来，除非发生死锁。包括gap锁和x锁可能导致的死锁等待，数据库开启了死锁等待机制可以检测死锁。</span><br></pre></td></tr></table></figure><h4 id="开启慢查询"><a href="#开启慢查询" class="headerlink" title="开启慢查询"></a>开启慢查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &quot;%query%&quot;</span><br></pre></td></tr></table></figure><p>result:</p><p><img src="https://arthornye.github.io/images/querylog.jpg" alt="cmd-markdown-logo"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 会在当前session立即生效</span><br><span class="line">set global slow_query_log=&apos;ON&apos;;</span><br><span class="line">-- 不会在当前的session生效，很坑，需要开启另一个session才会查询到设置效果</span><br><span class="line">set global long_query_time=0;</span><br></pre></td></tr></table></figure><p>截取一个slow log的记录结果：</p><p><img src="https://arthornye.github.io/images/slowlog.jpg" alt="cmd-markdown-logo"></p><h4 id="慢查询优化步骤"><a href="#慢查询优化步骤" class="headerlink" title="慢查询优化步骤"></a>慢查询优化步骤</h4><p>业务上有个审核表的表结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `audit_order` (</span><br><span class="line">  `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &apos;id&apos;,</span><br><span class="line">  `order_id` int(11) unsigned NOT NULL COMMENT &apos;销售订单号&apos;,</span><br><span class="line">  `order_code` varchar(32) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;订单中心订单号&apos;,</span><br><span class="line">  `user_id` varchar(32) DEFAULT NULL COMMENT &apos;申请人id&apos;,</span><br><span class="line">  `auditor_id` varchar(32) DEFAULT NULL COMMENT &apos;审核人id&apos;,</span><br><span class="line">  `status` tinyint(4) NOT NULL DEFAULT &apos;10&apos; COMMENT &apos;状态 10：待审核 20：审核通过 30：审核驳回 40：审核未通过&apos;,</span><br><span class="line">  `reject_reason` varchar(128) DEFAULT NULL COMMENT &apos;不通过原因&apos;,</span><br><span class="line">  `updater_id` varchar(32) DEFAULT &apos;&apos; COMMENT &apos;更新人&apos;,</span><br><span class="line">  `date_create` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &apos;创建时间&apos;,</span><br><span class="line">  `date_update` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &apos;更新时间&apos;,</span><br><span class="line">  `business_type` varchar(32) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `idx_order_id` (`order_id`),</span><br><span class="line">  KEY `idx_order_code` (`order_code`),</span><br><span class="line">  KEY `date_update` (`date_update`),</span><br><span class="line">  KEY `idx_date_create` (`date_create`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=50571 DEFAULT CHARSET=utf8 COMMENT=&apos;订单审核表&apos;;</span><br></pre></td></tr></table></figure><p>分析下面语句实际扫描的行数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, order_code, status, date_create, date_update</span><br><span class="line">, reject_reason</span><br><span class="line">FROM audit_order</span><br><span class="line">WHERE (business_type = &apos;CUSTOMIZED_CAR&apos;</span><br><span class="line">AND status IN (20)</span><br><span class="line">AND date_update &gt; &apos;2018-01-01&apos;)</span><br><span class="line">ORDER BY date_update</span><br><span class="line">LIMIT 100</span><br></pre></td></tr></table></figure><p>我们explain一下：</p><p><img src="https://arthornye.github.io/images/noindex.jpg" alt="cmd-markdown-logo"></p><p>这里分析显示的扫描行数rows是24786行，但是实际上我们通过慢查询日志发现，实际的扫描行数是接近五万行，接近两倍。using index condition表示通过date_update索引查询过滤到记录之后回表，执行时间在全表数据较少的情况下用了100ms，符合我们的预期：</p><p><img src="https://arthornye.github.io/images/noindexlog.jpg" alt="cmd-markdown-logo"></p><p>加一个索引，重新执行explain，并观察慢查询日志真实扫描行数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE audit_order</span><br><span class="line">ADD INDEX idx_type_status_date (status, business_type, date_update);</span><br></pre></td></tr></table></figure><p><img src="https://arthornye.github.io/images/useindex.jpg" alt="cmd-markdown-logo"></p><p><img src="https://arthornye.github.io/images/useindexlog.jpg" alt="cmd-markdown-logo"></p><p><strong>通常我们观察range级别是索引可用级别，但是实际的扫描行数还是需要参考explain的rows和日志中的rows_examinzed，其中explain是估计值，真正准确的还是rows_examinzed。</strong></p><h4 id="count-性能"><a href="#count-性能" class="headerlink" title="count(*)性能"></a>count(*)性能</h4><p>innnodb在统计行数的时候没有像myisam一样保存了行数，需要重新扫描一遍表。我们比较一下集中查询方式的性能。插入一个两百多万行的数据表word。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER ;;</span><br><span class="line">CREATE DEFINER=`root`@`localhost` PROCEDURE `inputdata`()</span><br><span class="line">begin</span><br><span class="line">  declare i int;</span><br><span class="line">  set i=1;</span><br><span class="line">  while(i&lt;=2800000)do</span><br><span class="line">    insert into words values(i,i);</span><br><span class="line">    set i=i+1;</span><br><span class="line">  end while;</span><br><span class="line">end;;</span><br><span class="line">DELIMITER ;</span><br><span class="line">call inputdata;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-- count(id)</span><br><span class="line"># Time: 2019-01-09T14:10:05.038579Z</span><br><span class="line"># User@Host: root[root] @ localhost []  Id:    14</span><br><span class="line"># Query_time: 0.349229  Lock_time: 0.000062 Rows_sent: 1  Rows_examined: 0</span><br><span class="line">SET timestamp=1547043005;</span><br><span class="line">select count(id) from words;</span><br><span class="line"></span><br><span class="line">-- count(1)</span><br><span class="line"># Time: 2019-01-09T14:10:02.488929Z</span><br><span class="line"># User@Host: root[root] @ localhost []  Id:    14</span><br><span class="line"># Query_time: 0.305565  Lock_time: 0.000060 Rows_sent: 1  Rows_examined: 0</span><br><span class="line">SET timestamp=1547043002;</span><br><span class="line">select count(1) from words;</span><br><span class="line"></span><br><span class="line">-- count(字段)</span><br><span class="line"># Time: 2019-01-09T14:09:56.943701Z</span><br><span class="line"># User@Host: root[root] @ localhost []  Id:    14</span><br><span class="line"># Query_time: 0.544218  Lock_time: 0.000066 Rows_sent: 1  Rows_examined: 2709998</span><br><span class="line">SET timestamp=1547042996;</span><br><span class="line">select count(word) from words;</span><br><span class="line"></span><br><span class="line">-- count(*)</span><br><span class="line"># Time: 2019-01-09T14:09:59.196291Z</span><br><span class="line"># User@Host: root[root] @ localhost []  Id:    14</span><br><span class="line"># Query_time: 0.301123  Lock_time: 0.000057 Rows_sent: 1  Rows_examined: 0</span><br><span class="line">SET timestamp=1547042999;</span><br><span class="line">select count(*) from words;</span><br></pre></td></tr></table></figure><p>结论：<strong>count(*)约等于count(1)&gt;count(id)&gt;count(字段)，推荐使用前三个</strong>，count字段有磁盘io，会把字段的值取出来，进行判断是否为null值。通常我们通过innodb的事务性特征，将总记录条数在一个事务中去取，mysql即使在异常情况下也不会导致数据不一致。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;查询长时间不返回&quot;&gt;&lt;a href=&quot;#查询长时间不返回&quot; class=&quot;headerlink&quot; title=&quot;查询长时间不返回&quot;&gt;&lt;/a&gt;查询长时间不返回&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>react学习</title>
    <link href="http://jianghao.wang/2018/React%E5%AD%A6%E4%B9%A0/"/>
    <id>http://jianghao.wang/2018/React学习/</id>
    <published>2018-12-17T11:01:38.088Z</published>
    <updated>2019-01-09T13:28:16.746Z</updated>
    
    <content type="html"><![CDATA[<h4 id="setState异步执行"><a href="#setState异步执行" class="headerlink" title="setState异步执行"></a>setState异步执行</h4><p>在实践的过程中发现一个奇怪的现象，我们如果先进行setState在进行网络请求，那么网络请求很可能提前进行，也就是setState是异步的，正确的同步写法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">onPageChange = (page) =&gt; &#123;</span><br><span class="line">       if(this.state.isSaleOrder)&#123;</span><br><span class="line">           this.setState(&#123;</span><br><span class="line">               sale_page:page,</span><br><span class="line">           &#125;,() =&gt;&#123;//这要采用回调的方式，更新完state再继续进行网络请求，不然会造成异常情况</span><br><span class="line">               this.getOrderManageList();</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           this.setState(&#123;</span><br><span class="line">               purchase_page:page,</span><br><span class="line">           &#125;,() =&gt;&#123;</span><br><span class="line">               this.getOrderManageList();</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="div设置不可见"><a href="#div设置不可见" class="headerlink" title="div设置不可见"></a>div设置不可见</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;display</span> <span class="attr">:</span> <span class="attr">this.state.reject</span>&#125;&#125;&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Form</span> <span class="attr">layout</span>=<span class="string">"inline"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FormItem</span> <span class="attr">label</span>=<span class="string">"审核打回时间段筛选"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">RangePicker</span> <span class="attr">placeholder</span>=<span class="string">&#123;[</span> "开始时间", "结束时间"]&#125; <span class="attr">onChange</span>=<span class="string">&#123;(data)</span>=&gt;</span>&#123; this.state.rejectStartTime = data[0]; this.state.rejectEndTime = data[1] &#125;&#125; /&gt;<span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FormItem</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">type</span>=<span class="string">"primary"</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>this.getAuditList()&#125;&gt; 筛选<span class="tag">&lt;/<span class="name">Button</span>&gt;</span><span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以通过设置<strong>display:’none’</strong>不显示当前div，通过设置<strong>display:’block’</strong>显示当前div。</p><h4 id="通过Form设置组件布局"><a href="#通过Form设置组件布局" class="headerlink" title="通过Form设置组件布局"></a>通过Form设置组件布局</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginTop:</span> <span class="attr">24</span> &#125;&#125;&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Form</span> <span class="attr">layout</span>=<span class="string">"inline"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FormItem</span> <span class="attr">label</span>=<span class="string">"请选择业务类型:"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Select</span> <span class="attr">defaultValue</span>=<span class="string">"全部"</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width:</span> <span class="attr">120</span> &#125;&#125; <span class="attr">onChange</span>=<span class="string">&#123;this.onChangeBusinessType&#125;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Option</span> <span class="attr">value</span>=<span class="string">"ALL"</span>&gt;</span>全部<span class="tag">&lt;/<span class="name">Option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Option</span> <span class="attr">value</span>=<span class="string">"COMMON_NEW_RETAIL"</span>&gt;</span>普通订单<span class="tag">&lt;/<span class="name">Option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Option</span> <span class="attr">value</span>=<span class="string">"CUSTOMIZED_CAR"</span>&gt;</span>定制车订单<span class="tag">&lt;/<span class="name">Option</span>&gt;</span><span class="tag">&lt;/<span class="name">Select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过<strong>label:””</strong>设置左边的显示tab。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;setState异步执行&quot;&gt;&lt;a href=&quot;#setState异步执行&quot; class=&quot;headerlink&quot; title=&quot;setState异步执行&quot;&gt;&lt;/a&gt;setState异步执行&lt;/h4&gt;&lt;p&gt;在实践的过程中发现一个奇怪的现象，我们如果先进行setSta
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql中的隐式类型转换</title>
    <link href="http://jianghao.wang/2018/mysql%E4%B8%AD%E7%9A%84%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://jianghao.wang/2018/mysql中的隐式类型转换/</id>
    <published>2018-12-04T04:52:03.232Z</published>
    <updated>2019-02-21T03:25:17.817Z</updated>
    
    <content type="html"><![CDATA[<h4 id="mysql中的隐式类型转换？"><a href="#mysql中的隐式类型转换？" class="headerlink" title="mysql中的隐式类型转换？"></a>mysql中的隐式类型转换？</h4><p>mysql innodb有行锁的实现，行锁会针对当前读进行加排他锁。</p><p><strong>1.对索引字段做函数操作会导致索引失效，破坏索引的有序性，优化器不走b+树搜索</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from trade_log where month(t_modify)=7;</span><br></pre></td></tr></table></figure><p>上面的语句没办法使用到索引，不可以在索引的字段上加函数操作，这里复杂的函数操作导致了破坏索引的扫描，但是即使类似where id+1=1000这种操作优化器也并不会做优化操作，需要写成where id= 1000-1。</p><h4 id="隐式字符编码转换导致索引失效"><a href="#隐式字符编码转换导致索引失效" class="headerlink" title="隐式字符编码转换导致索引失效"></a>隐式字符编码转换导致索引失效</h4><p>在应用过程中通常会有字段字符集不统一的问题，如a表字段order_code为utf8mb4，关联 b表retail_order_code字段字符集为utf8。utf8mb4为utf8的超集合，也就是如果用a表取关联b表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from a,b where a.order_code=b.retail_order_code;</span><br></pre></td></tr></table></figure><p>实际上这句话在被连接的表上的逻辑==：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from b where convert(b.retail_order_code using utf8mb4) =a.value;</span><br></pre></td></tr></table></figure><p>所以隐式字符编码转换索引失效的条件：<strong>连接过程中被驱动的表的索引字段加函数操作。</strong></p><p>解决的方法：</p><p>1.改字符集，改成同样的字符集。</p><p>2.将驱动表的字符集用函数操作改为被驱动表的字符集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from a,b where convert(a.order_code using utf8) = b.retail_order_code;</span><br></pre></td></tr></table></figure><p>上面的语句在被连接表的逻辑变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from b where b.retail_order_code=a.value;//字符集一致，不需要做索引函数操作</span><br></pre></td></tr></table></figure><h4 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h4><p>在mysql的数据结构中，varchar和int的类型转换级别是不一样的，参考上面的分析方法，我们通过实践语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &quot;10&quot;&gt;9;//输出 1代表将字符串转成了数字</span><br></pre></td></tr></table></figure><p>那么我们可以得出结论，如果一个表a中有个varchar(32)的字段为索引字段order_code, 但是我们执行语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from a where order_code=1111;//会导致全表扫描。</span><br></pre></td></tr></table></figure><p><strong>便于理解，我们将其定义为一个父集一个子集，父集可以自动convert转换为子集。上面utf8为父集，utf8mb4为子集，int为子集，varchar为父集。如果父集为索引字段，子集为查询的字段，那么会出现索引失效。</strong></p><h4 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Illegal mix of collations (utf8_unicode_ci,IMPLICIT) and (utf8_general_ci,IMPLICIT) for operation &apos;=&apos;</span><br></pre></td></tr></table></figure><p>虽然都是utf8，但是mysql在比较的时候无法用具体的字符集进行比较，需要强制指定字符集：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- convert(t1.order_code using utf8)</span><br><span class="line">-- convert(t1.order_code using uft8) COLLATE utf8_unicode_ci</span><br><span class="line">SELECT t1.retail_order_code</span><br><span class="line">, (</span><br><span class="line">SELECT CASE t2.order_status</span><br><span class="line">WHEN 150 THEN 3</span><br><span class="line">ELSE 4</span><br><span class="line">END</span><br><span class="line">), t1.tmail_order_id, 1,t1.step_count, t1.disburse_fee</span><br><span class="line">, t1.voucher_price, t1.deleted, t1.sku_id, t1.date_create, t1.date_update</span><br><span class="line">, &apos;normal&apos;, &apos;retainge&apos;, 50, &apos;3393340311&apos;, &apos;大搜车旗舰店&apos;</span><br><span class="line">, 50</span><br><span class="line">FROM retail_marketing_order t1</span><br><span class="line">LEFT JOIN retail_order t2 ON convert(t1.retail_order_code USING utf8) = t2.order_code;</span><br></pre></td></tr></table></figure><p>值得注意的是convert(t1.order_code using uft8) COLLATE utf8_unicode_ci和convert(t1.order_code using utf8)虽然让字符集标准化了，通过explain我们发现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1SIMPLEt1NULLALLNULLNULLNULLNULL186100.00NULL</span><br><span class="line">1SIMPLEt2NULLindexorder_code_indexsync_index107NULL113582100.00Using where; Using index; Using join buffer (Block Nested Loop)</span><br></pre></td></tr></table></figure><p>sql查询日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Query_time: 0.002302  Lock_time: 0.000244 Rows_sent: 186  Rows_examined: 372  一次回表查询</span><br><span class="line">SET timestamp=1548079631;</span><br><span class="line">SELECT t1.retail_order_code</span><br><span class="line">  , (</span><br><span class="line">    SELECT CASE t2.order_status</span><br><span class="line">        WHEN 150 THEN 3</span><br><span class="line">        ELSE 4</span><br><span class="line">      END</span><br><span class="line">  ), t1.tmail_order_id, 1,t1.step_count, t1.disburse_fee</span><br><span class="line">  , t1.voucher_price, t1.deleted, t1.sku_id, t1.date_create, t1.date_update</span><br><span class="line">  , &apos;distributor&apos;, &apos;retainge&apos;, 50</span><br><span class="line">  , 50</span><br><span class="line">FROM retail_marketing_order t1</span><br><span class="line">  LEFT JOIN retail_order t2 ON convert(t1.retail_order_code USING utf8) = t2.order_code;</span><br></pre></td></tr></table></figure><p><strong>join操作在驱动表上加父集合（convert using utf8）使用索引。</strong></p><h4 id="Using-join-buffer-Block-Nested-Loop"><a href="#Using-join-buffer-Block-Nested-Loop" class="headerlink" title="Using join buffer (Block Nested Loop)"></a>Using join buffer (Block Nested Loop)</h4><p>BNL算法建立在join操作的基础上，join操作有一个内表一个外表，外表和内表两层循环。BNL算法取出100条放到join buffer中，内层循环直接从buffer中全部匹配出来100条，这样操作减少了磁盘io</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;mysql中的隐式类型转换？&quot;&gt;&lt;a href=&quot;#mysql中的隐式类型转换？&quot; class=&quot;headerlink&quot; title=&quot;mysql中的隐式类型转换？&quot;&gt;&lt;/a&gt;mysql中的隐式类型转换？&lt;/h4&gt;&lt;p&gt;mysql innodb有行锁的实现，行锁会
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql索引介绍</title>
    <link href="http://jianghao.wang/2018/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/"/>
    <id>http://jianghao.wang/2018/mysql索引介绍/</id>
    <published>2018-11-24T07:16:28.373Z</published>
    <updated>2019-01-22T10:02:35.428Z</updated>
    
    <content type="html"><![CDATA[<h4 id="索引的几种数据模型"><a href="#索引的几种数据模型" class="headerlink" title="索引的几种数据模型"></a>索引的几种数据模型</h4><p>数据库引擎在设计索引结构的时候首先需要数据结构，怎样的数据结构能够兼容查询和更新，在不同的场景下选择也有所不同。下面主要介绍几种模型以及数据结构上的利弊。</p><h5 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h5><p>哈希索引数据模型类似HashMap，KV结构，通过数组+链表的方式去存储。<strong>利于等值查询（单值查询），不利于多值查询（范围查询），利于更新。</strong></p><p>应用：主要是应用在memcache，nosql等。主要为单值查询比较多的场景，更新性能也不差，不考虑IO。</p><h5 id="有序数组索引"><a href="#有序数组索引" class="headerlink" title="有序数组索引"></a>有序数组索引</h5><p>有序数组数据模型类比数组，有序的记录。<strong>利于查询（单值查询和多值查询表现都比较优秀），复杂度O(log n)，不利于更新（需要移动位置）。</strong></p><p>应用：有序数组索引只适用于静态存储引擎，比如你要保存的是某一年某个城市所有的人口信息。多为查询，更新比较少。</p><h5 id="N叉树索引"><a href="#N叉树索引" class="headerlink" title="N叉树索引"></a>N叉树索引</h5><p>N叉树索引数据模型，类比mysql中的B+TREE。<strong>利于IO，查询和更新的表现比较平衡。数据库数据存储在磁盘，多叉树可以减少大量IO。</strong></p><p>应用：mysql innodb采用的b+tree，相较于我们通常看到的平衡二叉树（查询O(log n)，更新O(log n)）兼容了磁盘IO，在大数据存储查询上更有优势。</p><h4 id="innodb的索引模型"><a href="#innodb的索引模型" class="headerlink" title="innodb的索引模型"></a>innodb的索引模型</h4><p>innodb采用b+tree维护每个索引，每个索引对应的都是一个b+tree多叉树的数据结构，其中mysql会为每个表默认生成一个字自增的primary key，作为表的唯一主键。那么我们将mysql的索引类型可以简单的分为主键索引的普通索引。</p><h5 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h5><p>mysql的主键索引我们又可以称之为聚簇索引，索引叶子结点记录了所有的字段信息。</p><p><img src="http://arthornye.github.io/images/mysql.png" alt="cmd-markdown-logo"></p><h5 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h5><p>普通索引只存储了索引的值+主键的值。普通索引查询之后，如果需要取出主键之外的信息，只要索引中不包含，就需要进行一个<strong>“回表”</strong>的操作。这里衍生出一种索引，叫做覆盖索引，意思是不需要回表，所查询的信息已经在普通索引中维护好了。例如我们上面建立的person表，card这个字段上是有一个普通索引的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from person where card=&apos;330...&apos;;//覆盖索引（不会进行回表）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from person where card=&apos;330...&apos;;//用不到覆盖索引（找到id后回表，在主键索引中再执行一次查询）</span><br></pre></td></tr></table></figure><h5 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h5><p>覆盖索引，上面的表中，我们如果根据单个字段的值建立索引，在根据索引遍历到记录之后需要进行回表操作。那么如果我们加索引index（name,card），数据在根据身份证去找名字的时候的查询语句就不需要回表，这个就叫<strong>覆盖索引</strong>。</p><p>可以看到覆盖索引其实也就是在我们通常称为<strong>联合索引</strong>的基础之上的。联合索引会导致一些失效的情况：</p><h4 id="普通索引和唯一索引如何选择"><a href="#普通索引和唯一索引如何选择" class="headerlink" title="普通索引和唯一索引如何选择"></a>普通索引和唯一索引如何选择</h4><p>两种索引的选择主要基于性能，从读和写考虑，普通索引的读和唯一索引的读性能差别基本不大。</p><p><img src="https://arthornye.github.io/images/changebuffer.jpg" alt="cmd-markdown-logo"></p><p><strong>普通索引不需要唯一约束校验，可以将更新语句存储到change buffer中，等到记录被读取的时候再直接更新内存记录，这样节省了一次随机读IO。尽量选择普通索引，能够改善更新效率。</strong></p><h5 id="redo-log-和-change-buffer"><a href="#redo-log-和-change-buffer" class="headerlink" title="redo log 和 change buffer"></a>redo log 和 change buffer</h5><p><strong>1.change buffer 在innodb的内存中，redo log是日志文件。</strong></p><p><strong>2.change buffer主要为了优化随机读，redo log主要优化随机写*（批量写入减少IO）。</strong></p><h4 id="in查询优化"><a href="#in查询优化" class="headerlink" title="in查询优化"></a>in查询优化</h4><p>业务表retail_order假设我们建立一个索引，索引sql如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table retail_order add index idx_type_code(business_type,order_code);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">retail_order1idx_type_code1business_typeA1NULLNULLBTREE</span><br><span class="line">retail_order1idx_type_code2order_codeA113582NULLNULLYESBTREE</span><br></pre></td></tr></table></figure><p>采用union all（不区分重复记录）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(SELECT *</span><br><span class="line">FROM retail_order</span><br><span class="line">WHERE business_type = &apos;CUSTOMIZED_CAR&apos;</span><br><span class="line">ORDER BY order_code</span><br><span class="line">LIMIT 100)</span><br><span class="line">UNION ALL</span><br><span class="line">(SELECT *</span><br><span class="line">FROM retail_order</span><br><span class="line">WHERE business_type = &apos;COMMON_NEW_RETAIL&apos;</span><br><span class="line">ORDER BY order_code</span><br><span class="line">LIMIT 100)</span><br><span class="line">ORDER BY order_code</span><br><span class="line">LIMIT 100;</span><br></pre></td></tr></table></figure><p>分析explain 和 慢查询日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Time: 2019-01-14T07:58:52.068234Z</span><br><span class="line"># User@Host: root[root] @ localhost []  Id:    10</span><br><span class="line"># Query_time: 0.109241  Lock_time: 0.000976 Rows_sent: 100  Rows_examined: 500</span><br><span class="line">SET timestamp = 1547452732;</span><br><span class="line">(SELECT *</span><br><span class="line">FROM retail_order</span><br><span class="line">WHERE business_type = &apos;CUSTOMIZED_CAR&apos;</span><br><span class="line">ORDER BY order_code</span><br><span class="line">LIMIT 100)</span><br><span class="line">UNION ALL</span><br><span class="line">(SELECT *</span><br><span class="line">FROM retail_order</span><br><span class="line">WHERE business_type = &apos;COMMON_NEW_RETAIL&apos;</span><br><span class="line">ORDER BY order_code</span><br><span class="line">LIMIT 100)</span><br><span class="line">ORDER BY order_code</span><br><span class="line">LIMIT 100;</span><br><span class="line">//慢查询日志显示扫描行数为（100+100）*2回表</span><br><span class="line"></span><br><span class="line">//这里是explain 的结果 ，扫描行数并不准确，100条的using filesort可以接受，在程序中排序也会耗费性能。</span><br><span class="line">1PRIMARYretail_orderNULLrefidx_type_codeidx_type_code82const1382100.00Using index condition</span><br><span class="line">2UNIONretail_orderNULLrefidx_type_codeidx_type_code82const56791100.00Using index condition</span><br><span class="line">NULLUNION RESULT&lt;union1,2&gt;NULLALLNULLNULLNULLNULLNULLNULLUsing temporary; Using filesort</span><br></pre></td></tr></table></figure><p>理论上用in查询会使索引失效，但是实际这里我们通过in查询在先前的索引基础上优化器是有做优化的，并且减少了数据库的扫描行数。这里暂时不知道如何做的这个优化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from retail_order where business_type in (&apos;CUSTOMIZED_CAR&apos;,&apos;COMMON_NEW_RETAIL&apos;)   order by order_code limit 100;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- explain result 扫描行数195行，做了优化</span><br><span class="line">1SIMPLEretail_orderNULLindexidx_type_codeorder_code_index99NULL19551.22Using where</span><br><span class="line"></span><br><span class="line">-- 慢查询日志结果 实际上只扫描了100行</span><br><span class="line"># administrator command: Ping;</span><br><span class="line"># Time: 2019-01-14T08:36:22.221282Z</span><br><span class="line"># User@Host: root[root] @ localhost []  Id:    10</span><br><span class="line"># Query_time: 0.108762  Lock_time: 0.000197 Rows_sent: 100  Rows_examined: 100</span><br><span class="line">SET timestamp=1547454982;</span><br><span class="line">select * from retail_order where business_type in (&apos;CUSTOMIZED_CAR&apos;,&apos;COMMON_NEW_RETAIL&apos;)   order by order_code limit 100;</span><br></pre></td></tr></table></figure><p><strong>对比发现，sql优化器有对这种情况的in查询做优化，实际上还是用到了索引。注意这里的耗时比较长主要因为传输的数据量比较大。</strong></p><h4 id="查看索引和库文件大小"><a href="#查看索引和库文件大小" class="headerlink" title="查看索引和库文件大小"></a>查看索引和库文件大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 库文件和索引大小存在information_schema库中的TABLES表</span><br><span class="line">use information_schema;</span><br><span class="line">select concat(round(sum(DATA_LENGTH/1024/1024),2),&apos;MB&apos;) as data  from TABLES where table_schema=&apos;souche_retail&apos;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">216.96MB</span><br></pre></td></tr></table></figure><p>查看线上的索引文件大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use information_schema;</span><br><span class="line">select concat(round(sum(DATA_LENGTH/1024/1024/1024),2),&apos;GB&apos;) as data  from TABLES where table_schema=&apos;souche_retail_pre&apos;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">16.97GB</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;索引的几种数据模型&quot;&gt;&lt;a href=&quot;#索引的几种数据模型&quot; class=&quot;headerlink&quot; title=&quot;索引的几种数据模型&quot;&gt;&lt;/a&gt;索引的几种数据模型&lt;/h4&gt;&lt;p&gt;数据库引擎在设计索引结构的时候首先需要数据结构，怎样的数据结构能够兼容查询和更新，在
      
    
    </summary>
    
    
      <category term="-mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql innodb日志模块介绍</title>
    <link href="http://jianghao.wang/2018/mysql%20innodb%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/"/>
    <id>http://jianghao.wang/2018/mysql innodb日志模块介绍/</id>
    <published>2018-11-17T14:45:21.552Z</published>
    <updated>2018-11-18T02:52:35.993Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍一下mysql的日志系统。我们都知道在数据库的生产环境上，可能会发生一些事故。例如之前有个同事在执行数据订正的时候，不小心将很多的订单数据中的凭证数据覆盖成了空。这样的操作第一时间肯定是想通过数据库备份的形式将数据恢复出来，这个时候你的DBA可能会告诉你，有一周的数据的备份。不幸的是，这个事故发生的情况并没有在一星期之内定位到原因。所幸，有一份较久的备份，DBA可以根据这个备份恢复到丢失前的那个节点。那么这里就需要提到mysql的日志系统是如何实现的，只介绍一下概念，具体的实践由伟大的DBA完成。</p><h4 id="mysql的日志模块以及如何保证一致性"><a href="#mysql的日志模块以及如何保证一致性" class="headerlink" title="mysql的日志模块以及如何保证一致性"></a>mysql的日志模块以及如何保证一致性</h4><p>mysql的日志主要分为物理日志redo log（重做日志）和bin log（归档日志）。这两种日志都是只针对更新操作进行记录，针对查询的记录不会记录到mysql的日志模块。更新语句执行的主要流程：</p><p><img src="http://arthornye.github.io/images/twostep.png" alt="cmd-markdown-logo"></p><h5 id="redo-log（重做日志）"><a href="#redo-log（重做日志）" class="headerlink" title="redo log（重做日志）"></a>redo log（重做日志）</h5><p>这个是只针对数据库引擎innodb才有的日志模块。我们可以类比我们在记账的时候，我们有一个账本，记录了每个顾客的账户余额记录，但是如果人特别多的时候我们很难找到每个顾客的记录然后做个更新操作（这里一次查询io一次更新io），最好的办法是将这次的消费记录更新计算的结果记录到一个“白板”上面，等到空闲的时候再去写账本（sync同步到数据库磁盘）。这个“白板”的功能就是redo log。当然这个“白板”也会有写完的时候，实际情况下redo log文件是存在物理文件中的，假设我们有四个redo log文件总共大小为4g，那么每个文件的容量为1g。</p><p><img src="http://arthornye.github.io/images/pointmove.png" alt="cmd-markdown-logo"></p><p>粉板和账本配合的整个过程，其实就是 MySQL 里经常说到WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。</p><h5 id="bin-log（归档日志）"><a href="#bin-log（归档日志）" class="headerlink" title="bin log（归档日志）"></a>bin log（归档日志）</h5><p>可以简单理解为是记录了又一句的更新sql语句，当你需要进行恢复的时候可以先将表恢复到某个历史时间点，然后通过bin log中的记录一个个去执行到丢失数据前的时间点。那么这两种日志有什么不同，为什么要做区分？</p><p><strong>1.redo log是物理日志，记录了在某行做了修改的结果（修改后的记录）。而bin log是逻辑日志，记录了在某行做了什么操作（执行修改的操作）。</strong></p><p><strong>2.redo log是InnoDB 引擎特有的，而bin log是基于mysql的server引擎的，所有的引擎都有选择启用或者关闭这个日志功能。</strong></p><p><strong>3.redo log是循环写的，如果point重合的话是会强制sync到磁盘的，但是bin log是会一直往下写的。</strong></p><h5 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h5><p>介绍了两种日志模块的功能，我们再来分析开头为什么要做两阶段提交。我们在系统交互的过程中有没有碰到一种情况就是两个任务需要同时完成才算是完成，如果由于异常失败了其中一个，那么整个过程是不成功的，这里我们通常会用一个中间状态来控制整个事务。也就是两阶段提交日志的概念，将写bin log和redo log整个当成一个事务去处理。</p><p><strong>redo log更新成功，binlog更新的时候mysql重启，重启机制检测到之后回滚该事务。redo log更新和bin log更新都成功，提交的时候mysql重启，重启之后检测到该事务已经完成自动提交。那么两个日志模块的数据是始终一致的。</strong></p><p>如果不进行两阶段提交，数据库在异常重启之后恢复的正是库可能和通过bin log恢复的备份数据是不一致的。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>主要介绍了mysql innodb在更新操作的时候是如果记录日志，防止突然的重启以及后续的数据备份恢复。即时突然重启，redo log也记录了原始的物理修改信息。当然如果想要恢复到历史的某一个点，也可以通过bin log的形式在历史某一个版本的数据上进行迭代执行。两个日志模块通过了中间状态进行两阶段提交，同时也保证了数据的一致性（这里如果是分各自提交会有问题，数据不一致）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单介绍一下mysql的日志系统。我们都知道在数据库的生产环境上，可能会发生一些事故。例如之前有个同事在执行数据订正的时候，不小心将很多的订单数据中的凭证数据覆盖成了空。这样的操作第一时间肯定是想通过数据库备份的形式将数据恢复出来，这个时候你的DBA可能会告诉你，有一周的数
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql加锁处理分析</title>
    <link href="http://jianghao.wang/2018/mysql%E5%8A%A0%E9%94%81%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://jianghao.wang/2018/mysql加锁处理分析/</id>
    <published>2018-11-12T06:07:22.527Z</published>
    <updated>2018-12-29T10:02:23.466Z</updated>
    
    <content type="html"><![CDATA[<p>之前的一篇文章介绍了mysql的四种隔离级别，本篇主要介绍一下mysql是如何进行加锁处理的。主要想了解mysql在处理高并发情况下的读写以及可能遇到的并发问题之间是如何去兼容的。我们都知道加锁是比较资源的操作，但是不加锁也会面临一些并发的问题，本篇文章将基于四种隔离级别去介绍mysql是如何进行加锁的处理的。</p><h4 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h4><p>我们需要先了解一下当前读和快照读的区别，实际上在mysql中是区分这两种读的，看两个sql语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from test_test where ? for update;//这一整个事务是一个当前读（实际上是一个写操作）</span><br><span class="line">select * from test_test where ?;//这个事务是一个快照读（实际上只是一个从数据库获取数据的操作）</span><br></pre></td></tr></table></figure><p><strong>当前读：delete，insert，update操作都可以视为当前读，从语义上可以理解为select for udpate，都是先读再写，需要保证并发的读写数据一致性。</strong></p><p><strong>快照读：单纯的select操作，数据库读取操作，不同的数据库隔离级别可能面临重复读的不一致问题和幻读问题。</strong></p><p>在mysql中，针对快照读只有在最高的隔离级别serializable级别下才会对快照读进行加锁，其他的级别下都是不加锁的。针对当前读，mysql在各个级别下为了防止并发的数据不一致问题都会进行加锁，加排他锁，也可以理解为写锁。</p><h4 id="各种隔离级别下的加锁机制"><a href="#各种隔离级别下的加锁机制" class="headerlink" title="各种隔离级别下的加锁机制"></a>各种隔离级别下的加锁机制</h4><p>我们探讨一下RC隔离级别下的几种索引遍历加锁处理的情况：</p><h5 id="RC-UUK（不可重复读-非唯一索引）"><a href="#RC-UUK（不可重复读-非唯一索引）" class="headerlink" title="RC+UUK（不可重复读+非唯一索引）"></a>RC+UUK（不可重复读+非唯一索引）</h5><p>我们将mysql的隔离级别调整为RC，建立一个test_test表，其中id是primary key，code是unique key。分别执行下面的sql：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=5 for update;</span><br><span class="line">//先在session1中执行该sql1</span><br><span class="line">id  name code</span><br><span class="line">13yqz   5</span><br><span class="line">14yqz   5</span><br><span class="line"></span><br><span class="line">update test_test set test_test.name=&apos;pyx&apos; where code =5;</span><br><span class="line">//然后在session2中执行该sql2</span><br><span class="line"></span><br><span class="line">执行结果，sql2获取锁超时。</span><br></pre></td></tr></table></figure><p>结论：RC隔离级别下对快照读不加锁，会存在重复读的数据不一致问题+幻读问题。对当前读，RC隔离级别会加锁，其他事务不允许修改已经被当前读锁定的修改记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=5 for update;</span><br><span class="line">//先在session1中执行该sql1</span><br><span class="line">id  name code</span><br><span class="line">13yqz   5</span><br><span class="line">14yqz   5</span><br><span class="line"></span><br><span class="line">insert into test_test values(20,&apos;yqz&apos;,7);//session2可以正常插入</span><br><span class="line">insert into test_test values(20,&apos;yqz&apos;,5);//session2不能插入，锁竞争</span><br><span class="line">update test_test set code=1 where id=13;//session2不能插入，锁竞争</span><br></pre></td></tr></table></figure><p>做了个图，分析下这里的加锁：</p><p>​    <img src="http://arthornye.github.io/images/lock.png" alt="cmd-markdown-logo"></p><p>结论：RC隔离级别对当前读会加锁，也会加GAP间隙锁防止两次当前读之间发生后幻读。但是两次快照读之前还是不能防止幻读的（这个在mysql事务和事务隔离机制文章中可以看到相关的介绍）。</p><p>分析，insert into test_test values(20,’yqz’,5)语句碰到了GAP间隙锁导致了锁竞争，update test_test set code=1 where id=13语句碰到了主键的记录导致了锁竞争。这也是为什么在根据un unique key遍历的时候我们要加两次锁的原因，因为可能有别的sql udpate是根据primary key来进行的。这里不熟悉mysql的索引的朋友们可以了解下mysql的索引结构，primary key对应的是聚族索引（innodb数据库引擎），基于B+TREE结构，在每个叶子结点都保存了完整的信息。但是建立的所有unuque key只保存了索引相关的信息，我们可以根据un unique key建立的B+TREE去遍历到primary key，再根据这个primary key去遍历主键索引。</p><h5 id="RC-UK（不可重复读-唯一索引）"><a href="#RC-UK（不可重复读-唯一索引）" class="headerlink" title="RC+UK（不可重复读+唯一索引）"></a>RC+UK（不可重复读+唯一索引）</h5><p>基于上面的分析，我们可以类比得到，这种情况下当前读也会在unique key对应的结果加排他锁，同时也加两个间隙锁。在对应的主键记录的叶子节点位置加排他锁，不存在幻读问题。但是针对快照读在RC隔离级别下还是会存在不可重复读+幻读问题。</p><h5 id="RR-UK（可重复读-唯一索引）"><a href="#RR-UK（可重复读-唯一索引）" class="headerlink" title="RR+UK（可重复读+唯一索引）"></a>RR+UK（可重复读+唯一索引）</h5><p>类比RC+UK，在当前读上的加锁处理没有什么区别，都不会存在重复读的问题和幻读问题。但是在快照读上，RR是通过了事务版本号和数据库记录版本号来限制了重复读不一致的问题的，也是旧版本的事务永远读不到新版本的事务提交的更改，删除以及新增记录。有的博客在介绍的时候会说是GAP间隙锁防止了幻读的发生，这个也有一定的道理，但是这个是针对当前读的，并不是针对快照读，快照读除非在串行的前提下才加锁，其他的情况都不加锁。</p><h5 id="RC-RR-NK（不可重复读-可重复读-无索引）"><a href="#RC-RR-NK（不可重复读-可重复读-无索引）" class="headerlink" title="RC/RR+NK（不可重复读/可重复读 +无索引）"></a>RC/RR+NK（不可重复读/可重复读 +无索引）</h5><p>无索引会直接根据主键进行全表扫描，同时会将整个表锁住，这种情况是及其低效的。</p><h4 id="分析一条复杂sql加锁"><a href="#分析一条复杂sql加锁" class="headerlink" title="分析一条复杂sql加锁"></a>分析一条复杂sql加锁</h4><p>通过上面的学习，我们尝试去分析一条sql的加锁情况：</p><p><img src="http://arthornye.github.io/images/sqllock.png" alt="cmd-markdown-logo"></p><p><strong><em>tips:这里有一种场景，mysql innodb默认会在这种查询的时候正向加锁（next-key lock===gap锁+右边的行锁），如果是倒序排序的话，会在倒序的末尾再加一个点。这是比较诡异的地方。</em></strong></p><h4 id="mysql死锁的发生"><a href="#mysql死锁的发生" class="headerlink" title="mysql死锁的发生"></a>mysql死锁的发生</h4><p>在mysql中也会发生一些死锁的情况，我们熟知发生死锁的条件能够帮助我们避免写出死锁。下面几种情况会发生死锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">session1</span><br><span class="line">select * from test_test where code=5 for udpate;</span><br><span class="line">select * from test_test where id=1 for update;</span><br><span class="line"></span><br><span class="line">session2</span><br><span class="line">select * from test_test where id=1 for update;</span><br><span class="line">select * from test_test where code=5 for udpate;</span><br><span class="line">//这种是比较简单的情况，循环加锁导致死锁</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">session1</span><br><span class="line">select * from test_test where code=5 for udpate;</span><br><span class="line">id  name code</span><br><span class="line">13yqz   5</span><br><span class="line">select * from test_test where code=4 for udpate;</span><br><span class="line">id  name code</span><br><span class="line">12yqz   4</span><br><span class="line"></span><br><span class="line">session2</span><br><span class="line">select * from test_test where id=12 for udpate;</span><br><span class="line">select * from test_test where id=13 for udpate;</span><br><span class="line"></span><br><span class="line">//这里虽然不是直接的进行了循环加锁，但是由于在聚簇索引的节点处也加了锁，实际上是有一个加锁的闭环的。我们通过mysql的加锁处理分析可以更准确的得到加锁信息，从而分析出死锁</span><br></pre></td></tr></table></figure><h4 id="MDL表级锁"><a href="#MDL表级锁" class="headerlink" title="MDL表级锁"></a>MDL表级锁</h4><p>mysql事务在执行的过程中，对表级别的操作分为两部分：表数据的增删改查，以及表结构的增删改查。表数据的增删改查需要获取MDL读锁，表结构的增删改查需要获取MDL写锁。MDL表级锁具备如下特性：</p><p><strong>1.MDL读锁是共享锁，不同事务不阻塞。</strong></p><p><strong>2.MDL写锁是独占锁，会阻塞在读锁和写锁上。</strong></p><p>表级锁在实际操作过程中，可能因为不恰当的操作导致业务发生异常，这里给个实例，下面三个事务依次执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">session a:</span><br><span class="line">begin;</span><br><span class="line">select * from test_test where code=2;//事务a获取到mdl表级锁的读锁</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session b:</span><br><span class="line">alter table add column city varchar(16);//事务b获取mdl写锁被block</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session c:</span><br><span class="line">select * from test_test where code=1;//事务c获取mdl读锁被block</span><br></pre></td></tr></table></figure><p>这里我们看到读锁和读锁之间虽然是共享锁，但是如果中间穿插了一个写锁的block，还是会有序被block住的。这里我们如果将事务a提交，mysql会依次执行b，c。所以我们在实际 操作过程中如果要对线上的数据的表进行变更，需要保证没有长事务，如果当前正有个长事务在对表数据进行操作，那么执行表结构变更的写操作会被block导致其他的读操作也被block。可以考虑在执行表结构变更的时候：</p><ul><li>查看执行中是否有长事务，kill长事务</li><li>alter等修改操作设置等待时间（需要引擎支持）</li></ul><h4 id="mysql行锁"><a href="#mysql行锁" class="headerlink" title="mysql行锁"></a>mysql行锁</h4><p>mysql中仅innodb支持行锁，其他引擎不支持行锁。我们通过一个实例来进行介绍mysql的行锁。假如A在B影院买了一张电影票，C也在B影院买了一张电影票。那么这两个事务都需要对客户账户余额做-操作，同时对影院的余额也做+操作。先介绍一些主要的概念再进行展开。</p><ul><li><strong>减少客户的账户余额</strong></li><li><strong>增加商家的账户余额</strong></li><li><strong>增加一条交易记录</strong></li></ul><p>上面的整个过程需要保证原子性。我们通常称之为一个事务，要么全部成功要么全部失败。</p><p><strong>两阶段锁协议</strong>：innodb中的行锁是需要的时候会进行加锁，但是并不是不需要的时候就会释放锁，需要事务提交之后才会释放锁。</p><p><strong>死锁：</strong>行锁发生了循环引用导致发生死锁，线程在锁上持续等待。</p><p><strong>如何解决死锁：</strong>代码中避免循环引用；可以通过设置超时时间和开启数据库死锁检测防止死锁。设置超时时间可能导致部分正常业务也就是没有发生死锁的事务被回滚，对业务是有损的；开启数据库死锁检测对业务是无损的，但是死锁的检测机制会占用大量的cpu。</p><p><strong>热点更新：</strong>这里我们讨论的热点更新，可以假设在上面的事务过程中，出现了双11类似的疯狂买票操作。那么这个场景下对商家余额的记录的写操作是非常频繁的。如果开始了死锁检测，那么等待的线程假设是1000个，那么这些线程会不断去检测死锁也就是1000*1000的复杂度，这个占用大量的cpu。</p><p><strong>如何解决热点更新：</strong> 在并发量比较大的情况下，我们可以通过增加热点更新记录的条数来减少锁的竞争。例如我们可以维护十条B账户余额的记录，在更新的时候随机取其中的某一条去更新，之后将所有的余额数据进行累加。这样的设计也是可以直接减少锁的竞争提高并发量。但是这样的设计需要考虑逆向操作，也就是如果发生退款操作导致其中的某条记录变成了0，代码需要特殊处理。</p><p><strong>并发量如何提高：</strong>尽量将一个事务中可能发生锁竞争的语句往后靠，前面的事务过程中增加商家的余额，这种热点更新其实可以放在后面，减少占有锁之后的锁持有时间。</p><p><strong>死锁检测：</strong>这里需要注意的是死锁检测是当前线程在发现锁阻塞之后就回去扫描别的线程，所以在并发量非常高的时候这个检测影响的性能也就更加明显。通常在秒杀的场景下，单个热点更新会导致不停的进行死锁检测，极大的降低了性能。 </p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本篇主要分析了mysql是如何进行加锁的处理的。mysql在RR隔离级别及以下对快照读是比较友好的，不会加锁，这样也极大地提高了数据库处理并发的能力。但是针对快照读RC隔离级别下还是不能防止幻读，也不能重复读。值得注意的是，mysql在RR,RC的隔离级别下都是有对当前读防止幻读的，通过加排他锁和间隙锁的共同使用。针对RR隔离级别的快照读，通过加版本号达到可重复读和防止幻读的目的。通过总结希望从sql语句，结合隔离级别以及索引判断出在执行过程中可能发生的加锁和锁竞争。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前的一篇文章介绍了mysql的四种隔离级别，本篇主要介绍一下mysql是如何进行加锁处理的。主要想了解mysql在处理高并发情况下的读写以及可能遇到的并发问题之间是如何去兼容的。我们都知道加锁是比较资源的操作，但是不加锁也会面临一些并发的问题，本篇文章将基于四种隔离级别去
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql事务和事务隔离机制</title>
    <link href="http://jianghao.wang/2018/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6/"/>
    <id>http://jianghao.wang/2018/mysql事务和事务隔离机制/</id>
    <published>2018-11-07T09:36:02.887Z</published>
    <updated>2018-11-21T02:06:56.503Z</updated>
    
    <content type="html"><![CDATA[<p>在学习mysql的事务隔离机制的过程中，对mysql的会话和事务的概念有点模糊不清，这里主要通过mysql可视化工具sequel pro来记录在实践过程中遇到的问题以及思考。</p><h4 id="mysql会话begin自动提交事务"><a href="#mysql会话begin自动提交事务" class="headerlink" title="mysql会话begin自动提交事务"></a>mysql会话begin自动提交事务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">update retail_order set order_status=111 where order_code=&apos;899120869590&apos;;</span><br></pre></td></tr></table></figure><p>我们建立一个mysql连接，然后开启一个会话session1，执行上面的sql。这条sql会在行记录上加锁。但是当前的事务是没有提交的，mysql的默认事务隔离机制是RR（可重复读）。我们在另一个会话session2中执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">update retail_order set order_status=111 where order_code=&apos;899120869590&apos;;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>会话2会报超时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure><p>通过这种方式我们成功验证了session1的事务还在执行中，数据库的记录已经上锁。</p><p>那么我们再去验证，当前会话的某个事务还在执行中，当前会话是不是可以继续执行其他事务，执行下面的select</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select order_status from retail_order where order_code=&apos;899120869590&apos;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">111</span><br></pre></td></tr></table></figure><p>实际上这个事务没有被提交上去，但是在本会话中再提交select却可以读取到这个值。这里其实我们应该将其理解为实际上本事务并没有提交，数据库会检测是同一个会话提交的sql，将其整合为一个未提交的事务。所以这里的变更对其他会话的事务依旧是不可见的。</p><p>那么什么时候这个事务什么时候会被提交？我们可以联想到是不是在执行一个commit本会话的事务便会被提交，对其他的会话可见。我们在session1单独执行一句commit，在session2中执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select order_status from retail_order where order_code=&apos;899120869590&apos;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">111</span><br></pre></td></tr></table></figure><p>可见我们的事务已经被提交了，同样的，我们发现在session1中执行一句begin，看session2同样查询的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">111</span><br></pre></td></tr></table></figure><p>做个总结：</p><p><code>当我们忘了对一个事务进行提交的时候，该会话接下来执行的事务也会叠加，直到我们显示的去进去提交或者开启一个新的事务。一个会话的事务没有提交可能导致另一个会话获取不到锁。</code></p><h4 id="mysql事务隔离机制"><a href="#mysql事务隔离机制" class="headerlink" title="mysql事务隔离机制"></a>mysql事务隔离机制</h4><p>熟悉了我们的可视化工具，我们尝试分析mysql的事务隔离机制，相信对mysql有基本了解的都知道，mysql的四种隔离机制。这四种隔离机制是我们分析数据库锁机制的基本，我也将会在本篇介绍隔离机制之后介绍一下mysql的锁机制。接下来的介绍需要我们去改变mysql的事务隔离机制，我们可以通过语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@global.tx_isolation,@@tx_isolation;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPEATABLE-READREPEATABLE-READ</span><br></pre></td></tr></table></figure><p>mysql的默认隔离机制RR,前一个是全局session的隔离级别，后一个是当前会话的隔离级别，我们可以在当前会话中设置隔离级别，通过sql语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level read committed; </span><br><span class="line">set session transaction isolation level repeatable read;</span><br></pre></td></tr></table></figure><h5 id="Read-Uncommited"><a href="#Read-Uncommited" class="headerlink" title="Read Uncommited"></a>Read Uncommited</h5><p>这个基本不用考虑，因为如果事务没有被提交就被其他的事务看到这样的设计从逻辑上来看是不合理的，会造成大量的脏读。</p><h5 id="Read-Commited-不可重复读"><a href="#Read-Commited-不可重复读" class="headerlink" title="Read Commited(不可重复读)"></a>Read Commited(不可重复读)</h5><p>在这个隔离机制下，事务在提交之后对另一个事务可见。如果在一个事务A的执行过程中进行了两次查询，事务B在查询间隙进行了数据更新，这个隔离级别会存在脏读+幻读的可能。我们新建一个test_test表，开启session1，执行事务A，不提交，模拟不可重复读：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1wmm1</span><br><span class="line">2wmm1</span><br><span class="line">3wmm1</span><br><span class="line">4wmm1</span><br><span class="line">5wmm1</span><br></pre></td></tr></table></figure><p>开启session2，执行事务B，直接提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update test_test set name=&apos;wmm&apos; where code=1;</span><br></pre></td></tr></table></figure><p>回到session1，执行查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br></pre></td></tr></table></figure><p>RC隔离级别下不可重复读，两次读的结果不一致。</p><p>用同样的方式，测试该隔离模式下会不会存在幻读：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert test_test values(6,&apos;yqz&apos;,1);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6yqz1</span><br></pre></td></tr></table></figure><p>该模式下存在幻读（如果没有显式begin开始一个事务，事务都默认自动提交，部分语句没有加begin，commit，自动提交）。</p><h4 id="Repeatable-Read-可重复读"><a href="#Repeatable-Read-可重复读" class="headerlink" title="Repeatable Read(可重复读)"></a>Repeatable Read(可重复读)</h4><p>首先通过恢复到该数据库隔离级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level repeatable read;</span><br></pre></td></tr></table></figure><p>模拟是否存在脏读，session1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6yqz1</span><br></pre></td></tr></table></figure><p>session2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update test_test set name=&apos;pyx&apos; where code=1;</span><br></pre></td></tr></table></figure><p>session1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6yqz1</span><br></pre></td></tr></table></figure><p>RR隔离模式下不存在脏读，那么mysql是如何实现该隔离模式下的避免脏读？了解过juc的cas的都知道我们可以通过在共享内存标记一个版本号，来防止aba问题。那么类比mysql也是通过在每行的记录后面添加一列标记版本号，读的时候不会修改这个版本号，但是更新删除都会版本号+1。参考上面的例子，session1在执行事务A的时候，假设当前事务的版本号为1，当前事务并没有提交，然后session2执行了更新事务B，提交之后数据库该行记录的版本号变成了2。在该隔离模式下事务A只会读取到版本号不大于当前事务版本号的记录，也就是说，虽然这条记录的更改已经在数据库真实存在，但是事务A并不能读取到这条记录的变更。</p><ul><li>SELECT时，读取创建版本号&lt;=当前事务版本号，删除版本号为空或&gt;当前事务版本号。</li><li>INSERT时，保存当前事务版本号为行的创建版本号。</li><li>DELETE时，保存当前事务版本号为行的删除版本号。</li><li>UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行。</li></ul><p><strong>2018.11.20增加对MVCC多版本并发控制的理解：</strong>如果我们数据库中某一条记录的值经历的版本变化为4-&gt;3-&gt;2-&gt;1，那么数据库引擎同时会记录一个回滚日志，根据对应事务的版本号去回滚到事务对应的值。</p><p><img src="http://arthornye.github.io/images/mvcc.png" alt="cmd-markdown-logo"></p><p>同样的方式看该该隔离级别下是否存在幻读，session1，事务A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6pyx1</span><br></pre></td></tr></table></figure><p>session2，事务B：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert test_test values(7,&apos;yqz&apos;,1);</span><br></pre></td></tr></table></figure><p>session1，事务A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6pyx1</span><br></pre></td></tr></table></figure><p>session1，事务A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit;</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6pyx1</span><br><span class="line">7yqz1</span><br></pre></td></tr></table></figure><p>可以看到这里是不存在幻读的，很多博客在介绍mysql的四种隔离级别的时候会说RR隔离模式下可以避免脏读但是不能避免幻读，我们通过实践看到这个级别是可以避免幻读的。</p><h4 id="Serializable-串行化"><a href="#Serializable-串行化" class="headerlink" title="Serializable(串行化)"></a>Serializable(串行化)</h4><p>这个隔离级别，个人的理解可以类比RetrantWriteReadLock的设计。事务在执行的时候如果数据行存在写锁（排他锁），读锁是共享锁，这种情况下会等待写锁释放。同样的如果是事务尝试去获取某个数据行的写锁，发现共享锁的读锁没有完全释放开，也需要等待读锁全部释放完才可以获取到写锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level serializable;</span><br></pre></td></tr></table></figure><p>将数据库隔离级别调整为串行，然后分别执行事务，session1，事务A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test_test where code=1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1pyx1</span><br><span class="line">2pyx1</span><br><span class="line">3pyx1</span><br><span class="line">4pyx1</span><br><span class="line">5pyx1</span><br><span class="line">6pyx1</span><br><span class="line">7yqz1</span><br><span class="line">8yqz1</span><br></pre></td></tr></table></figure><p>session2，事务B：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update test_test set name=&apos;pyx&apos; where id=1</span><br></pre></td></tr></table></figure><p>执行结果，事务B，获取锁超时，Lock wait timeout exceeded; try restarting transaction。通过下面的语句也可以查看到当前存在锁竞争。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.innodb_locks</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5930258879:6688936:3:35930258879XRECORD`souche_retail`.`test_test`PRIMARY668893633NULL</span><br><span class="line">5930501833:6688936:3:35930501833SRECORD`souche_retail`.`test_test`PRIMARY668893633NULL</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本篇主要介绍了mysql的四种事务隔离级别，这里终结下它们的特点：</p><table><br><tr><br>    <th>Read Uncommited</th><br>    <th>不可重复读</th><br>    <th>幻读</th><br></tr><br><tr><br>    <th>Read Commited </th><br>    <th>不可重复读</th><br>    <th>幻读</th><br></tr><br><tr><br>    <th>Repeatable Read</th><br>    <th>可重复读</th><br>    <th>不存在幻读</th><br></tr><br><tr><br>    <th>Serializable</th><br>    <th>不可重复读</th><br>    <th>不存在幻读</th><br></tr><br></table><p>接下来的博客将会主要介绍mysql在这几种隔离机制下是如何加锁保持高并发情况下的数据一致性的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习mysql的事务隔离机制的过程中，对mysql的会话和事务的概念有点模糊不清，这里主要通过mysql可视化工具sequel pro来记录在实践过程中遇到的问题以及思考。&lt;/p&gt;
&lt;h4 id=&quot;mysql会话begin自动提交事务&quot;&gt;&lt;a href=&quot;#mysql会话
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Semaphore控制并发的信号量</title>
    <link href="http://jianghao.wang/2018/Semaphore%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <id>http://jianghao.wang/2018/Semaphore控制并发的信号量/</id>
    <published>2018-11-05T02:07:12.193Z</published>
    <updated>2018-11-07T03:10:35.130Z</updated>
    
    <content type="html"><![CDATA[<p>在面试的时候被问到关于java信号量，并没有很了解这个并发同步器，这里学习之后做一点简单的记录。Semaphore我们通常称之为信号量，这是用来控制同时访问某个资源的线程数量的一个同步器。比如数据库连接，如果数据库连接的数量只有10个，但是此时在执行的线程数量大于10个，那么线程会报错，获取不到数据库连接。为了防止这样的情况，我们可以通过信号量Semaphore来进行流量的控制。</p><h4 id="使用Semaphore控制并发流量"><a href="#使用Semaphore控制并发流量" class="headerlink" title="使用Semaphore控制并发流量"></a>使用Semaphore控制并发流量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 10/25/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个线程池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService threadPoolExecutor= Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="comment">//这里用信号量尝试控制流量</span></span><br><span class="line">            Semaphore semaphore =<span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//public static volatile int count=0;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++)&#123;</span><br><span class="line">            threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        semaphore.acquire();</span><br><span class="line">                        <span class="comment">//模拟获取数据库连接</span></span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">"   get database link : "</span>);</span><br><span class="line">                        semaphore.release();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Semaphore-API介绍"><a href="#Semaphore-API介绍" class="headerlink" title="Semaphore API介绍"></a>Semaphore API介绍</h4><p>Semaphore对每一个进入获取令牌的线程，都会尝试给予令牌，但是如果出现了供不应求的情况，每个线程需要的处理方式可能是不同的：</p><h5 id="semaphore-acquire"><a href="#semaphore-acquire" class="headerlink" title="semaphore.acquire()"></a>semaphore.acquire()</h5><p><strong>线程选择直接获取（非阻塞），进入等待队列，循环等待没获取到线程挂起</strong>。</p><p>通过源码分析在底层的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">               <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                   <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                   <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                       setHeadAndPropagate(node, r);</span><br><span class="line">                       p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                       failed = <span class="keyword">false</span>;</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<span class="comment">//公平加入等待队列，如果没获取到直接触发中断，直接抛出中断异常</span></span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>##### </p><h5 id="semaphore-tryAcquire"><a href="#semaphore-tryAcquire" class="headerlink" title="semaphore.tryAcquire()"></a>semaphore.tryAcquire()</h5><p><strong>线程可以选择等待一段时间（非阻塞），如果超时获取不到返回false，检测到中断信号线程中断</strong>。</p><p>贴上源码的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">               <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//如果超时了返回获取锁失败</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())<span class="comment">//将中断信号标志位复位，同时抛出中断异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();<span class="comment">//检测到当前线程已经被中断，执行自我中断，抛出异常。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="semaphore-acquireUninterruptibly"><a href="#semaphore-acquireUninterruptibly" class="headerlink" title="semaphore.acquireUninterruptibly()"></a>semaphore.acquireUninterruptibly()</h5><p>获取锁的过程中不允许中断，线程会一直处于获取锁的状态，只会在失败之后将标志位置为true。</p><p>贴上源码的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Acquires in shared uninterruptible mode.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">               <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                   <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                   <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                       setHeadAndPropagate(node, r);</span><br><span class="line">                       p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                       <span class="keyword">if</span> (interrupted)</span><br><span class="line">                           selfInterrupt();</span><br><span class="line">                       failed = <span class="keyword">false</span>;</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   interrupted = <span class="keyword">true</span>;<span class="comment">//不抛出异常，方法不支持中断抛出异常</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="Semaphore的两种实现（公平or非公平）"><a href="#Semaphore的两种实现（公平or非公平）" class="headerlink" title="Semaphore的两种实现（公平or非公平）"></a>Semaphore的两种实现（公平or非公平）</h4><p>Semaphore信号量提供了两种实现，公平和非公平的方式，这个可以类比retrantlock的公平非公平机制。一个会加入等待队列，一个不会加入等待队列。我们看下两个的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">//不会中断哦，一直循环占用cpu</span></span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;<span class="comment">//非公平的方式也会一直循环直到获取成功，少了的话也会返回一个负值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasQueuedPredecessors())<span class="comment">//公平的方式这里多维护了一个队列，如果已经加入了队列，直接返回，队列中的线程会被调度。</span></span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>我们看到公平和非公平的方式只是多了一个方法，那么看下这个方法到底实现了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* <span class="meta">@return</span> &#123;<span class="meta">@code</span> <span class="keyword">true</span>&#125; <span class="keyword">if</span> there is a queued thread preceding the</span><br><span class="line">     *         current thread, and &#123;<span class="meta">@code</span> <span class="keyword">false</span>&#125; <span class="keyword">if</span> the current thread</span><br><span class="line">     *         is at the head of the queue or the queue is empty</span><br><span class="line">     * <span class="meta">@since</span> <span class="number">1.7</span></span><br><span class="line">     */</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">        <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">        <span class="comment">// thread is first in queue.</span></span><br><span class="line">        Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//这里是维护的node队列，node是记录一个线程信息的对象。该方法主要判断当前线程是否已经维护进了公平等待的队列中，如果维护进去了，就返回false，没有维护进去就返回true。也就是公平锁会直接返回一个-1，线程继续执行，进入等待队列中调度执行。</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在面试的时候被问到信号量当时也是蛮懵逼的，觉得自己深入了解过AQS队列同步器，但是对java原生实现的一些同步器了解并不是特别多。信号量这个名字并不是特别好理解，可以更形象的称之为令牌管理器。在并发线程比较多的时候，一些有限的资源类似数据库连接数不能及时供应，那么我们需要进行一个流量控制。对于客户端的请求来说，可以在一段时间获取不到这个令牌之后选择不再等待，也可以在获取令牌的方法一直等待直到被中断，或者干脆一直等下去，死磕。网上搜索的时候发现一篇介绍同样内容的[博客]还不错，可以mark下<a href="https://blog.csdn.net/hanchao5272/article/details/79780045。" target="_blank" rel="noopener">https://blog.csdn.net/hanchao5272/article/details/79780045。</a></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在面试的时候被问到关于java信号量，并没有很了解这个并发同步器，这里学习之后做一点简单的记录。Semaphore我们通常称之为信号量，这是用来控制同时访问某个资源的线程数量的一个同步器。比如数据库连接，如果数据库连接的数量只有10个，但是此时在执行的线程数量大于10个，那
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>动态规划经典案例</title>
    <link href="http://jianghao.wang/2018/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B/"/>
    <id>http://jianghao.wang/2018/动态规划经典案例/</id>
    <published>2018-08-22T03:45:39.000Z</published>
    <updated>2018-08-22T06:40:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>​    动态规划是算法中比较重要的一课，是一种典型的空间换取时间的算法。通常是可以用分治法取考虑一个动态规划问题，用递归实现代码上看起来更加浅显易懂。但是基于递归的实现都是n2的复杂度，这样的复杂度在递归栈到达一定深度的时候会变的非常慢，并且有非常多的重复操作。动态规划致力于将这类递归问题，通过空间换取时间，用容器的方式记录递归结果，减少了重复递归，同时降低了时间复杂度。</p><h4 id="最长子数组问题"><a href="#最长子数组问题" class="headerlink" title="最长子数组问题"></a>最长子数组问题</h4><p>​    找出一个数组的连续子数组的最大和。最先想到的solution应该是n2的两次遍历。但是这样的循环是非常耗时的。我们尝试用分治的方式去思考一个复杂的问题，这是算法设计过程中常用的思维。当我们考虑一个任意数组比如{10,-1,2,-4,3,-5,10}，找出最长的子数组。可以先找出{10,-1,2,-4,3,-5}的最长子数组，那么我们可以得到一个数学函数公式（今天想偷个懒，明早去公司画一画）：</p><p>​    <img src="http://arthornye.github.io/images/%E5%AD%90%E4%B8%B2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png" alt="cmd-markdown-logo"></p><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>​    通常得出递归数学公式之后我们可以直接写出一个直观的递归程序。递归程序如下，这里需要维护一个Sum类，需要记录最长子数组的起始元素位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> MaxSubArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 8/21/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer startIndex;</span><br><span class="line">    <span class="keyword">private</span> Integer sum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getStartIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStartIndex</span><span class="params">(Integer startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.startIndex = startIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSum</span><span class="params">(Integer sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sum = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxSubArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Integer[] integerArray=&#123;<span class="number">10</span>,-<span class="number">1</span>,<span class="number">2</span>,-<span class="number">4</span>,<span class="number">3</span>,-<span class="number">5</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        System.out.println(maxSubArray(integerArray,<span class="number">6</span>).getSum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Sum <span class="title">maxSubArray</span><span class="params">(Integer[] integers, Integer index)</span></span>&#123;</span><br><span class="line">        Sum sum=<span class="keyword">new</span> Sum();</span><br><span class="line">        <span class="keyword">if</span>(integers==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(integers!=<span class="keyword">null</span> &amp;&amp; index==<span class="number">0</span>)&#123;</span><br><span class="line">            sum.setStartIndex(<span class="number">0</span>);</span><br><span class="line">            sum.setSum(integers[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Sum tempSum=maxSubArray(integers,index-<span class="number">1</span>);<span class="comment">//一个递归嘛,调用栈在上面的地方pop哦，没问题哦（在这里递归到0的时候pop执行下面的方法栈）。这里获取到子集的最长子串</span></span><br><span class="line">            Integer tempSumValue=<span class="number">0</span>;</span><br><span class="line">            Integer tempIndex=<span class="number">0</span>;<span class="comment">//最长子串的起始元素。必须记录这个元素，不然无法计算最长子数组到integer[i]的和</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=tempSum.getStartIndex();i&lt;=index;i++)&#123;</span><br><span class="line">                tempSumValue+=integers[i];</span><br><span class="line">            &#125;<span class="comment">//计算最长子数组到integer[i]的和</span></span><br><span class="line">            <span class="keyword">if</span>(tempSumValue&lt;integers[index])&#123;</span><br><span class="line">                tempIndex=index;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tempIndex=tempSum.getStartIndex();</span><br><span class="line">            &#125;</span><br><span class="line">            Integer maxSum=max(max(tempSumValue,integers[index]),tempSum.getSum());<span class="comment">//取三种情况的最大值</span></span><br><span class="line">            sum.setStartIndex(tempIndex);<span class="comment">//设置当前递归数组的起始元素和最大数组和</span></span><br><span class="line">            sum.setSum(maxSum);</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="动态规划（DP）"><a href="#动态规划（DP）" class="headerlink" title="动态规划（DP）"></a>动态规划（DP）</h5><p>​    分析上面的递归程序，n2的效率+递归调用栈，空间和时间利用率都不高。我们通过动态规划进行优化，动态规划的精髓可以用空间去换取空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxSubArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Integer[] integerArray=&#123;<span class="number">10</span>,-<span class="number">1</span>,<span class="number">2</span>,-<span class="number">4</span>,<span class="number">3</span>,-<span class="number">5</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> MaxSum = integerArray[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> TempMaxSum = integerArray[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; integerArray.length;i++)<span class="comment">//n的复杂度</span></span><br><span class="line">        &#123;</span><br><span class="line">          TempMaxSum = max(integerArray[i],TempMaxSum + integerArray[i]);<span class="comment">//决定当前最大子数组以哪个元素开头</span></span><br><span class="line">          MaxSum = max(MaxSum,TempMaxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(MaxSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="斐波那契数列问题"><a href="#斐波那契数列问题" class="headerlink" title="斐波那契数列问题"></a>斐波那契数列问题</h4><p>​    斐波那契数列的性质可以得到如下的数学递推公式，同样，我们提供递归和动态规划两种实现方式，这里我们看一下递推的公式：</p><p>​    <img src="http://arthornye.github.io/images/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.png" alt="cmd-markdown-logo"></p><h5 id="递归-DP"><a href="#递归-DP" class="headerlink" title="递归+DP"></a>递归+DP</h5> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Fobi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 8/22/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FoboNaCiArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(fiboNaciDigui(<span class="number">6</span>));<span class="comment">//递归的求斐波那契数列</span></span><br><span class="line">        <span class="comment">//DP求斐波那契数列</span></span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        arrayList.add(<span class="number">0</span>);</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(fiboNaciDP(<span class="number">6</span>,arrayList));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Integer <span class="title">fiboNaciDigui</span><span class="params">(Integer i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fiboNaciDigui(i-<span class="number">1</span>)+fiboNaciDigui(i-<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Integer <span class="title">fiboNaciDP</span><span class="params">(Integer index,ArrayList&lt;Integer&gt; arrayList)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;index;i++)&#123;</span><br><span class="line">            arrayList.add(arrayList.get(i-<span class="number">1</span>)+arrayList.get(i-<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrayList.get(index-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    动态规划是算法中比较重要的一课，是一种典型的空间换取时间的算法。通常是可以用分治法取考虑一个动态规划问题，用递归实现代码上看起来更加浅显易懂。但是基于递归的实现都是n2的复杂度，这样的复杂度在递归栈到达一定深度的时候会变的非常慢，并且有非常多的重复操作。动态规划致
      
    
    </summary>
    
    
      <category term="大搜车的点滴记录" scheme="http://jianghao.wang/tags/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%9A%84%E7%82%B9%E6%BB%B4%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Java 8中的Stream API 详解</title>
    <link href="http://jianghao.wang/2018/Java-8%E4%B8%AD%E7%9A%84Streams-API-%E8%AF%A6%E8%A7%A3/"/>
    <id>http://jianghao.wang/2018/Java-8中的Streams-API-详解/</id>
    <published>2018-08-14T10:07:19.000Z</published>
    <updated>2018-08-15T07:23:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Stream-API概述"><a href="#Stream-API概述" class="headerlink" title="Stream API概述"></a>Stream API概述</h3><p>​    Stream是Java8中的一大亮点，它为容器集合的操作提供了一系列函数式编程方式，节省了大量的重复代码，同时也让代码变得更加简洁精炼。相信在运用java8之前的版本中，我们需要对容器进行操作，手写遍历手写赋值的过程使得代码十分臃肿并且可读性极差。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。可以说stream api是函数式+多核的结合物。</p><h3 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h3><p>​    在之前的工作中，曾经有个需求需要构造一个双层的map结构。我们拿到的是一个仓库的全列表，需要根据城市首字母去聚合所有的城市，然后根据城市去聚合这个城市的仓库列表。从复杂度上考虑，需要两次聚合操作，要有两次循环。这里贴一段java8之前的代码实现（相当繁琐，可读性极差）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TruckStoreDTO&gt; <span class="title">getStorageList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       StorageQO storageQO=<span class="keyword">new</span> StorageQO();</span><br><span class="line">       Page&lt;StorageDTO&gt; storageDTOPage=remoteStorageService.query(storageQO,<span class="number">1</span>,<span class="number">200</span>);</span><br><span class="line">       <span class="keyword">if</span>(storageDTOPage!=<span class="keyword">null</span> &amp;&amp; storageDTOPage.getTotalNumber()!=<span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//获取到原始仓库列表数据</span></span><br><span class="line">           List&lt;StorageDTO&gt; storageDTOList=storageDTOPage.getItems();</span><br><span class="line">           <span class="comment">//根据城市首字母建立一个聚合列表，treemap遍历有序,查询匹配logn复杂度</span></span><br><span class="line">           TreeMap&lt;String,Map&lt;String,List&lt;StorageDetailDTO&gt;&gt;&gt; cityTreeMap=<span class="keyword">new</span> TreeMap();</span><br><span class="line">           <span class="keyword">for</span>(StorageDTO storageDTO:storageDTOList)&#123;</span><br><span class="line">               String pinyinCity= PingYingUtils.getPinYinFirstHeadChar(storageDTO.getCity());</span><br><span class="line">               <span class="comment">//获取到城市名拼音的首字母大写（同拼音城市列表map&lt;cityCode,list&lt;bean&gt;&gt;）</span></span><br><span class="line">               String firstPinyin=pinyinCity.toUpperCase();</span><br><span class="line"></span><br><span class="line">               <span class="comment">//根据城市的code聚合仓库列表，treemap匹配logn复杂度</span></span><br><span class="line">               Map&lt;String,List&lt;StorageDetailDTO&gt;&gt; cityStorageDTOMap;</span><br><span class="line">               List&lt;StorageDetailDTO&gt; storageDetailDTOList;</span><br><span class="line">               <span class="comment">//判断是否包含了该拼音的map&lt;cityCode,List&lt;StorageDetailDTO&gt;</span></span><br><span class="line">               <span class="keyword">if</span> (cityTreeMap.containsKey(firstPinyin)) &#123;</span><br><span class="line">                   cityStorageDTOMap=cityTreeMap.get(firstPinyin);</span><br><span class="line"></span><br><span class="line">                   StorageDetailDTO storageDetailDTO=<span class="keyword">new</span> StorageDetailDTO();</span><br><span class="line">                   storageDetailDTO.setStorageCode(storageDTO.getStorageCode());</span><br><span class="line">                   storageDetailDTO.setStorageName(storageDTO.getStorageName());</span><br><span class="line">                   storageDetailDTO.setCityName(storageDTO.getCity());</span><br><span class="line">                   storageDetailDTO.setAddress(storageDTO.getPlace());</span><br><span class="line">                   <span class="comment">//如果当前城市已经被插入(同城市列表list&lt;bean&gt;)</span></span><br><span class="line">                   <span class="keyword">if</span>(cityStorageDTOMap.containsKey(storageDTO.getCityCode()))&#123;</span><br><span class="line">                       <span class="comment">//在城市中插入多个仓库</span></span><br><span class="line">                       storageDetailDTOList=cityStorageDTOMap.get(storageDTO.getCityCode());</span><br><span class="line">                       storageDetailDTOList.add(storageDetailDTO);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//当前城市未被插入过</span></span><br><span class="line">                   <span class="keyword">else</span> &#123;</span><br><span class="line">                       storageDetailDTOList =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                       storageDetailDTOList.add(storageDetailDTO);</span><br><span class="line">                       cityStorageDTOMap.put(storageDTO.getCityCode(),storageDetailDTOList);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//当前首字母未被插入过</span></span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   cityStorageDTOMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">                   cityTreeMap.put(firstPinyin,cityStorageDTOMap);</span><br><span class="line"></span><br><span class="line">                   storageDetailDTOList =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                   StorageDetailDTO storageDetailDTO=<span class="keyword">new</span> StorageDetailDTO();</span><br><span class="line">                   storageDetailDTO.setStorageCode(storageDTO.getStorageCode());</span><br><span class="line">                   storageDetailDTO.setStorageName(storageDTO.getStorageName());</span><br><span class="line">                   storageDetailDTO.setCityName(storageDTO.getCity());</span><br><span class="line">                   storageDetailDTO.setAddress(storageDTO.getPlace());</span><br><span class="line">                   storageDetailDTOList.add(storageDetailDTO);</span><br><span class="line">                   cityStorageDTOMap.put(storageDTO.getCityCode(),storageDetailDTOList);</span><br><span class="line">                   cityTreeMap.put(firstPinyin,cityStorageDTOMap);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           List&lt;TruckStoreDTO&gt; truckStoreDTOList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span>(Map.Entry cityEntry:cityTreeMap.entrySet())&#123;</span><br><span class="line">               TruckStoreDTO truckStoreDTO=<span class="keyword">new</span> TruckStoreDTO();</span><br><span class="line">               Map&lt;String,List&lt;StorageDetailDTO&gt;&gt; storageDetailListMap=(Map&lt;String,List&lt;StorageDetailDTO&gt;&gt;)cityEntry.getValue();</span><br><span class="line">               List&lt;CityStorageDTO&gt; cityStorageDTOList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">               <span class="keyword">for</span>(Map.Entry storageEntry:storageDetailListMap.entrySet() )&#123;</span><br><span class="line">                   List&lt;StorageDetailDTO&gt; storageDetailDTOList=(List&lt;StorageDetailDTO&gt;)storageEntry.getValue();</span><br><span class="line">                   CityStorageDTO cityStorageDTO=<span class="keyword">new</span> CityStorageDTO();</span><br><span class="line">                   cityStorageDTO.setCityName(storageDetailDTOList.get(<span class="number">0</span>).getCityName());</span><br><span class="line">                   cityStorageDTO.setCityCode((String)storageEntry.getKey());</span><br><span class="line">                   cityStorageDTO.setStorageDetailDTOList(storageDetailDTOList);</span><br><span class="line">                   cityStorageDTOList.add(cityStorageDTO);</span><br><span class="line">               &#125;</span><br><span class="line">               truckStoreDTO.setCityStorageDTOList(cityStorageDTOList);</span><br><span class="line">               truckStoreDTO.setCityListKey((String)cityEntry.getKey());</span><br><span class="line">               truckStoreDTOList.add(truckStoreDTO);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> truckStoreDTOList;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这种实现的弊端：</p><p><strong><em>1.太多的循环导致可读性极差</em></strong></p><p><strong><em>2.重复冗余的代码过多</em></strong></p><p>那么我们希望通过Stream API去改善和优化这段代码，因为这段是之前在项目中的一段代码，我在这里进行模拟操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> StreamAPI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by yqz on 8/14/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StorageTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;StorageDTO&gt; arrayList=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">27</span>;i++)&#123;</span><br><span class="line">            StorageDTO storageDTO=<span class="keyword">new</span> StorageDTO();</span><br><span class="line">            <span class="keyword">char</span> firstKey=(<span class="keyword">char</span>) (i+<span class="number">65</span>);</span><br><span class="line">            storageDTO.setCityFirstKey(String.valueOf(firstKey));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++) &#123;</span><br><span class="line">                String cityName=<span class="string">"city:"</span>+(<span class="keyword">char</span>) (j+<span class="number">65</span>);</span><br><span class="line">                storageDTO.setCityName(cityName);</span><br><span class="line">                storageDTO.setStorageName(<span class="string">"storage:"</span>+j);</span><br><span class="line">                arrayList.add(storageDTO);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//构造一个两次聚合的仓库数组列表</span></span><br><span class="line">        Stream stream= arrayList.stream();</span><br><span class="line">        Map&lt;String,Map&lt;String,List&lt;StorageDTO&gt;&gt;&gt;storageListMap=(Map&lt;String,Map&lt;String,List&lt;StorageDTO&gt;&gt;&gt;)stream.collect(Collectors.groupingBy(StorageDTO::getCityFirstKey,Collectors.groupingBy(StorageDTO::getCityName)));</span><br><span class="line">        <span class="comment">//通过stream的聚合操作可以直接完成上面的一堆代码的操作，一句代码vs一堆代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到这两种方式的对比是非常明显的，使用Stream API的聚合操作，代码可读性更强。</p><h3 id="流的使用详解"><a href="#流的使用详解" class="headerlink" title="流的使用详解"></a>流的使用详解</h3><p>​    一个流在处理的过程中可能有<strong>Intermediate</strong>（对原数据创建流这个过程会对数据进行过滤和筛选，这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历）。<strong>Terminal</strong>操作会开始真实的遍历过程，会将先前的lazy的遍历条件全部执行。</p><p>​    lazy操作的意思是我们在进行类似filter操作以及limit等操作，实际上并没有开始执行，因为这样如果执行会面临比较大的效率问题。一次循环执行所有的lazy条件，这是对函数式编程的一种技能上的提升。</p><h4 id="流是如何构造"><a href="#流是如何构造" class="headerlink" title="流是如何构造"></a>流是如何构造</h4><p>​    当我们需要去获取或者构造一个流的时候，因为流提供的是一种聚合操作，所以流的数据源是不分层的，类似于简单的对象列表，是没有维度的。那么我们可以通过数组去构造或者通过数组去获得流。常见的几种流的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stream stream = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);<span class="comment">//单纯通过数组去构造流</span></span><br><span class="line"></span><br><span class="line">String [] strArray = <span class="keyword">new</span> String[] &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">stream = Stream.of(strArray);</span><br><span class="line">stream = Arrays.stream(strArray);</span><br><span class="line"><span class="comment">//通过数组容器直接获取到流应该是最常用的一种方式</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(strArray);</span><br><span class="line">stream = list.stream();</span><br></pre></td></tr></table></figure><h4 id="流的主要API"><a href="#流的主要API" class="headerlink" title="流的主要API"></a>流的主要API</h4><p>​    这个模块会主要展示流的几种主要的api，这里根据<strong>Intermediate</strong>，<strong>Short-circuiting</strong>，<strong>Terminal</strong>进行分类：</p><ul><li><p>Intermediate：</p><p>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered</p></li><li><p>Terminal：</p><p>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</p></li><li><p>Short-circuiting：</p><p>anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</p><p>我们下面看一下 Stream 的比较典型用法：</p></li></ul><h5 id="map-flatMap"><a href="#map-flatMap" class="headerlink" title="map/flatMap"></a>map/flatMap</h5><p>map提供流数据一对一的映射操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       arrayList.add(<span class="string">"I"</span>);</span><br><span class="line">       arrayList.add(<span class="string">"LOVE"</span>);</span><br><span class="line">       arrayList.add(<span class="string">"U"</span>);</span><br><span class="line">       arrayList.add(<span class="string">"TOO"</span>);</span><br><span class="line">       arrayList.add(<span class="string">"MUCH"</span>);</span><br><span class="line">       Stream&lt;String&gt; stream=arrayList.stream();</span><br><span class="line">       <span class="comment">//用map将字段映射成小写</span></span><br><span class="line">       List&lt;String&gt; stringList=stream.map(String::toLowerCase).collect(Collectors.toList());</span><br><span class="line">       System.out.println(stringList);</span><br></pre></td></tr></table></figure><p>flatMap提供流数据的一对多映射操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(</span><br><span class="line"> Arrays.asList(<span class="number">1</span>),</span><br><span class="line"> Arrays.asList(<span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line"> Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"> );</span><br><span class="line">Stream&lt;Integer&gt; outputStream = inputStream.</span><br><span class="line">flatMap((childList) -&gt; childList.stream());</span><br><span class="line"><span class="comment">//将一个数组列表的数据扁平化，一对多映射操作</span></span><br></pre></td></tr></table></figure><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><p>filter操作进行进行过滤流数据。例如我们可以对数据急性偶数和奇数的过滤，类似的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer[] sixNums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">Integer[] evens =</span><br><span class="line">Stream.of(sixNums).filter(n -&gt; n%<span class="number">2</span> == <span class="number">0</span>).toArray(Integer[]::<span class="keyword">new</span>);</span><br><span class="line"><span class="comment">//过滤数据</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; output = reader.lines().</span><br><span class="line"> flatMap(line -&gt; Stream.of(line.split(REGEXP))).</span><br><span class="line"> filter(word -&gt; word.length() &gt; <span class="number">0</span>).</span><br><span class="line"> collect(Collectors.toList());</span><br><span class="line"><span class="comment">//过滤单词，flatMap将一行单词转换为一个单词列表</span></span><br></pre></td></tr></table></figure><h5 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h5><p>forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roster.stream()</span><br><span class="line"> .filter(p -&gt; p.getGender() == Person.Sex.MALE)</span><br><span class="line"> .forEach(p -&gt; System.out.println(p.getName()));</span><br></pre></td></tr></table></figure><p>另外需要注意的是如果对一个stream进行两次terminal操作，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stream.forEach(element -&gt; doOneThing(element));</span><br><span class="line">stream.forEach(element -&gt; doAnotherThing(element));</span><br></pre></td></tr></table></figure><p>运行时会报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.IllegalStateException: stream has already been operated upon or closed </span><br><span class="line">at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:<span class="number">229</span>)</span><br><span class="line">at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:<span class="number">499</span>)</span><br><span class="line">at StreamAPI.StreamAPITest.main(StreamAPITest.java:<span class="number">33</span>)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:<span class="number">497</span>)</span><br><span class="line">at com.intellij.rt.execution.application.AppMain.main(AppMain.java:<span class="number">144</span>)</span><br></pre></td></tr></table></figure><p>那么如果我们需要在流数据过滤的过程中进行打印，可以不用terminal操作，采用Intermediate操作，上面的代码可以通过peek操作达到打印的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>)</span><br><span class="line"> .filter(e -&gt; e.length() &gt; <span class="number">3</span>)</span><br><span class="line"> .peek(e -&gt; System.out.println(<span class="string">"Filtered value: "</span> + e))</span><br><span class="line"> .map(String::toUpperCase)</span><br><span class="line"> .peek(e -&gt; System.out.println(<span class="string">"Mapped value: "</span> + e))<span class="comment">//不是teminal操作，Intermediate操作不会报错</span></span><br><span class="line"> .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><p>字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce，例如 Stream 的 sum 就相当于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer sum = integers.reduce(<span class="number">0</span>, (a, b) -&gt; a+b); <span class="comment">//前面是是初始值，右边是操作的元素的函数</span></span><br><span class="line">Integer sum = integers.reduce(<span class="number">0</span>, Integer::sum);:<span class="comment">//sum的简写方式</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找出最长的单词用reduce</span></span><br><span class="line">Optional&lt;String&gt; longest=stream.reduce((s1, s2)-&gt;s1.length()&gt;s2.length()?s1:s2);</span><br><span class="line">System.out.println(<span class="string">"reduce操作找出最长的单词字符串:"</span>);</span><br><span class="line">System.out.println(longest.get());</span><br><span class="line"><span class="comment">//reduce操作拼接字符串</span></span><br><span class="line">String concatStr=stream.reduce(<span class="string">""</span>,String::concat);</span><br><span class="line">System.out.println(<span class="string">"reduce操作拼接字符串"</span>+concatStr);</span><br></pre></td></tr></table></figure><h5 id="limit-skip-sorted"><a href="#limit-skip-sorted" class="headerlink" title="limit/skip/sorted"></a>limit/skip/sorted</h5><p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来），正常的sorted操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; personList=persons.stream().sorted((p1,p2)-&gt;p1.getAge().compareTo(p2.getAge())).limit(<span class="number">3</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>讲到这里可能大家比较好奇的是，这个自带的api是如何保证执行效率的，或者说它内部的时间效率如果是n2那作为调用方其实是未知的。那么实际上排序的时间复杂度是 O(n log n)</p><h5 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h5><p>Stream 有三个 match 方法，从语义上说：</p><ul><li>allMatch：Stream 中全部元素符合传入的 predicate，返回 true</li><li>anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true</li><li>noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList();</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"name"</span> + <span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">2</span>, <span class="string">"name"</span> + <span class="number">2</span>, <span class="number">21</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">3</span>, <span class="string">"name"</span> + <span class="number">3</span>, <span class="number">34</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">4</span>, <span class="string">"name"</span> + <span class="number">4</span>, <span class="number">6</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">5</span>, <span class="string">"name"</span> + <span class="number">5</span>, <span class="number">55</span>));</span><br><span class="line"><span class="keyword">boolean</span> isAllAdult = persons.stream().</span><br><span class="line"> allMatch(p -&gt; p.getAge() &gt; <span class="number">18</span>);</span><br><span class="line">System.out.println(<span class="string">"All are adult? "</span> + isAllAdult);</span><br><span class="line"><span class="keyword">boolean</span> isThereAnyChild = persons.stream().</span><br><span class="line"> anyMatch(p -&gt; p.getAge() &lt; <span class="number">12</span>);</span><br><span class="line">System.out.println(<span class="string">"Any child? "</span> + isThereAnyChild);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">All are adult? <span class="keyword">false</span></span><br><span class="line">Any child? <span class="keyword">true</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>运用Stream API最明显的感觉是提供了类似c++提供的一系列STL容器操作。帮主我们对容器进行更方便可读性更强的处理，减少了很多常用的重复代码。之后在工作种可以用这种写法，这里做一个总结stream的特性：</p><ul><li>不是数据结构</li></ul><ul><li>它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。</li><li>它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。</li></ul><ul><li>所有 Stream 的操作必须以 lambda 表达式为参数</li><li>不支持索引访问</li></ul><ul><li>你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。</li></ul><ul><li>很容易生成数组或者 List</li><li>惰性化</li></ul><ul><li>很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。</li><li>Intermediate 操作永远是惰性化的。</li></ul><ul><li>并行能力</li></ul><ul><li>当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。</li></ul><ul><li>集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Stream-API概述&quot;&gt;&lt;a href=&quot;#Stream-API概述&quot; class=&quot;headerlink&quot; title=&quot;Stream API概述&quot;&gt;&lt;/a&gt;Stream API概述&lt;/h3&gt;&lt;p&gt;​    Stream是Java8中的一大亮点，它为容器集合
      
    
    </summary>
    
    
      <category term="大搜车的点滴记录" scheme="http://jianghao.wang/tags/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%9A%84%E7%82%B9%E6%BB%B4%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
</feed>
