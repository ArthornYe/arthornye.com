<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TizzyT&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/9dde1b9d65b89035e235650923e5811e</icon>
  <subtitle>即使是拖后腿的，拼死努力的话，也是可以超越精英的。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jianghao.wang/"/>
  <updated>2020-07-30T07:42:07.380Z</updated>
  <id>http://jianghao.wang/</id>
  
  <author>
    <name>yeqiaozhu</name>
    <email>yqz_zjut@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring事务注解失效的几种场景</title>
    <link href="http://jianghao.wang/2020/Spring/Spring%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF/"/>
    <id>http://jianghao.wang/2020/Spring/Spring事务注解失效的几种场景/</id>
    <published>2020-07-30T07:30:51.239Z</published>
    <updated>2020-07-30T07:42:07.380Z</updated>
    
    <content type="html"><![CDATA[<p>Spring中事务注解@Transactional在一些情况下会失效，主要介绍几种可能导致事务注解失效的场景。</p><h3 id="场景一：同类方法嵌套调用"><a href="#场景一：同类方法嵌套调用" class="headerlink" title="场景一：同类方法嵌套调用"></a>场景一：同类方法嵌套调用</h3><p>Spring可以通过动态代理进行类增强，A类中A方法未加注解，A类中B方法加了@Transactional注解，那么如果从A入口调用B方法，会导致事务注解失效。伪代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testA</span><span class="params">()</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"调用本类A方法"</span>);</span><br><span class="line">   testB();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Transactional</span>(rollbackFor = Exception.class)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//更新第一个</span></span><br><span class="line">   ShipmentDO shipmentDO=<span class="keyword">new</span> ShipmentDO();</span><br><span class="line">   shipmentDO.setShipmentId(<span class="number">36156474</span>);</span><br><span class="line">   shipmentDO.setPackboxIsOut(<span class="string">"Y"</span>);</span><br><span class="line">   shipmentMapper.update(shipmentDO);</span><br><span class="line">   <span class="comment">//模拟抛出异常</span></span><br><span class="line">   String string=<span class="keyword">null</span>;</span><br><span class="line">   String A=<span class="string">"A"</span>;</span><br><span class="line">   <span class="keyword">if</span> (string.equals(A))&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//更新第二个</span></span><br><span class="line">   ShipmentDO shipmentDO1=<span class="keyword">new</span> ShipmentDO();</span><br><span class="line">   shipmentDO1.setShipmentId(<span class="number">36156846</span>);</span><br><span class="line">   shipmentDO1.setPackboxIsOut(<span class="string">"Y"</span>);</span><br><span class="line">   shipmentMapper.update(shipmentDO1);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这段代码的结果是第一个更新操作成功写入，说明testB方法并没有达到事务控制的效果。如果我们需要达到事务控制的效果，需要从testB直接进入。</p><h3 id="场景一总结"><a href="#场景一总结" class="headerlink" title="场景一总结"></a>场景一总结</h3><ul><li>spring采用动态代理（AOP）实现对Bean的管理和切片, 它为我们的每个class生成一个代理对象, 只有在代理对象之间进行调用时, 可以触发切面逻辑</li><li>在同一个类中, 方法B调用A, 调用的是当前对象的方法, 而不是通过代理对象, 所以spring无法切到这次调用, 也就是无法通过注解保证事务性</li><li>通过SpringUtil.getBean(this.class)获取当前类的代理对象</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring中事务注解@Transactional在一些情况下会失效，主要介绍几种可能导致事务注解失效的场景。&lt;/p&gt;
&lt;h3 id=&quot;场景一：同类方法嵌套调用&quot;&gt;&lt;a href=&quot;#场景一：同类方法嵌套调用&quot; class=&quot;headerlink&quot; title=&quot;场景一：同
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://jianghao.wang/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>二分通用总结</title>
    <link href="http://jianghao.wang/2020/leetCode%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E9%80%9A%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://jianghao.wang/2020/leetCode算法/二分通用总结/</id>
    <published>2020-03-30T10:34:25.024Z</published>
    <updated>2020-03-30T10:35:13.415Z</updated>
    
    <content type="html"><![CDATA[<p>本篇总结下二分查找在不同的场景下的书写模板。在书写二分查找的过程中，通常会对while条件和内部判断条件有一定的困惑,这里总结一个未来通用的模板。<br>通用模板如下：</p><ul><li>1.第一步定义start和end。</li><li>2.第二步循环中找到中间位置mid（这里需要注意数值越界）。</li><li>3.第三步确定左移或者右移判断条件（具体情况具体分析）。</li><li>4.第四步根据比较的结果位移（左移end=mid-1,右移start=mid+1）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//step1 定义start和end</span></span><br><span class="line">        <span class="keyword">long</span> start=<span class="number">0</span>,end= n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start&lt;=end)&#123;</span><br><span class="line">            <span class="keyword">long</span> mid=start+(end-start)/<span class="number">2</span>;<span class="comment">//step2 这样定义可以适当防止int越界还是不行可以用long类型</span></span><br><span class="line">            <span class="comment">//step3 获取比较值  这里可以视具体的情况确定</span></span><br><span class="line">            <span class="keyword">long</span> temp=(<span class="number">2</span>+mid)*(mid+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//step4 根据比较的结果进行位移 注意这里必须是mid-1或者mid+1不然start的位置有可能不会超过end</span></span><br><span class="line">            <span class="keyword">if</span>(temp&gt;n)&#123;</span><br><span class="line">                end=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                start=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().arrangeCoins(<span class="number">8</span>));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().arrangeCoins(<span class="number">1804289383</span>));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().arrangeCoins(<span class="number">5</span>));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().arrangeCoins(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().arrangeCoins(<span class="number">2</span>));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().arrangeCoins(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P441-Arranging-Coins"><a href="#P441-Arranging-Coins" class="headerlink" title="P441. Arranging Coins"></a>P441. Arranging Coins</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Example 1:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * n = 5</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The coins can form the following rows:</span></span><br><span class="line"><span class="comment"> * ¤</span></span><br><span class="line"><span class="comment"> * ¤ ¤</span></span><br><span class="line"><span class="comment"> * ¤ ¤</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Because the 3rd row is incomplete, we return 2.</span></span><br><span class="line"><span class="comment"> * Example 2:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * n = 8</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The coins can form the following rows:</span></span><br><span class="line"><span class="comment"> * ¤</span></span><br><span class="line"><span class="comment"> * ¤ ¤</span></span><br><span class="line"><span class="comment"> * ¤ ¤ ¤</span></span><br><span class="line"><span class="comment"> * ¤ ¤</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Because the 4th row is incomplete, we return 3.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//step1 定义start和end</span></span><br><span class="line">        <span class="keyword">long</span> start=<span class="number">0</span>,end= n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start&lt;=end)&#123;</span><br><span class="line">            <span class="keyword">long</span> mid=(start+end)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//计算当前梯队的值</span></span><br><span class="line">            <span class="keyword">long</span> temp=(<span class="number">2</span>+mid)*(mid+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(temp&gt;n)&#123;</span><br><span class="line">                end=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                start=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().arrangeCoins(<span class="number">8</span>));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().arrangeCoins(<span class="number">1804289383</span>));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().arrangeCoins(<span class="number">5</span>));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().arrangeCoins(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().arrangeCoins(<span class="number">2</span>));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().arrangeCoins(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P852-Peak-Index-in-a-Mountain-Array"><a href="#P852-Peak-Index-in-a-Mountain-Array" class="headerlink" title="P852. Peak Index in a Mountain Array"></a>P852. Peak Index in a Mountain Array</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example 1:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Input: [0,1,0]</span></span><br><span class="line"><span class="comment"> * Output: 1</span></span><br><span class="line"><span class="comment"> * Example 2:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Input: [0,2,1,0]</span></span><br><span class="line"><span class="comment"> * Output: 1</span></span><br><span class="line"><span class="comment"> * Note:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3 &lt;= A.length &lt;= 10000</span></span><br><span class="line"><span class="comment"> * 0 &lt;= A[i] &lt;= 10^6</span></span><br><span class="line"><span class="comment"> * A is a mountain, as defined above.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,end=A.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start&lt;=end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=start+(end-start)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (A[mid+<span class="number">1</span>]&lt;A[mid]) &#123;</span><br><span class="line">                end=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                start=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().peakIndexInMountainArray(ints));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ints1=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().peakIndexInMountainArray(ints1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P162-Find-Peak-Element"><a href="#P162-Find-Peak-Element" class="headerlink" title="P162. Find Peak Element"></a>P162. Find Peak Element</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本题虽然是会出现多个peak number但是只需要定位其中一个即可</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 方法一：一遍扫描是可以的</span></span><br><span class="line"><span class="comment"> * 方法二：二分搜索到其中一个peak number就行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example 1:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Input: nums = [1,2,3,1]</span></span><br><span class="line"><span class="comment"> * Output: 2</span></span><br><span class="line"><span class="comment"> * Explanation: 3 is a peak element and your function should return the index number 2.</span></span><br><span class="line"><span class="comment"> * Example 2:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Input: nums = [1,2,1,3,5,6,4]</span></span><br><span class="line"><span class="comment"> * Output: 1 or 5</span></span><br><span class="line"><span class="comment"> * Explanation: Your function can return either index number 1 where the peak element is 2,</span></span><br><span class="line"><span class="comment"> *              or index number 5 where the peak element is 6.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,end=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start&lt;=end)&#123;</span><br><span class="line">            <span class="keyword">if</span> (start==end &amp;&amp; end==nums.length-<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> mid=start+(end-start)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&lt;nums[mid+<span class="number">1</span>]) &#123;</span><br><span class="line">                start=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                end=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().findPeakElement(ints));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ints1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().findPeakElement(ints1));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ints2=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().findPeakElement(ints2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇总结下二分查找在不同的场景下的书写模板。在书写二分查找的过程中，通常会对while条件和内部判断条件有一定的困惑,这里总结一个未来通用的模板。&lt;br&gt;通用模板如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.第一步定义start和end。&lt;/li&gt;
&lt;li&gt;2.第二步循环中找到中间
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring Bean的生命周期</title>
    <link href="http://jianghao.wang/2020/Spring/Spring%20Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://jianghao.wang/2020/Spring/Spring Bean的生命周期/</id>
    <published>2020-03-26T06:20:52.571Z</published>
    <updated>2020-03-27T03:30:44.551Z</updated>
    
    <content type="html"><![CDATA[<p>Spring上下文中的Bean生命周期如下：</p><h3 id="1-实例化Bean"><a href="#1-实例化Bean" class="headerlink" title="1.实例化Bean"></a>1.实例化Bean</h3><p>对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。</p><p>对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean。</p><h3 id="2-设置对象属性（依赖注入）"><a href="#2-设置对象属性（依赖注入）" class="headerlink" title="2.设置对象属性（依赖注入）"></a>2.设置对象属性（依赖注入）</h3><p>实例化后的对象被封装在BeanWrapper对象中，紧接着，Spring根据BeanDefinition中的信息 以及 通过BeanWrapper提供的设置属性的接口完成依赖注入。</p><h3 id="3-处理Aware接口"><a href="#3-处理Aware接口" class="headerlink" title="3.处理Aware接口"></a>3.处理Aware接口</h3><p>接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给Bean：</p><ul><li><p><strong>如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方法，此处传递的就是Spring配置文件中Bean的id值。</strong></p></li><li><p><strong>如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()方法，传递的是Spring工厂自身。</strong></p></li><li><p><strong>如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文。</strong></p></li></ul><h3 id="4-BeanPostProcessor："><a href="#4-BeanPostProcessor：" class="headerlink" title="4.BeanPostProcessor："></a>4.BeanPostProcessor：</h3><p>如果想对Bean进行一些自定义的处理，那么可以让Bean实现了BeanPostProcessor接口，那将会调用postProcessBeforeInitialization(Object obj, String s)方法。</p><p>由于这个方法是在Bean初始化结束时调用的，所以可以被应用于内存或缓存技术；</p><h3 id="5-InitializingBean-与-init-method："><a href="#5-InitializingBean-与-init-method：" class="headerlink" title="5.InitializingBean 与 init-method："></a>5.InitializingBean 与 init-method：</h3><p>如果Bean在Spring配置文件中配置了 init-method 属性，则会自动调用其配置的初始化方法。</p><h3 id="6-postProcessAfterInitialization："><a href="#6-postProcessAfterInitialization：" class="headerlink" title="6.postProcessAfterInitialization："></a>6.postProcessAfterInitialization：</h3><p>如果这个Bean实现了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法；</p><p>以上几个步骤完成后，Bean就已经被正确创建了，之后就可以使用这个Bean了。</p><h3 id="7-DisposableBean："><a href="#7-DisposableBean：" class="headerlink" title="7.DisposableBean："></a>7.DisposableBean：</h3><p>当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy()方法；</p><h3 id="8-destroy-method："><a href="#8-destroy-method：" class="headerlink" title="8.destroy-method："></a>8.destroy-method：</h3><p>最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring上下文中的Bean生命周期如下：&lt;/p&gt;
&lt;h3 id=&quot;1-实例化Bean&quot;&gt;&lt;a href=&quot;#1-实例化Bean&quot; class=&quot;headerlink&quot; title=&quot;1.实例化Bean&quot;&gt;&lt;/a&gt;1.实例化Bean&lt;/h3&gt;&lt;p&gt;对于BeanFactor
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://jianghao.wang/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring事务传播行为</title>
    <link href="http://jianghao.wang/2020/Spring/Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E7%BA%A7%E5%88%AB/"/>
    <id>http://jianghao.wang/2020/Spring/Spring事务传播级别/</id>
    <published>2020-03-24T15:34:20.624Z</published>
    <updated>2020-12-03T09:29:50.732Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录几种主要的Spring事务传播行为。</p><h3 id="Spring事务传播行为"><a href="#Spring事务传播行为" class="headerlink" title="Spring事务传播行为"></a>Spring事务传播行为</h3><h4 id="1-PROPAGATION-REQUIRED（默认）"><a href="#1-PROPAGATION-REQUIRED（默认）" class="headerlink" title="1.PROPAGATION_REQUIRED（默认）"></a>1.PROPAGATION_REQUIRED（默认）</h4><p><strong>在外围方法开启事务的情况下<code>Propagation.REQUIRED</code>修饰的内部方法会加入到外围方法的事务中，所有<code>Propagation.REQUIRED</code>修饰的内部方法和外围方法均属于同一事务，只要一个方法回滚，整个事务均回滚。</strong></p><h4 id="2-PROPAGATION-NESTED（嵌套子事务）"><a href="#2-PROPAGATION-NESTED（嵌套子事务）" class="headerlink" title="2.PROPAGATION_NESTED（嵌套子事务）"></a>2.PROPAGATION_NESTED（嵌套子事务）</h4><p><strong>在外围方法开启事务的情况下<code>Propagation.NESTED</code>修饰的内部方法属于外部事务的子事务，外围主事务回滚，子事务一定回滚，而内部子事务可以单独回滚而不影响外围主事务和其他子事务。</strong></p><h4 id="3-PROPAGATION-REQUIRES-NEW-（独立新事务）"><a href="#3-PROPAGATION-REQUIRES-NEW-（独立新事务）" class="headerlink" title="3.PROPAGATION_REQUIRES_NEW （独立新事务）"></a>3.PROPAGATION_REQUIRES_NEW （独立新事务）</h4><p><strong>在外围方法开启事务的情况下<code>Propagation.REQUIRES_NEW</code>修饰的内部方法依然会单独开启独立事务，且与外部方法事务也独立，内部方法之间、内部方法和外部方法事务均相互独立，互不干扰。</strong></p><h4 id="4-PROPAGATION-NOT-SUPPORTED"><a href="#4-PROPAGATION-NOT-SUPPORTED" class="headerlink" title="4.PROPAGATION_NOT_SUPPORTED"></a>4.PROPAGATION_NOT_SUPPORTED</h4><p><strong>如果没有，就以非事务方式执行</strong>（如果发现方法A没有开启事务，则方法B也不开启事务）；<strong>如果有，就将当前事务挂起</strong>。（方法A的事务挂起，而方法B非事务的状态运行完，再继续方法A的事务。）这就是 <strong>PROPAGATION_NOT_SUPPORTED</strong>，这种方式非常强硬，没有就没有，有我也不支持你，把你挂起来，不鸟你。</p><h4 id="5-PROPAGATION-SUPPORTED"><a href="#5-PROPAGATION-SUPPORTED" class="headerlink" title="5. PROPAGATION_SUPPORTED"></a>5. PROPAGATION_SUPPORTED</h4><p><strong>如果没有，就以非事务方式执行</strong>（如果发现方法A没有开启事务，则方法B也不开启事务）；<strong>如果有，就加入当前事务。</strong>（方法B看到自己已经运行在方法A的事务内部，就不再起新的事务，直接加入方法A）。这就是 <strong>PROPAGATION_SUPPORTS</strong>，这种方式非常随意，没有就没有，有就有，有点无所谓的态度，反正我是支持你的。</p><h4 id="6-PROPAGATION-NEVER"><a href="#6-PROPAGATION-NEVER" class="headerlink" title="6.PROPAGATION_NEVER"></a>6.PROPAGATION_NEVER</h4><p><strong>如果没有，就以非事务方式执行</strong>（如果发现方法A没有开启事务，则方法B也不开启事务）；<strong>如果有，就抛出异常</strong>（如果发现方法A有开启事务，则方法B直接抛出异常）。这就是 <strong>PROPAGATION_NEVER</strong>，这种方式更猛，没有就没有，有了反而报错，确实够牛的，它说：我从不支持事务！</p><h4 id="7-PROPAGATION-MANDATORY"><a href="#7-PROPAGATION-MANDATORY" class="headerlink" title="7.PROPAGATION_MANDATORY"></a>7.PROPAGATION_MANDATORY</h4><p>如果没有，就抛出异常；如果有，就使用当前事务。这就是 <strong><code>PROPAGATION_MANDATORY</code></strong>，这种方式可以说是牛逼中的牛逼了，没有事务直接就报错，确实够狠的，它说：我必须要有事务！</p><p><img src="http://arthornye.github.io/images/事务传播行为.jpg" alt="cmd-markdown-logo"></p><p>记录一片比较好的文章参考方便复习:<a href="https://segmentfault.com/a/1190000013341344#comment-area" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013341344#comment-area</a></p><h3 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h3><p>在外围方法开启事务的前提下，内部事务的传播行为REQUIRED，此时如果外部方法捕获内部方法的异常直接吞掉，外部事务在提交的时候会报<strong>Transaction rolled back because it has been marked as rollback-only</strong>。这是因为内部事务在回滚的时候已经将rollback-only设置为true，那么外部事务切面在执行的时候虽然没有捕获到异常但是判断这个状态为true，则进行回滚。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>在乐其的工作中，通常会有处理一张数据量超大的表的需求。</p><ul><li><p>通常我们为了避免大事务会将这个事务分成几个独立事务分别进行提交，并汇总执行的结果。</p></li><li><p>其中一个失误发生异常通过try catch捕获，不影响其他事务。</p></li></ul><p>1.内部方法添加独立事务注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception.class,propagation = Propagation.REQUIRES_NEW)</span><br></pre></td></tr></table></figure><p>2.外部方法添加事务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception.class,propagation = Propagation.REQUIRED)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文记录几种主要的Spring事务传播行为。&lt;/p&gt;
&lt;h3 id=&quot;Spring事务传播行为&quot;&gt;&lt;a href=&quot;#Spring事务传播行为&quot; class=&quot;headerlink&quot; title=&quot;Spring事务传播行为&quot;&gt;&lt;/a&gt;Spring事务传播行为&lt;/h3&gt;&lt;h4
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://jianghao.wang/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>乐其工作记录</title>
    <link href="http://jianghao.wang/2020/%E5%A4%A7%E6%90%9C%E8%BD%A6%E7%82%B9%E6%BB%B4%E8%AE%B0%E5%BD%95/%E4%B9%90%E5%85%B6%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
    <id>http://jianghao.wang/2020/大搜车点滴记录/乐其工作记录/</id>
    <published>2020-03-24T09:05:43.015Z</published>
    <updated>2020-10-15T07:15:36.185Z</updated>
    
    <content type="html"><![CDATA[<h4 id="工作问题记录"><a href="#工作问题记录" class="headerlink" title="工作问题记录"></a>工作问题记录</h4><h3 id="安装nacos出现问题"><a href="#安装nacos出现问题" class="headerlink" title="安装nacos出现问题"></a>安装nacos出现问题</h3><p>/nacos/conf/cluster.conf (No such file or directory)启动日志报错。查询发现是以集群的方式启动了，改成以单机的方式启动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh startup.sh -m standalone</span><br></pre></td></tr></table></figure><h3 id="为什么要加-Transactional-rollbackFor-Exception-class"><a href="#为什么要加-Transactional-rollbackFor-Exception-class" class="headerlink" title="为什么要加@Transactional(rollbackFor = Exception.class)"></a>为什么要加@Transactional(rollbackFor = Exception.class)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这种设置是因为Spring的默认回滚RuntimeException，如果想要回滚Exception时，要设置<span class="meta">@Transactional</span>(rollbackFor = Exception.class)，而且Exception还要抛出。</span><br></pre></td></tr></table></figure><h4 id="产品运营反馈问题"><a href="#产品运营反馈问题" class="headerlink" title="产品运营反馈问题"></a>产品运营反馈问题</h4><p>某商品库存被单据占有无法分配，提供barcode进行排查。</p><ul><li><p>1.根据barcode查到商品id，观察qty_total和qty_available判断可能是哪个order_goods_id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from wms.product_location pl inner join wms.product p on pl.product_id=p.product_id </span><br><span class="line">where p.barcode=&apos;pxp001&apos;</span><br></pre></td></tr></table></figure></li><li><p>2.查到order_goods_id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">select count(1), order_goods_id from (</span><br><span class="line">(select order_goods_id</span><br><span class="line">from wms.order_goods where order_id in (select distinct op.order_id from wms.product_location_detail pld</span><br><span class="line">inner join wms.task t on pld.task_id = t.task_id</span><br><span class="line">inner join wms.order_process op on t.batch_pick_id = op.batch_pick_id</span><br><span class="line">where pld.pl_id in (</span><br><span class="line">select pl.pl_id from wms.product_location pl</span><br><span class="line">inner join wms.location l on pl.location_id = l.location_id</span><br><span class="line">where product_id = 73172 and l.location_type = &apos;TRANSIT_LOCATION&apos; and pl.physical_warehouse_id=1164 and pl.customer_id=1087)) and product_id =  73172)</span><br><span class="line">union all </span><br><span class="line">(select og.order_goods_id from wms.order_goods og </span><br><span class="line">inner join wms.product_location_detail pld on og.order_goods_id = pld.order_goods_id</span><br><span class="line">inner join wms.product_location pl on pld.pl_id = pl.pl_id</span><br><span class="line">inner join wms.location l on pl.location_id = l.location_id</span><br><span class="line">where og.product_id = 73172 and l.location_type = &apos;TRANSIT_LOCATION&apos; and pl.physical_warehouse_id=1164 and pl.customer_id=1087) ) as ob</span><br><span class="line">group by order_goods_id </span><br><span class="line">having count(1) = 1;</span><br></pre></td></tr></table></figure></li><li><p>3.排查该订单的订单轨迹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from wms.user_action_order where order_id=4381294</span><br><span class="line">select * from wms.order_goods where order_id=2351367  </span><br><span class="line">select * from wms.order_inventory_return where order_id=2351367</span><br></pre></td></tr></table></figure></li></ul><h4 id="RequestParam接收不到前端参数"><a href="#RequestParam接收不到前端参数" class="headerlink" title="@RequestParam接收不到前端参数"></a>@RequestParam接收不到前端参数</h4><p>application/x-www-form-urlencoded是以表格的形式请求，而application/json则将数据序列化后才进行传递，如果使用了@RequestParam会在Content里面查找对应的数据，结果因为传递的数据已经被序列化所以不能找到，所以当要使用@RequestParam注解时候应当使用application/x-www-form-urlencoded，而如果想要使用application/json则应当使用@RequestBody获取被序列化的参数。</p><h4 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick "></a>git cherry-pick <commithash></commithash></h4><p>在公共分支上不小心提交了开发分支的代码，可以查看当前提交的id，从开发分支上cherry-pick这个提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git cherry-pick &lt;commitHash&gt;</span><br></pre></td></tr></table></figure><h2 id="java-lang-ClassNotFoundException"><a href="#java-lang-ClassNotFoundException" class="headerlink" title="java.lang.ClassNotFoundException:"></a>java.lang.ClassNotFoundException:</h2><p>集成支付宝时候，启动时候发现报了这个错误，java.lang.NoClassDefFoundError: com/alipay/api/AlipayApiException</p><p>百思不得其解，lib已经导入了，然后发现在tomcat的war包里面的lib没有阿里爸爸的包,用的是idea工具，因为已经添加了alipay的jar包所以重新模拟下。右键打开modul设置，Arifacts—&gt;选择自己项目—&gt;lib—&gt;Add Copy of–&gt;Libray Files 选择alipay.jar包即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;工作问题记录&quot;&gt;&lt;a href=&quot;#工作问题记录&quot; class=&quot;headerlink&quot; title=&quot;工作问题记录&quot;&gt;&lt;/a&gt;工作问题记录&lt;/h4&gt;&lt;h3 id=&quot;安装nacos出现问题&quot;&gt;&lt;a href=&quot;#安装nacos出现问题&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="乐其工作记录" scheme="http://jianghao.wang/tags/%E4%B9%90%E5%85%B6%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://jianghao.wang/2020/Untitled/"/>
    <id>http://jianghao.wang/2020/Untitled/</id>
    <published>2020-02-19T05:43:42.375Z</published>
    <updated>2020-02-19T05:43:42.375Z</updated>
    
    <content type="html"><![CDATA[<p>Step1</p><p>调用接口/wms/web/inside/process/management/info/exception/save</p><p>入参：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"exceptionTypes"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"exceptionType"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"exceptionType"</span>: <span class="string">"SELF_DEFINE_EXCEPTION"</span>,</span><br><span class="line">          <span class="string">"exceptionName"</span>: <span class="string">"自定义1"</span>,</span><br><span class="line">          <span class="string">"exceptionNumber"</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="string">"exceptionUnit"</span>: <span class="string">"box"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"exceptionType"</span>: <span class="string">"SELF_DEFINE_EXCEPTION"</span>,</span><br><span class="line">          <span class="string">"exceptionName"</span>: <span class="string">"自定义2"</span>,</span><br><span class="line">          <span class="string">"exceptionNumber"</span>: <span class="number">2</span>,</span><br><span class="line">          <span class="string">"exceptionUnit"</span>: <span class="string">"box"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">"id"</span>: <span class="number">29545</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"processInfoId"</span>: <span class="number">11757</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step2"><a href="#Step2" class="headerlink" title="Step2"></a>Step2</h3><p>调用/wms/web/inside/process/management/goods/list?processInfoId=11757获取异常</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">                <span class="string">"exceptionType"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">"exceptionType"</span>: <span class="string">"SELF_DEFINE_EXCEPTION"</span>,</span><br><span class="line">                        <span class="string">"exceptionNumber"</span>: <span class="number">1</span>,</span><br><span class="line">                        <span class="string">"exceptionId"</span>: <span class="string">"ebc53c1a-5b3e-4289-8e4c-26462b10bd62"</span>,</span><br><span class="line">                        <span class="string">"exceptionUnit"</span>: <span class="string">"box"</span>,</span><br><span class="line">                        <span class="string">"exceptionName"</span>: <span class="string">"自定义1"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">"exceptionType"</span>: <span class="string">"SELF_DEFINE_EXCEPTION"</span>,</span><br><span class="line">                        <span class="string">"exceptionNumber"</span>: <span class="number">2</span>,</span><br><span class="line">                        <span class="string">"exceptionId"</span>: <span class="string">"a7cc0058-a631-4b80-983c-d5404494ca37"</span>,</span><br><span class="line">                        <span class="string">"exceptionUnit"</span>: <span class="string">"box"</span>,</span><br><span class="line">                        <span class="string">"exceptionName"</span>: <span class="string">"自定义2"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">"costBoxes"</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="string">"length"</span>: <span class="number">33.000</span>,</span><br><span class="line">                <span class="string">"productName"</span>: <span class="string">"舒洁那些年系列手帕纸3层给力特惠 30包装 【2738】"</span>,</span><br><span class="line">                <span class="string">"spec"</span>: <span class="number">12</span>,</span><br><span class="line">                <span class="string">"picUrl"</span>: <span class="string">""</span>,</span><br><span class="line">                <span class="string">"goodsNumber"</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="string">"costNumbers"</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="string">"goodsBox"</span>: <span class="string">"0箱又1件"</span>,</span><br><span class="line">                <span class="string">"width"</span>: <span class="number">20.000</span>,</span><br><span class="line">                <span class="string">"doneNumber"</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="string">"id"</span>: <span class="number">29545</span>,</span><br><span class="line">                <span class="string">"barcode"</span>: <span class="string">"6923589427386"</span>,</span><br><span class="line">                <span class="string">"height"</span>: <span class="number">16.000</span>,</span><br><span class="line">                <span class="string">"status"</span>: <span class="string">"DONE"</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Step1&lt;/p&gt;
&lt;p&gt;调用接口/wms/web/inside/process/management/info/exception/save&lt;/p&gt;
&lt;p&gt;入参：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>有意思的利用栈实现二叉树的三种遍历</title>
    <link href="http://jianghao.wang/2020/leetCode%E7%AE%97%E6%B3%95/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E5%88%A9%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86/"/>
    <id>http://jianghao.wang/2020/leetCode算法/有意思的利用栈实现二叉树三种遍历/</id>
    <published>2020-01-03T06:30:13.099Z</published>
    <updated>2020-01-03T06:35:10.922Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树的preorder,inorder,postorder三种遍历方式，通过递归都能比较优雅的实现，但是递归可能会遇到递归栈过深的情况，如果考虑到这些情况，可以用stack栈替代递归的方案，这里列举三种遍历方式用递归替代的方案，个人认为比较巧妙。</p><h3 id="preorder"><a href="#preorder" class="headerlink" title="preorder"></a>preorder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//step1 栈保存右节点</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; result= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环迭代</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode current=stack.pop();</span><br><span class="line">            result.add(current.val);</span><br><span class="line">            <span class="comment">//将先输出的节点放到栈顶 bread-first-search是直接按照从左到右的顺序（利用队列） 这里是利用stack特点将左子树遍历完（利用栈）</span></span><br><span class="line">            <span class="keyword">if</span> (current.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(current.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(current.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="inorder"><a href="#inorder" class="headerlink" title="inorder"></a>inorder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode curr=root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curr!=<span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (curr!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(curr);</span><br><span class="line">                curr=curr.left;</span><br><span class="line">            &#125;</span><br><span class="line">            curr=stack.pop();</span><br><span class="line">            res.add(curr.val);</span><br><span class="line">            curr=curr.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="postorder"><a href="#postorder" class="headerlink" title="postorder"></a>postorder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">     List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">     Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">     stack.push(root);</span><br><span class="line">     <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">         TreeNode curr = stack.pop();</span><br><span class="line">         list.add(<span class="number">0</span>,curr.val);</span><br><span class="line">         <span class="keyword">if</span>(curr.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">             stack.push(curr.left);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(curr.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">             stack.push(curr.right);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> list;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;二叉树的preorder,inorder,postorder三种遍历方式，通过递归都能比较优雅的实现，但是递归可能会遇到递归栈过深的情况，如果考虑到这些情况，可以用stack栈替代递归的方案，这里列举三种遍历方式用递归替代的方案，个人认为比较巧妙。&lt;/p&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>寻找中位数算法通用总结</title>
    <link href="http://jianghao.wang/2019/leetCode%E7%AE%97%E6%B3%95/%E5%AF%BB%E6%89%BE%E4%B8%AD%E4%BD%8D%E6%95%B0%E7%AE%97%E6%B3%95%E9%80%9A%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://jianghao.wang/2019/leetCode算法/寻找中位数算法通用总结/</id>
    <published>2019-12-27T09:57:35.043Z</published>
    <updated>2020-01-02T02:42:39.118Z</updated>
    
    <content type="html"><![CDATA[<p>寻找中位数我们通常可以从三个角度去思考，第一种方式利用双指针(前提是已经分别排序好)，第二种方式利用排序，第三种方式利用堆或者树。这里我们主要介绍利用堆或者树的解题模板。</p><h3 id="P295-MedianFinder-难度中等"><a href="#P295-MedianFinder-难度中等" class="headerlink" title="P295 MedianFinder(难度中等)"></a>P295 MedianFinder(难度中等)</h3><p>解题思路，定义一个最大堆，定义一个最小堆，保证最大堆中的元素大于最小堆中的元素数量并且不超过一个。可以通过一段代码套用模板实现，<strong><em>先插入最大堆，然后将最大堆中的堆顶元素(最大值)插入到最小堆中；如果最大堆中的元素小于最小堆中的元素数量，将最小堆的堆顶元素(最小值)弹出到最大堆中</em></strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    maxHeap.offer(num);</span><br><span class="line">    minHeap.offer(maxHeap.poll());</span><br><span class="line">    <span class="keyword">if</span> (maxHeap.size()&lt;minHeap.size()) &#123;</span><br><span class="line">      maxHeap.offer(minHeap.poll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的方式构造的最大最小堆，我们只需要考虑堆顶的元素即可找出中位数，如果是偶数，那么中位数是两个堆顶元素的平均数，如果是奇数，那么中位数是最大堆的堆顶元素。这道题得到的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Design.P295;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Adding number 41</span></span><br><span class="line"><span class="comment"> * MaxHeap lo: [41]           // MaxHeap stores the largest value at the top (index 0)</span></span><br><span class="line"><span class="comment"> * MinHeap hi: []             // MinHeap stores the smallest value at the top (index 0)</span></span><br><span class="line"><span class="comment"> * Median is 41</span></span><br><span class="line"><span class="comment"> * =======================</span></span><br><span class="line"><span class="comment"> * Adding number 35</span></span><br><span class="line"><span class="comment"> * MaxHeap lo: [35]</span></span><br><span class="line"><span class="comment"> * MinHeap hi: [41]</span></span><br><span class="line"><span class="comment"> * Median is 38</span></span><br><span class="line"><span class="comment"> * =======================</span></span><br><span class="line"><span class="comment"> * Adding number 62</span></span><br><span class="line"><span class="comment"> * MaxHeap lo: [41, 35]</span></span><br><span class="line"><span class="comment"> * MinHeap hi: [62]</span></span><br><span class="line"><span class="comment"> * Median is 41</span></span><br><span class="line"><span class="comment"> * =======================</span></span><br><span class="line"><span class="comment"> * Adding number 4</span></span><br><span class="line"><span class="comment"> * MaxHeap lo: [35, 4]</span></span><br><span class="line"><span class="comment"> * MinHeap hi: [41, 62]</span></span><br><span class="line"><span class="comment"> * Median is 38</span></span><br><span class="line"><span class="comment"> * =======================</span></span><br><span class="line"><span class="comment"> * Adding number 97</span></span><br><span class="line"><span class="comment"> * MaxHeap lo: [41, 35, 4]</span></span><br><span class="line"><span class="comment"> * MinHeap hi: [62, 97]</span></span><br><span class="line"><span class="comment"> * Median is 41</span></span><br><span class="line"><span class="comment"> * =======================</span></span><br><span class="line"><span class="comment"> * Adding number 108</span></span><br><span class="line"><span class="comment"> * MaxHeap lo: [41, 35, 4]</span></span><br><span class="line"><span class="comment"> * MinHeap hi: [62, 97, 108]</span></span><br><span class="line"><span class="comment"> * Median is 51.5</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * addNum(2)</span></span><br><span class="line"><span class="comment"> * findMedian() -&gt; 1.5</span></span><br><span class="line"><span class="comment"> * addNum(3)</span></span><br><span class="line"><span class="comment"> * findMedian() -&gt; 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="comment">/** 定义一个最大堆和一个最小堆*/</span></span><br><span class="line">    Queue&lt;Integer&gt; minHeap= <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">//传入一个倒序的比较器</span></span><br><span class="line">    Queue&lt;Integer&gt; maxHeap= <span class="keyword">new</span> PriorityQueue&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        maxHeap.offer(num);</span><br><span class="line">        minHeap.offer(maxHeap.poll());</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size()&lt;minHeap.size()) &#123;</span><br><span class="line">            maxHeap.offer(minHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minSize=minHeap.size();</span><br><span class="line">        <span class="keyword">int</span> maxSize=maxHeap.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (((maxSize+minSize)&amp;<span class="number">1</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (minHeap.peek()+maxHeap.peek())/<span class="number">2.0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> maxHeap.peek()/<span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MedianFinder medianFinder=<span class="keyword">new</span> MedianFinder();</span><br><span class="line">        medianFinder.addNum(<span class="number">1</span>);</span><br><span class="line">        medianFinder.addNum(<span class="number">2</span>);</span><br><span class="line">        System.out.println(medianFinder.findMedian()); <span class="comment">//-&gt; 1.5</span></span><br><span class="line">        medianFinder.addNum(<span class="number">3</span>);</span><br><span class="line">        System.out.println(medianFinder.findMedian()); <span class="comment">//-&gt; 2</span></span><br><span class="line">        medianFinder.addNum(<span class="number">5</span>);</span><br><span class="line">        System.out.println(medianFinder.findMedian());</span><br><span class="line">        medianFinder.addNum(<span class="number">4</span>);</span><br><span class="line">        System.out.println(medianFinder.findMedian());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj.addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj.findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="P480-MedianSlidingWindow-难度困难"><a href="#P480-MedianSlidingWindow-难度困难" class="headerlink" title="P480 MedianSlidingWindow(难度困难)"></a>P480 MedianSlidingWindow(难度困难)</h3><p>这道题不同的是如果只用最大堆和最小堆来实现的话，在删除节点的时候复杂度过高了，为了避免删除节点造成的时间复杂度提升，我们可以改用TreeMap二叉搜索树来实现，将删除节点的复杂度从n减少到了logn。我们套用构建最大树和最小树的模板，发现是极其相似的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">    left.add(i);</span><br><span class="line">    right.add(left.pollLast());</span><br><span class="line">    <span class="keyword">if</span> (left.size()&lt;right.size()) &#123;</span><br><span class="line">      left.add(right.pollFirst());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这边采用两个和采用一个TreeMap是一样的，只不过始终需要保持左子树和右子树的节点数量差左边大于右边不超过一个。参考一个更加通俗的本题的解题模板。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SlidingWindow.P480;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个版本更加通俗易懂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-01-02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingTreeSetClear</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] medianSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">double</span>[] result = <span class="keyword">new</span> <span class="keyword">double</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        TreeSet&lt;Integer&gt; left = getSet(nums);</span><br><span class="line">        TreeSet&lt;Integer&gt; right = getSet(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left.size() &lt;= right.size()) &#123;</span><br><span class="line">                right.add(i);</span><br><span class="line">                <span class="keyword">int</span> m = right.first();</span><br><span class="line">                right.remove(m);</span><br><span class="line">                left.add(m);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left.add(i);</span><br><span class="line">                <span class="keyword">int</span> m = left.last();</span><br><span class="line">                left.remove(m);</span><br><span class="line">                right.add(m);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left.size() + right.size() == k) &#123;</span><br><span class="line">                <span class="keyword">double</span> med;</span><br><span class="line">                <span class="keyword">if</span> (left.size() == right.size())</span><br><span class="line">                    med = ((<span class="keyword">double</span>) nums[left.last()] + nums[right.first()]) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (left.size() &lt; right.size())</span><br><span class="line">                    med = nums[right.first()];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    med = nums[left.last()];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> start = i - k + <span class="number">1</span>;</span><br><span class="line">                result[start] = med;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!left.remove(start))</span><br><span class="line">                    right.remove(start);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TreeSet&lt;Integer&gt; <span class="title">getSet</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a, Integer b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[a] == nums[b] ? a - b : nums[a] &lt; nums[b] ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>构造最大最小堆/树可以参考其中一个模板。模块的开头已经列出。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;寻找中位数我们通常可以从三个角度去思考，第一种方式利用双指针(前提是已经分别排序好)，第二种方式利用排序，第三种方式利用堆或者树。这里我们主要介绍利用堆或者树的解题模板。&lt;/p&gt;
&lt;h3 id=&quot;P295-MedianFinder-难度中等&quot;&gt;&lt;a href=&quot;#P295-
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>BFS(宽度优先搜索)算法通用总结</title>
    <link href="http://jianghao.wang/2019/leetCode%E7%AE%97%E6%B3%95/BFS%E7%AE%97%E6%B3%95%E9%80%9A%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://jianghao.wang/2019/leetCode算法/BFS算法通用总结/</id>
    <published>2019-11-28T07:07:09.849Z</published>
    <updated>2019-11-28T08:41:58.510Z</updated>
    
    <content type="html"><![CDATA[<p>宽度优先搜索在二叉树当中需要借助队列/栈等数据结构保存每一层的数据。有一个基本的模板可以参考，基本可以分为三个基本步骤：</p><ul><li>1.定义队列，这里可以是单向队列，双端队列或者栈。</li><li>2.开始循环直到队列为空。</li><li>3.从队列/栈中不断弹出元素进行处理。</li><li>4.继续往队列/栈中添加下一级的非空节点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.定义queue</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.开始循环</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> currentSize = queue.size();</span><br><span class="line">            <span class="comment">//将当前队列的最上层的元素加入result</span></span><br><span class="line">            result.add(((LinkedList&lt;TreeNode&gt;) queue).peekLast().val);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; currentSize; i++) &#123;</span><br><span class="line">                <span class="comment">//3.从队列中弹出一个元素</span></span><br><span class="line">                TreeNode treeNode = queue.poll();</span><br><span class="line"><span class="comment">//4.继续添加元素</span></span><br><span class="line">                <span class="keyword">if</span> (treeNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(treeNode.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (treeNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(treeNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;宽度优先搜索在二叉树当中需要借助队列/栈等数据结构保存每一层的数据。有一个基本的模板可以参考，基本可以分为三个基本步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.定义队列，这里可以是单向队列，双端队列或者栈。&lt;/li&gt;
&lt;li&gt;2.开始循环直到队列为空。&lt;/li&gt;
&lt;li&gt;3.从队列
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>DFS(广度优先搜索)算法通用总结</title>
    <link href="http://jianghao.wang/2019/leetCode%E7%AE%97%E6%B3%95/DFS%E7%AE%97%E6%B3%95%E9%80%9A%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://jianghao.wang/2019/leetCode算法/DFS算法通用总结/</id>
    <published>2019-11-28T03:26:43.708Z</published>
    <updated>2019-11-28T08:37:11.520Z</updated>
    
    <content type="html"><![CDATA[<p>DFS(广度优先搜索)主要区别于BFS(宽度优先搜索)存在。这里总结一下应用的一些经典题，总结一下模板。广度优先搜索是自顶向下的搜索算法，到达底部的条件在二叉树的情况下就是到达叶子节点。</p><h3 id="针对二叉树解题基本模板"><a href="#针对二叉树解题基本模板" class="headerlink" title="针对二叉树解题基本模板"></a>针对二叉树解题基本模板</h3><p>这套模板主要针对二叉树，其他的多重路径的条件下还是需要用backtracking，实际上DFS像是二维的backtracking和分治法的结合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root,<span class="keyword">int</span> temp)</span></span>&#123;</span><br><span class="line"><span class="comment">//计算当前节点的值</span></span><br><span class="line">        <span class="keyword">int</span> next=temp*<span class="number">10</span>+root.val;</span><br><span class="line">        <span class="comment">//只需要判断叶子节点即可</span></span><br><span class="line">        <span class="keyword">if</span> (root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//到达叶子节点</span></span><br><span class="line">            sum+=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//非叶子节点并且左子树不为空往下继续</span></span><br><span class="line">        <span class="keyword">if</span> (root.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            dfs(root.left,next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//非叶子节点并且右子树不为空往下继续</span></span><br><span class="line">        <span class="keyword">if</span> (root.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            dfs(root.right,next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="P988"><a href="#P988" class="headerlink" title="P988"></a>P988</h3><p>这道题通过DFS找出最小的字符串，基本就按照模板去套。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> DepthFirstSearch.P988;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> CommonUtils.TreeNodeUtils;</span><br><span class="line"><span class="keyword">import</span> P104.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-11-28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingStringBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String min=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">smallestFromLeaf</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root,<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root,String temp)</span></span>&#123;</span><br><span class="line">        String next=(<span class="keyword">char</span>)(root.val+<span class="string">'a'</span>)+temp;</span><br><span class="line">        <span class="keyword">if</span> (root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//进行比较并判断大小</span></span><br><span class="line">            <span class="keyword">if</span> (min==<span class="keyword">null</span>) &#123;</span><br><span class="line">                min=next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                min=next.compareTo(min)&lt;<span class="number">0</span>?next:min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            dfs(root.left,next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            dfs(root.right,next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode treeNode= TreeNodeUtils.stringToTreeNode(<span class="string">"[0,1,2,3,4,3,4]"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().smallestFromLeaf(treeNode));</span><br><span class="line"></span><br><span class="line">        TreeNode treeNode1= TreeNodeUtils.stringToTreeNode(<span class="string">"[25,1,3,1,3,0,2]"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().smallestFromLeaf(treeNode1));</span><br><span class="line"></span><br><span class="line">        TreeNode treeNode2= TreeNodeUtils.stringToTreeNode(<span class="string">"[25,1,null,0,0,1,null,null,null,0]"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> UsingStringBuilder().smallestFromLeaf(treeNode2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;DFS(广度优先搜索)主要区别于BFS(宽度优先搜索)存在。这里总结一下应用的一些经典题，总结一下模板。广度优先搜索是自顶向下的搜索算法，到达底部的条件在二叉树的情况下就是到达叶子节点。&lt;/p&gt;
&lt;h3 id=&quot;针对二叉树解题基本模板&quot;&gt;&lt;a href=&quot;#针对二叉树解题基
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Innodb如何排查锁</title>
    <link href="http://jianghao.wang/2019/mysql/Innodb%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E9%94%81/"/>
    <id>http://jianghao.wang/2019/mysql/Innodb如何排查锁/</id>
    <published>2019-11-18T09:17:35.266Z</published>
    <updated>2019-11-22T08:53:57.710Z</updated>
    
    <content type="html"><![CDATA[<p>今天在执行update语句时发现当前会话事务提交失败，事务获取锁超时，报错Lock wait timeout exceeded; try restarting transaction，初步判断有别的会话占领锁未释放，可能是别的会话获取到了锁一致未提交，大事务或者未进行commit。这里介绍几个表。本篇主要记录，参考文章<a href="https://cloud.tencent.com/developer/article/1356959。" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1356959。</a></p><h3 id="快速解决问题"><a href="#快速解决问题" class="headerlink" title="快速解决问题"></a>快速解决问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ID FROM information_schema.INNODB_TRX left join information_schema.processlist on trx_mysql_thread_id=ID ;</span><br></pre></td></tr></table></figure><ul><li>select * from information_schema.INNODB_TRX查询到所有的当前在执行的事务信息，拿到事务执行很长的线程ID。</li><li>select * from information_schema.processlist查询到所有当前的执行线程的状态,如果上面拿到的线程处于sleep状态，直接杀掉。</li><li>kill ID,执行杀死线程的行为。</li></ul><p>### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在执行update语句时发现当前会话事务提交失败，事务获取锁超时，报错Lock wait timeout exceeded; try restarting transaction，初步判断有别的会话占领锁未释放，可能是别的会话获取到了锁一致未提交，大事务或者未进行com
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://jianghao.wang/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Backtracking算法通用总结</title>
    <link href="http://jianghao.wang/2019/leetCode%E7%AE%97%E6%B3%95/Backtracking%E7%AE%97%E6%B3%95%E9%80%9A%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://jianghao.wang/2019/leetCode算法/Backtracking算法通用总结/</id>
    <published>2019-11-06T02:05:54.525Z</published>
    <updated>2019-11-07T08:51:50.311Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要针对Backtracking类型的算法进行总结归纳解题模板。</p><h3 id="P22-Generate-Parentheses"><a href="#P22-Generate-Parentheses" class="headerlink" title="P22. Generate Parentheses"></a>P22. Generate Parentheses</h3><h4 id="问题描述（难度中等）"><a href="#问题描述（难度中等）" class="headerlink" title="问题描述（难度中等）"></a>问题描述（难度中等）</h4><p>Given <em>n</em> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><p>For example, given <em>n</em> = 3, a solution set is:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="BackTracking代码"><a href="#BackTracking代码" class="headerlink" title="BackTracking代码"></a>BackTracking代码</h4><p>思路过程是，我们有n个左括号，n个右括号，第一次只能放一个左括号，第二次可以选择放一个右括号或者左括号。以此类推，当n&gt;0时都可以放左括号，当m&gt;n时都可以放右括号，最后递归的结束条件是m和n都减到零。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P22;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 时间复杂度O(N^2)</span></span><br><span class="line"><span class="comment"> * 空间复杂度O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        generateParenthesisMnes(<span class="string">""</span>,n,n);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateParenthesisMnes</span><span class="params">(String str,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span> &amp;&amp; m==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.result.add(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            generateParenthesisMnes(str+<span class="string">'('</span>,n-<span class="number">1</span>,m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m&gt;n) &#123;</span><br><span class="line">            generateParenthesisMnes(str+<span class="string">')'</span>,n,m-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Solution().generateParenthesis(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P78-Subsets"><a href="#P78-Subsets" class="headerlink" title="P78. Subsets"></a>P78. Subsets</h3><h4 id="问题描述（难度中等）-1"><a href="#问题描述（难度中等）-1" class="headerlink" title="问题描述（难度中等）"></a>问题描述（难度中等）</h4><p>Given a set of <strong>distinct</strong> integers, <em>nums</em>, return all possible subsets (the power set).</p><p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="Backtracking解题代码"><a href="#Backtracking解题代码" class="headerlink" title="Backtracking解题代码"></a>Backtracking解题代码</h4><p>回溯法可以通过模拟树，遍历各种情况，本题可以得到下面的图，当然前提是将nums数组进行排序：</p><p><img src="http://arthornye.github.io/images/backtracking.jpg" alt="cmd-markdown-logo"></p><p>得到代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P78;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Backtracking</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nums=nums;</span><br><span class="line">        <span class="comment">//这里排序，可以省去去重这一步</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        subSetsFind(<span class="keyword">new</span> ArrayList&lt;&gt;(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subSetsFind</span><span class="params">(List&lt;Integer&gt; tempList,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//增加当前元素到临时数组中</span></span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            <span class="comment">//继续往下回溯</span></span><br><span class="line">            subSetsFind(tempList,i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//将增加的元素取消掉，因为要继续回溯别的情况</span></span><br><span class="line">            tempList.remove(tempList.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> Solution().subsets(ints);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P90-Subsets-II"><a href="#P90-Subsets-II" class="headerlink" title="P90. Subsets II"></a>P90. Subsets II</h3><h4 id="问题描述（难度中等）-2"><a href="#问题描述（难度中等）-2" class="headerlink" title="问题描述（难度中等）"></a>问题描述（难度中等）</h4><p>Given a collection of integers that might contain duplicates, <strong>nums</strong>, return all possible subsets (the power set).</p><p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,2]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="Backtracking回溯代码"><a href="#Backtracking回溯代码" class="headerlink" title="Backtracking回溯代码"></a>Backtracking回溯代码</h4><p>比较第一题，主要是会出现重复的数字，重复数字出现的只需要跳过，不需要继续回溯。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P90;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nums=nums;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        subsetsWithDupBacking(<span class="keyword">new</span> ArrayList&lt;&gt;(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回溯函数参数如何确定 1.返回的数据类型 2.子结构</span></span><br><span class="line">    <span class="comment">//这里需要返回列表，同时每次子递归都需要有nums.length-start次的递归次数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subsetsWithDupBacking</span><span class="params">(List&lt;Integer&gt; tempList,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            subsetsWithDupBacking(tempList,i+<span class="number">1</span>);</span><br><span class="line">            tempList.remove(tempList.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> Solution().subsetsWithDup(ints);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P46-Permutations"><a href="#P46-Permutations" class="headerlink" title="P46. Permutations"></a>P46. Permutations</h3><h4 id="问题描述（难度中等）-3"><a href="#问题描述（难度中等）-3" class="headerlink" title="问题描述（难度中等）"></a>问题描述（难度中等）</h4><p>Given a collection of <strong>distinct</strong> integers, return all possible permutations.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="BackTracking解题代码"><a href="#BackTracking解题代码" class="headerlink" title="BackTracking解题代码"></a>BackTracking解题代码</h4><p>本题break的条件有所不同，本题需要在遍历到根节点之后才记录当前数组是有效的，另外在每次的回溯过程中需要过滤已经回溯过的字段，一开始想到用Set去存储，进行重复的判断。实际上用只需要判断前缀数组是否包含即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P46;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-11-07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soulution2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// Arrays.sort(nums); // not necessary</span></span><br><span class="line">        backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tempList.size() == nums.length)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tempList.contains(nums[i])) <span class="keyword">continue</span>; <span class="comment">// element already exists, skip</span></span><br><span class="line">                tempList.add(nums[i]);</span><br><span class="line">                backtrack(list, tempList, nums);</span><br><span class="line">                tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要针对Backtracking类型的算法进行总结归纳解题模板。&lt;/p&gt;
&lt;h3 id=&quot;P22-Generate-Parentheses&quot;&gt;&lt;a href=&quot;#P22-Generate-Parentheses&quot; class=&quot;headerlink&quot; title=&quot;P2
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Sliding Window算法通用总结</title>
    <link href="http://jianghao.wang/2019/leetCode%E7%AE%97%E6%B3%95/Sliding%20Window%E7%AE%97%E6%B3%95%E9%80%9A%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://jianghao.wang/2019/leetCode算法/Sliding Window算法通用总结/</id>
    <published>2019-11-01T09:23:05.368Z</published>
    <updated>2019-11-05T01:40:36.279Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要针对Sliding Window类型的算法进行总结归纳解题模板，适用于大部分解决字符串子问题的算法。这里将列举一下比较有代表性的，在每个解题的代码中都标注了一些具体的模版规则。</p><h3 id="Sliding-Window-Template（解题模板）"><a href="#Sliding-Window-Template（解题模板）" class="headerlink" title="Sliding Window Template（解题模板）"></a>Sliding Window Template（解题模板）</h3><p>Sliding Window问题模板代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">slidingWindowTemplate</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化返回的结果集</span></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(t.length()&gt; s.length()) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过hashmap存储目标子串的所有字符</span></span><br><span class="line">        <span class="comment">//(K, V) = (Character, 字符出现的次数/频率)</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : t.toCharArray())&#123;</span><br><span class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//维护一个标志位，标记当前窗口(begin,end)是否包含hashmap中目标子串</span></span><br><span class="line">        <span class="keyword">int</span> counter = map.size();<span class="comment">//一定要是map的长度，因为可能会有重复字符</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//双指针，一个开头一个结尾</span></span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//辅助判断条件.</span></span><br><span class="line">        <span class="keyword">int</span> len = Integer.MAX_VALUE; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//开始循环sliding window 移动end右窗口的位置</span></span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.length())&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(end);<span class="comment">//获取一个字符</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>( map.containsKey(c) )&#123;</span><br><span class="line">                map.put(c, map.get(c)-<span class="number">1</span>);<span class="comment">//减少key对应value的值</span></span><br><span class="line">                <span class="keyword">if</span>(map.get(c) == <span class="number">0</span>) counter--;<span class="comment">//如果hashmap中的key的value全部消耗完，减少counter</span></span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//当counter标志位符合要求的时候 移动begin左窗口的位置</span></span><br><span class="line">            <span class="keyword">while</span>(counter == <span class="number">0</span> <span class="comment">/* counter condition. different question may have different condition */</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">char</span> tempc = s.charAt(begin);<span class="comment">//选择左窗口begin当前位置的字符</span></span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(tempc))&#123;</span><br><span class="line">                    map.put(tempc, map.get(tempc) + <span class="number">1</span>);<span class="comment">//如果当前的begin所在的字符在map中存在，更新对应key位置value+1</span></span><br><span class="line">                    <span class="keyword">if</span>(map.get(tempc) &gt; <span class="number">0</span>) counter++;<span class="comment">//如果当前map中的key对应value大于0，counter标志位增加，跳出循环，让end继续往后滑</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//判断当前的窗口是否满足其他条件，不同的问题主要是这里不同</span></span><br><span class="line">                <span class="comment">//如果是最小子串，那么判断当前的窗口是否更小 存下更小的</span></span><br><span class="line">                <span class="comment">//如果是包含子串的列表 那么保存每个窗口</span></span><br><span class="line">           </span><br><span class="line">                begin++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P438-Find-All-Anagrams-in-a-String"><a href="#P438-Find-All-Anagrams-in-a-String" class="headerlink" title="P438. Find All Anagrams in a String"></a><strong>P438. Find All Anagrams in a String</strong></h3><h4 id="问题描述（难度中等）"><a href="#问题描述（难度中等）" class="headerlink" title="问题描述（难度中等）"></a>问题描述（难度中等）</h4><p>Given a string <strong>s</strong> and a <strong>non-empty</strong> string <strong>p</strong>, find all the start indices of <strong>p</strong>‘s anagrams in <strong>s</strong>.</p><p>Strings consists of lowercase English letters only and the length of both strings <strong>s</strong> and <strong>p</strong> will not be larger than 20,100.</p><p>The order of output does not matter.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s: &quot;cbaebabacd&quot; p: &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[0, 6]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The substring with start index = 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.</span><br><span class="line">The substring with start index = 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s: &quot;abab&quot; p: &quot;ab&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[0, 1, 2]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The substring with start index = 0 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.</span><br><span class="line">The substring with start index = 1 is &quot;ba&quot;, which is an anagram of &quot;ab&quot;.</span><br><span class="line">The substring with start index = 2 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.</span><br></pre></td></tr></table></figure><h4 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h4><p>利用Sliding Window算法。代码如下，备注部分思路模板。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P438;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * using slide window</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end=<span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//构造子串的map</span></span><br><span class="line">        Map&lt;Character,Integer&gt; pMap=<span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">128</span>,<span class="number">0.75f</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); i++) &#123;</span><br><span class="line">            pMap.put(p.charAt(i),pMap.getOrDefault(p.charAt(i),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count=pMap.size();</span><br><span class="line">        <span class="keyword">while</span> (end&lt;s.length())&#123;</span><br><span class="line">            Character currentChar=s.charAt(end);</span><br><span class="line">            <span class="comment">//如果当前key在pMap中</span></span><br><span class="line">            <span class="keyword">if</span> (pMap.containsKey(currentChar)) &#123;</span><br><span class="line">                <span class="comment">//pMap值-1</span></span><br><span class="line">                pMap.put(currentChar,pMap.get(currentChar)-<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//当前key全部减完 count更新</span></span><br><span class="line">                <span class="keyword">if</span> (pMap.get(currentChar)==<span class="number">0</span>) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">            <span class="comment">//如果count目标减为0 从begin开始加回去</span></span><br><span class="line">            <span class="keyword">while</span> (count==<span class="number">0</span>) &#123;</span><br><span class="line">                Character c=s.charAt(begin);</span><br><span class="line">                <span class="keyword">if</span> (pMap.containsKey(c)) &#123;</span><br><span class="line">                    pMap.put(c,pMap.get(c)+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (pMap.get(c)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//记录当前的begin的位置之后继续遍历</span></span><br><span class="line">                <span class="comment">//这里可以判断下当前是否满足条件</span></span><br><span class="line">                <span class="keyword">if</span> ((end-begin)==p.length()) &#123;</span><br><span class="line">                    result.add(begin);</span><br><span class="line">                &#125;</span><br><span class="line">                begin++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Solution().findAnagrams(<span class="string">"cbaebabacd"</span>,<span class="string">"abc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P76-Minimum-Window-Substring"><a href="#P76-Minimum-Window-Substring" class="headerlink" title="P76. Minimum Window Substring"></a>P76. Minimum Window Substring</h3><p>####问题描述（难度偏难）</p><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;</span><br><span class="line">Output: &quot;BANC&quot;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>If there is no such window in S that covers all characters in T, return the empty string <code>&quot;&quot;</code>.</li><li>If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</li></ul><h4 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P76;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sliding window</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义sliding begin位置 end位置 结束标记counter计数器</span></span><br><span class="line">        <span class="keyword">int</span> begin=<span class="number">0</span>,end=<span class="number">0</span>,counter;</span><br><span class="line">        Integer len=s.length();</span><br><span class="line">        String target=<span class="string">""</span>;</span><br><span class="line">        Map&lt;Character,Integer&gt; tMap=<span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">129</span>,<span class="number">0.75f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            tMap.put(t.charAt(i),tMap.getOrDefault(t.charAt(i),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        counter=tMap.size();</span><br><span class="line">        <span class="comment">//开始主循环</span></span><br><span class="line">        <span class="keyword">while</span> (end&lt;s.length())&#123;</span><br><span class="line">            <span class="comment">//判断当前的end位置是否在tmap中存在</span></span><br><span class="line">            <span class="keyword">if</span> (tMap.containsKey(s.charAt(end))) &#123;</span><br><span class="line">                <span class="comment">//如果存在的话就从tmap中踢掉一个</span></span><br><span class="line">                tMap.put(s.charAt(end),tMap.get(s.charAt(end))-<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//如果当前位置减掉之后变成零了 就更新counter计数器</span></span><br><span class="line">                <span class="keyword">if</span> (tMap.get(s.charAt(end))==<span class="number">0</span>) &#123;</span><br><span class="line">                    counter--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//继续执行遍历哟</span></span><br><span class="line">            end++;</span><br><span class="line">            <span class="comment">//每次都可以判断下counter是否等于零 等于0的话说明当前的begin和end位置是符合条件的（t中所有元素在当前窗口都存在）</span></span><br><span class="line">            <span class="comment">//确定到这个窗口之后，需要将begin往前推，也就是窗口继续向前滑动</span></span><br><span class="line">            <span class="keyword">while</span> (counter==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (tMap.containsKey(s.charAt(begin))) &#123;</span><br><span class="line">                    tMap.put(s.charAt(begin),tMap.get(s.charAt(begin))+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (tMap.get(s.charAt(begin))&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                        counter++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断下当前的窗口是否满足条件，这里的话只需要满足完全存在的条件也就是如果当前窗口定位到的是abcde 但是目标窗口是abe也可以返回</span></span><br><span class="line">                <span class="keyword">if</span> (end-begin&lt;=len) &#123;</span><br><span class="line">                    len=end-begin;</span><br><span class="line">                    target=s.substring(begin,end);</span><br><span class="line">                &#125;</span><br><span class="line">                begin++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Solution().minWindow(<span class="string">"ADOBECODEBANC"</span>,<span class="string">"ABC"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P30-Substring-with-Concatenation-of-All-Words"><a href="#P30-Substring-with-Concatenation-of-All-Words" class="headerlink" title="P30. Substring with Concatenation of All Words"></a>P30. Substring with Concatenation of All Words</h3><h4 id="问题描述（难度偏难）"><a href="#问题描述（难度偏难）" class="headerlink" title="问题描述（难度偏难）"></a>问题描述（难度偏难）</h4><p>You are given a string, <strong>s</strong>, and a list of words, <strong>words</strong>, that are all of the same length. Find all starting indices of substring(s) in <strong>s</strong> that is a concatenation of each word in <strong>words</strong> exactly once and without any intervening characters.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">  s = &quot;barfoothefoobarman&quot;,</span><br><span class="line">  words = [&quot;foo&quot;,&quot;bar&quot;]</span><br><span class="line">Output: [0,9]</span><br><span class="line">Explanation: Substrings starting at index 0 and 9 are &quot;barfoo&quot; and &quot;foobar&quot; respectively.</span><br><span class="line">The output order does not matter, returning [9,0] is fine too.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">  s = &quot;wordgoodgoodgoodbestword&quot;,</span><br><span class="line">  words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><h4 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h4><p>这道题关键点是words的数组中单词的长度是一致的，实际上演变为sliding window的变型，时间复杂度依旧是O(N)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P30;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sliding window template</span></span><br><span class="line"><span class="comment"> * 时间复杂度O(N)</span></span><br><span class="line"><span class="comment"> * 空间复杂度O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义存结果的list</span></span><br><span class="line">        List&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s==<span class="keyword">null</span> || s.length()==<span class="number">0</span> || words==<span class="keyword">null</span> || words.length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义位置 起点 终点 每次跳动的距离 定义一个counter标志</span></span><br><span class="line">        <span class="keyword">int</span> begin=<span class="number">0</span>,end=<span class="number">0</span>,step=words[<span class="number">0</span>].length(),counter;</span><br><span class="line">        <span class="comment">//将word的列表存到map中</span></span><br><span class="line">        Map&lt;String,Integer&gt; wordsMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            wordsMap.put(word,wordsMap.getOrDefault(word,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置counter默认值</span></span><br><span class="line">        counter=wordsMap.size();</span><br><span class="line">        <span class="comment">//sliding template 循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; step; i++) &#123;</span><br><span class="line">            begin=i;end=i;</span><br><span class="line">            <span class="keyword">while</span> (end+step&lt;=s.length())&#123;</span><br><span class="line">                String curString=s.substring(end,end+step);</span><br><span class="line">                <span class="keyword">if</span> (wordsMap.containsKey(curString)) &#123;</span><br><span class="line">                    wordsMap.put(curString,wordsMap.get(curString)-<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (wordsMap.get(curString)==<span class="number">0</span>) &#123;</span><br><span class="line">                        counter--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                end+=step;</span><br><span class="line">                <span class="keyword">while</span> (counter==<span class="number">0</span>)&#123;</span><br><span class="line">                    String beginS=s.substring(begin,begin+step);</span><br><span class="line">                    <span class="keyword">if</span> (wordsMap.containsKey(beginS)) &#123;</span><br><span class="line">                        wordsMap.put(beginS,wordsMap.get(beginS)+<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">if</span> (wordsMap.get(beginS)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                            counter++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//满足条件的存下来</span></span><br><span class="line">                    <span class="keyword">if</span> (end-begin==step*words.length) &#123;</span><br><span class="line">                        result.add(begin);</span><br><span class="line">                    &#125;</span><br><span class="line">                    begin+=step;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            wordsMap.clear();</span><br><span class="line">            <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">                wordsMap.put(word,wordsMap.getOrDefault(word,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            counter=wordsMap.size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] words=&#123;<span class="string">"ab"</span>,<span class="string">"ba"</span>,<span class="string">"ba"</span>&#125;;</span><br><span class="line">        String s=<span class="string">"ababaab"</span>;</span><br><span class="line">        <span class="keyword">new</span> Solution().findSubstring(s,words);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P567-Permutation-in-String"><a href="#P567-Permutation-in-String" class="headerlink" title="P567. Permutation in String"></a>P567. Permutation in String</h3><p>####问题描述（难度中等）</p><p>Given two strings <strong>s1</strong> and <strong>s2</strong>, write a function to return true if <strong>s2</strong> contains the permutation of <strong>s1</strong>. In other words, one of the first string’s permutations is the <strong>substring</strong> of the second string.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</span><br><span class="line">Output: True</span><br><span class="line">Explanation: s2 contains one permutation of s1 (&quot;ba&quot;).</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The input strings only contain lower case letters.</li><li>The length of both given strings is in range [1, 10,000].</li></ol><h4 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P567;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sliding window</span></span><br><span class="line"><span class="comment"> * begin和end中间的部分为窗口 注意不包括begin和end</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义前后窗口</span></span><br><span class="line">        <span class="keyword">int</span> begin=<span class="number">0</span>,end=<span class="number">0</span>,counter;</span><br><span class="line">        <span class="keyword">if</span> (s1==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s2==<span class="keyword">null</span> || s1.length()&gt;s2.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将s1字符存到map</span></span><br><span class="line">        Map&lt;Character,Integer&gt; sMap=<span class="keyword">new</span> HashMap&lt;&gt;(s1.length()*<span class="number">2</span>,<span class="number">0.75f</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> charC=s1.charAt(i);</span><br><span class="line">            sMap.put(charC,sMap.getOrDefault(charC,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        counter=sMap.size();</span><br><span class="line">        <span class="comment">//开始循环</span></span><br><span class="line">        <span class="keyword">while</span> (end&lt;s2.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> endChar=s2.charAt(end);</span><br><span class="line">            <span class="keyword">if</span> (sMap.containsKey(endChar)) &#123;</span><br><span class="line">                sMap.put(endChar,sMap.get(endChar)-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (sMap.get(s2.charAt(end))==<span class="number">0</span>) &#123;</span><br><span class="line">                    counter--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">            <span class="keyword">while</span> (counter==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">char</span> beginChar=s2.charAt(begin);</span><br><span class="line">                <span class="keyword">if</span> (sMap.containsKey(beginChar)) &#123;</span><br><span class="line">                    sMap.put(beginChar,sMap.get(beginChar)+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (sMap.get(beginChar)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                        counter++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断满足条件返回</span></span><br><span class="line">                <span class="keyword">if</span> ((end-begin)==s1.length()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                begin++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().checkInclusion(<span class="string">"ab"</span>,<span class="string">"eidbaooo"</span>));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().checkInclusion(<span class="string">"ab"</span>,<span class="string">"eeidboaoo"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P424-Longest-Repeating-Character-Replacement"><a href="#P424-Longest-Repeating-Character-Replacement" class="headerlink" title="P424. Longest Repeating Character Replacement"></a>P424. Longest Repeating Character Replacement</h3><p>####问题描述（难度中等）</p><p>Given a string <code>s</code> that consists of only uppercase English letters, you can perform at most <code>k</code> operations on that string.</p><p>In one operation, you can choose <strong>any</strong> character of the string and change it to any other uppercase English character.</p><p>Find the length of the longest sub-string containing all repeating letters you can get after performing the above operations.</p><p><strong>Note:</strong><br>Both the string’s length and <em>k</em> will not exceed 104.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;ABAB&quot;, k = 2</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Replace the two &apos;A&apos;s with two &apos;B&apos;s or vice versa.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;AABABBA&quot;, k = 1</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Replace the one &apos;A&apos; in the middle with &apos;B&apos; and form &quot;AABBBBA&quot;.</span><br><span class="line">The substring &quot;BBBB&quot; has the longest repeating letters, which is 4.</span><br></pre></td></tr></table></figure><h4 id="解题代码-4"><a href="#解题代码-4" class="headerlink" title="解题代码"></a>解题代码</h4><h5 id="方法一：HashMap-N-2"><a href="#方法一：HashMap-N-2" class="headerlink" title="方法一：HashMap(N^2)"></a>方法一：HashMap(N^2)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P424;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characterReplacement</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义滑动窗口左窗口和右窗口</span></span><br><span class="line">        <span class="keyword">int</span> begin=<span class="number">0</span>,end=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义一个hashmap用于存储滑动窗口中的key value统计值</span></span><br><span class="line">        Map&lt;Character,Integer&gt; countMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//定义返回的最大值</span></span><br><span class="line">        <span class="keyword">int</span> maxResult=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//开始循环右窗口</span></span><br><span class="line">        <span class="keyword">while</span> (end&lt;s.length())&#123;</span><br><span class="line">            countMap.put(s.charAt(end),countMap.getOrDefault(s.charAt(end),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            end++;</span><br><span class="line">            <span class="comment">//如果当前的窗口已经超出了满足条件的返回 也就是maxCount+k&gt;end-begin</span></span><br><span class="line">            <span class="keyword">while</span> ((end-begin)-getMax(countMap)&gt;k)&#123;</span><br><span class="line">                <span class="keyword">char</span> begingChar=s.charAt(begin);</span><br><span class="line">                countMap.put(begingChar,countMap.get(begingChar)-<span class="number">1</span>);</span><br><span class="line">                begin++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxResult=end-begin&gt;maxResult?end-begin:maxResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxResult;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(Map&lt;Character,Integer&gt; map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line">            max=value&gt;max?value:max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Solution().characterReplacement(<span class="string">"AABABBA"</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法二：一遍遍历-N"><a href="#方法二：一遍遍历-N" class="headerlink" title="方法二：一遍遍历(N)"></a>方法二：一遍遍历(N)</h5><p>方法一中我们每次都要找到当前窗口出现频率最多的key，以此来判断当前窗口是否满足条件，实际上我们不需要每次都去找到当前窗口出现频率最多的key，而只需要记录当前end索引对应的字符加入后最大频率的字母是否改变，改变了就重置最大频率。这样即使我们当前窗口最大频率不是最准确的，但是窗口永远不会大于<strong>最大频率+k</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characterReplacement</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, maxCount = <span class="number">0</span>, maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = <span class="number">0</span>; end &lt; len; end++) &#123;</span><br><span class="line">            maxCount = Math.max(maxCount, ++count[s.charAt(end) - <span class="string">'A'</span>]);</span><br><span class="line">            <span class="keyword">while</span> (end - start + <span class="number">1</span> - maxCount &gt; k) &#123;</span><br><span class="line">                count[s.charAt(start) - <span class="string">'A'</span>]--;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLength = Math.max(maxLength, end - start + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>主要总结下Sliding Window的模板。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要针对Sliding Window类型的算法进行总结归纳解题模板，适用于大部分解决字符串子问题的算法。这里将列举一下比较有代表性的，在每个解题的代码中都标注了一些具体的模版规则。&lt;/p&gt;
&lt;h3 id=&quot;Sliding-Window-Template（解题模板）&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://jianghao.wang/2019/%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/HashMap%E7%9A%84ConcurrentModificationException/"/>
    <id>http://jianghao.wang/2019/并发学习/HashMap的ConcurrentModificationException/</id>
    <published>2019-10-31T06:32:39.485Z</published>
    <updated>2019-10-31T14:01:59.558Z</updated>
    
    <content type="html"><![CDATA[<p>记录下在工作中发生的一个异常，深入源码分析观察原因，以及在之后写代码的过程中如何避免。具体的报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.util.ConcurrentModificationException</span><br><span class="line">at java.util.HashMap$HashIterator.nextNode(HashMap.java:1429)</span><br><span class="line">at java.util.HashMap$EntryIterator.next(HashMap.java:1463)</span><br><span class="line">at java.util.HashMap$EntryIterator.next(HashMap.java:1461)</span><br><span class="line">at com.souche.JsonTest.HashMapTest.main(HashMapTest.java:16)</span><br></pre></td></tr></table></figure><h3 id="ConcurrentModificationException产生原因"><a href="#ConcurrentModificationException产生原因" class="headerlink" title="ConcurrentModificationException产生原因"></a>ConcurrentModificationException产生原因</h3><p>定位到最主要的一段代码，报错是在HashIterator中暴出来的。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt;[] t;</span><br><span class="line">            Node&lt;K,V&gt; e = next;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>其中modCount是HashMap中实际存在的元素节点数量，而expectedModCount是复制出来的迭代器中的节点数量。来看下我们产生报错的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.JsonTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-10-30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JSONObject jsonObject=<span class="keyword">new</span> JSONObject();</span><br><span class="line">        jsonObject.put(<span class="string">"receiver.mobile"</span>,<span class="string">"test"</span>);</span><br><span class="line">        jsonObject.put(<span class="string">"test"</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : jsonObject.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getKey().contains(<span class="string">"."</span>)) &#123;</span><br><span class="line">                String[] strings=entry.getKey().split(<span class="string">"\\."</span>);</span><br><span class="line">                String key=strings[<span class="number">0</span>];</span><br><span class="line">                Object value=entry.getValue();</span><br><span class="line">                <span class="keyword">if</span> (jsonObject.containsKey(key)) &#123;</span><br><span class="line">                    JSONObject getJSON=(JSONObject) jsonObject.get(key);</span><br><span class="line">                    getJSON.put(key,value);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    JSONObject newJSON=<span class="keyword">new</span> JSONObject();</span><br><span class="line">                    String newKey=strings[<span class="number">1</span>];</span><br><span class="line">                    newJSON.put(newKey,value);</span><br><span class="line">                    jsonObject.put(key,newJSON);</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//最关键的一步</span></span><br><span class="line">            jsonObject.remove(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<strong><em>jsonObject.remove()函数我们减少了modCount的值，但是expectedModCount的值没有变。那么迭代器在继续进行下一个元素迭代的时候会报错。</em></strong>值得注意的是，如果先通过<strong><em>jsonObject.put()新增一个元素，然后又通过jsonObject.remove移除一个元素，是不会报这个错的，因为这里判断仍然相等，但是实际上是被修改了的。</em></strong>我们可以看一下上面描诉的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.souche.JsonTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-10-30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JSONObject jsonObject=<span class="keyword">new</span> JSONObject();</span><br><span class="line">        jsonObject.put(<span class="string">"receiver.mobile"</span>,<span class="string">"test"</span>);</span><br><span class="line">        jsonObject.put(<span class="string">"test"</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : jsonObject.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getKey().contains(<span class="string">"."</span>)) &#123;</span><br><span class="line">                String[] strings=entry.getKey().split(<span class="string">"\\."</span>);</span><br><span class="line">                String key=strings[<span class="number">0</span>];</span><br><span class="line">                Object value=entry.getValue();</span><br><span class="line">                <span class="keyword">if</span> (jsonObject.containsKey(key)) &#123;</span><br><span class="line">                    JSONObject getJSON=(JSONObject) jsonObject.get(key);</span><br><span class="line">                    getJSON.put(key,value);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    JSONObject newJSON=<span class="keyword">new</span> JSONObject();</span><br><span class="line">                    String newKey=strings[<span class="number">1</span>];</span><br><span class="line">                    newJSON.put(newKey,value);</span><br><span class="line">                    jsonObject.put(key,newJSON);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将这步移到这里就不会报错</span></span><br><span class="line">                jsonObject.remove(entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正确遍历HashMap（Iterator-ConcurrentHashMap）"><a href="#正确遍历HashMap（Iterator-ConcurrentHashMap）" class="headerlink" title="正确遍历HashMap（Iterator/ConcurrentHashMap）"></a>正确遍历HashMap（Iterator/ConcurrentHashMap）</h3><p>正常情况下我们获取到迭代器之后，需要通过迭代器去操作，防止发生上面我们介绍的异常。上面的代码改成迭代器的版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">usingIterator</span><span class="params">(JSONObject json)</span></span>&#123;</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String,Object&gt;&gt; iterator=json.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">      Map.Entry&lt;String,Object&gt; entry=iterator.next();</span><br><span class="line">      System.out.println(<span class="string">"key:"</span>+entry.getKey()+<span class="string">" "</span>+<span class="string">"value:"</span>+entry.getValue());</span><br><span class="line">      iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过迭代器去删除的时候进行expectedModCount–同时会执行modCount–操作，不会报错。当然如果我们使用ConcurrentHashMap也可以避免这个异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">usingConcurrentHashMap</span><span class="params">(JSONObject jsonObject)</span></span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; conMap=<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">//这里需要注意ConcurrentHashMap value不允许为空值，空值会报空指针的错误</span></span><br><span class="line">    conMap.putAll(jsonObject);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : conMap.entrySet()) &#123;</span><br><span class="line">      conMap.put(<span class="string">"key:"</span>+entry.getKey(),<span class="string">"value:"</span>+entry.getValue());</span><br><span class="line">      System.out.println(<span class="string">"key:"</span>+entry.getKey()+<span class="string">" value:"</span>+entry.getValue());</span><br><span class="line">      conMap.remove(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过ConcurrentHashMap不会发生ConcurrentModificationException异常。注意ConcurrentHashMap的value不允许为空值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录下在工作中发生的一个异常，深入源码分析观察原因，以及在之后写代码的过程中如何避免。具体的报错如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;l
      
    
    </summary>
    
    
      <category term="源码学习" scheme="http://jianghao.wang/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Subarray Sum Equals K</title>
    <link href="http://jianghao.wang/2019/leetCode%E7%AE%97%E6%B3%95/P560%20Subarray%20Sum%20Equals%20K/"/>
    <id>http://jianghao.wang/2019/leetCode算法/P560 Subarray Sum Equals K/</id>
    <published>2019-10-31T06:09:54.919Z</published>
    <updated>2019-10-31T14:13:06.243Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度中等）"><a href="#问题描述（难度中等）" class="headerlink" title="问题描述（难度中等）"></a>问题描述（难度中等）</h3><p>Given an array of integers and an integer <strong>k</strong>, you need to find the total number of continuous subarrays whose sum equals to <strong>k</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:nums = [1,1,1], k = 2</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The length of the array is in range [1, 20,000].</li><li>The range of numbers in the array is [-1000, 1000] and the range of the integer <strong>k</strong> is [-1e7, 1e7].</li></ol><h3 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><p>可以拆解为多个子问题。<strong>通过递归的方式求解，时间复杂度O(N^2)，空间复杂度O(1)</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P560;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nums=nums;</span><br><span class="line">        <span class="keyword">return</span> maxArraySum(nums.length-<span class="number">1</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArraySum</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]==k?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArraySum(i-<span class="number">1</span>,k)+tempArraySum(i-<span class="number">1</span>,k-nums[i])+(nums[i]==k?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tempArraySum</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]==k?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tempArraySum(i-<span class="number">1</span>,k-nums[i])+(nums[i]==k?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> Solution().subarraySum(nums,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：HashMap"><a href="#方法二：HashMap" class="headerlink" title="方法二：HashMap"></a>方法二：HashMap</h3><p>通过map存储和出现的次数，key为[0,j]元素的和，value为和出现的次数。假设[i,j]为和为k的数组，那么sum(0,j)-k=sum(0,i)。<strong>时间复杂度O(N),空间复杂度O(N)</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P560;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用map记录 key为[0,j]的和 value为和出现的次数</span></span><br><span class="line"><span class="comment"> * [i,j]为和为k的位置 那么sum(0,j)-k=sum(0,i)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-10-30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingMap</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; counts=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        counts.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            sum+=nums[j];</span><br><span class="line">            <span class="comment">//如果存在sum-k的值</span></span><br><span class="line">            <span class="keyword">if</span> (counts.containsKey(sum-k)) &#123;</span><br><span class="line">                count+=counts.getOrDefault(sum-k,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            counts.put(sum,counts.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> UsingMap().subarraySum(nums,<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过Map可以以空间换取时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度中等）&quot;&gt;&lt;a href=&quot;#问题描述（难度中等）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度中等）&quot;&gt;&lt;/a&gt;问题描述（难度中等）&lt;/h3&gt;&lt;p&gt;Given an array of integers and an inte
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Diameter of Binary Tree</title>
    <link href="http://jianghao.wang/2019/leetCode%E7%AE%97%E6%B3%95/P543%20Diameter%20of%20Binary%20Tree/"/>
    <id>http://jianghao.wang/2019/leetCode算法/P543 Diameter of Binary Tree/</id>
    <published>2019-10-29T13:43:15.046Z</published>
    <updated>2019-10-29T13:50:44.352Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度简单）"><a href="#问题描述（难度简单）" class="headerlink" title="问题描述（难度简单）"></a>问题描述（难度简单）</h3><p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the <strong>longest</strong> path between any two nodes in a tree. This path may or may not pass through the root.</p><p><strong>Example:</strong><br>Given a binary tree</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \     </span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p>Return <strong>3</strong>, which is the length of the path [4,2,1,3] or [5,2,1,3].</p><p><strong>Note:</strong> The length of path between two nodes is represented by the number of edges between them.</p><h3 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h3><p>分解为子问题，当前root节点左子树最大深度为left,右边子树最大深度为right,那么root的最大深度为Math.max(left,right)+1。当前root为根节点的最大树连接长度为left+right+2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P543;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> P104.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        diameterOfBinaryTreeDigui(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTreeDigui</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=diameterOfBinaryTreeDigui(root.left);</span><br><span class="line">        <span class="keyword">int</span> right=diameterOfBinaryTreeDigui(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result=left+right+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (result&gt;max) &#123;</span><br><span class="line">            max=result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left&gt;right?left+<span class="number">1</span>:right+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度简单）&quot;&gt;&lt;a href=&quot;#问题描述（难度简单）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度简单）&quot;&gt;&lt;/a&gt;问题描述（难度简单）&lt;/h3&gt;&lt;p&gt;Given a binary tree, you need to compu
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Counting Bits</title>
    <link href="http://jianghao.wang/2019/leetCode%E7%AE%97%E6%B3%95/P338%20Counting%20Bits/"/>
    <id>http://jianghao.wang/2019/leetCode算法/P338 Counting Bits/</id>
    <published>2019-10-29T03:45:11.480Z</published>
    <updated>2019-10-29T05:40:42.133Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度中等）"><a href="#问题描述（难度中等）" class="headerlink" title="问题描述（难度中等）"></a>问题描述（难度中等）</h3><p>Given a non negative integer number <strong>num</strong>. For every numbers <strong>i</strong> in the range <strong>0 ≤ i ≤ num</strong> calculate the number of 1’s in their binary representation and return them as an array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: [0,1,1]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: [0,1,1,2,1,2]</span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong></p><ul><li>It is very easy to come up with a solution with run time <strong>O(n*sizeof(integer))</strong>. But can you do it in linear time <strong>O(n)</strong> /possibly in a single pass?</li><li>Space complexity should be <strong>O(n)</strong>.</li><li>Can you do it like a boss? Do it without using any builtin function like <strong>__builtin_popcount</strong> in c++ or in any other language.</li></ul><h3 id="方法一：Dynamic-Programming"><a href="#方法一：Dynamic-Programming" class="headerlink" title="方法一：Dynamic Programming"></a>方法一：Dynamic Programming</h3><p>动态规划的思路主要来源于重复子问题，通过递推公式：<strong><em>f(i)=f(i&gt;&gt;1)+(i&amp;1)。</em></strong>存在重复子问题导致递归的效率为N^2，通过动态规划时间换取空间减少时间复杂度到N。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P338;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> CommonUtils.ArrayUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态规划</span></span><br><span class="line"><span class="comment"> * 避免计算重复子问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] counts=<span class="keyword">new</span> <span class="keyword">int</span>[num+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//这里注意+的优先级大于&amp;的优先级</span></span><br><span class="line">            counts[i]=counts[i&gt;&gt;<span class="number">1</span>]+(i&amp;<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayUtils.getInstance().printIntArray(<span class="keyword">new</span> Solution().countBits(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度中等）&quot;&gt;&lt;a href=&quot;#问题描述（难度中等）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度中等）&quot;&gt;&lt;/a&gt;问题描述（难度中等）&lt;/h3&gt;&lt;p&gt;Given a non negative integer number &lt;s
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Palindromic Substrings</title>
    <link href="http://jianghao.wang/2019/leetCode%E7%AE%97%E6%B3%95/P647%20Palindromic%20Substrings/"/>
    <id>http://jianghao.wang/2019/leetCode算法/P647 Palindromic Substrings/</id>
    <published>2019-10-28T14:55:07.586Z</published>
    <updated>2019-10-28T15:01:32.305Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度中等）"><a href="#问题描述（难度中等）" class="headerlink" title="问题描述（难度中等）"></a>问题描述（难度中等）</h3><p>given a string, your task is to count how many palindromic substrings in this string.</p><p>The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abc&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Three palindromic strings: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;aaa&quot;</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Six palindromic strings: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The input string length won’t exceed 1000.</li></ol><h3 id="方法一：中心扩展法"><a href="#方法一：中心扩展法" class="headerlink" title="方法一：中心扩展法"></a>方法一：中心扩展法</h3><p>选择中心进行扩展，中心可以分为两种情况，第一种是单个字符，第二种是两个字符。其他的情况都可以从这两种情况为中心的字符进行扩展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P647;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中心扩展法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@autor</span> yeqiaozhu.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-10-28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingCircle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        string=s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//两个元素为中心</span></span><br><span class="line">            checkParamlings(i,i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//单个元素为中心</span></span><br><span class="line">            checkParamlings(i,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkParamlings</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span> &amp;&amp; j&lt;string.length() &amp;&amp; string.charAt(i) == string.charAt(j))&#123;</span><br><span class="line">            count++;</span><br><span class="line">            i--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s=<span class="string">"aaa"</span>;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> UsingCircle().countSubstrings(s));</span><br><span class="line"></span><br><span class="line">        String s1=<span class="string">"abc"</span>;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> UsingCircle().countSubstrings(s1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：二维数组"><a href="#方法二：二维数组" class="headerlink" title="方法二：二维数组"></a>方法二：二维数组</h3><p>二维数组保存结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P647;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] booleans;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        booleans=<span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()];</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//一层循环定义长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//定义</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j+i-<span class="number">1</span> &lt; s.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">1</span>) &#123;</span><br><span class="line">                    booleans[j][j]=<span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">2</span>) &#123;</span><br><span class="line">                    booleans[j][j+<span class="number">1</span>] = s.charAt(j)==s.charAt(j+<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    booleans[j][j+i-<span class="number">1</span>]=(s.charAt(j)==s.charAt(j+i-<span class="number">1</span>) &amp;&amp; booleans[j+<span class="number">1</span>][j+i-<span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (booleans[j][j+i-<span class="number">1</span>]) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s=<span class="string">"aaa"</span>;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().countSubstrings(s));</span><br><span class="line"></span><br><span class="line">        String s1=<span class="string">"abc"</span>;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().countSubstrings(s1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>中心扩展法思路比较简洁，可以作为算法扩展到其他的情形。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度中等）&quot;&gt;&lt;a href=&quot;#问题描述（难度中等）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度中等）&quot;&gt;&lt;/a&gt;问题描述（难度中等）&lt;/h3&gt;&lt;p&gt;given a string, your task is to count 
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Lowest Common Ancestor of a Binary Tree</title>
    <link href="http://jianghao.wang/2019/leetCode%E7%AE%97%E6%B3%95/P236%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree/"/>
    <id>http://jianghao.wang/2019/leetCode算法/P236 Lowest Common Ancestor of a Binary Tree/</id>
    <published>2019-10-28T03:16:19.573Z</published>
    <updated>2019-10-28T03:38:20.817Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度中等）"><a href="#问题描述（难度中等）" class="headerlink" title="问题描述（难度中等）"></a>问题描述（难度中等）</h3><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p><p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p><p>Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The LCA of nodes 5 and 1 is 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>All of the nodes’ values will be unique.</li><li>p and q are different and both values will exist in the binary tree.</li></ul><h3 id="方法一：递归实现"><a href="#方法一：递归实现" class="headerlink" title="方法一：递归实现"></a>方法一：递归实现</h3><p>递归的方式，左右子树递归，返回一个符合条件的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P236;</span><br><span class="line"><span class="keyword">import</span> CommonUtils.TreeNodeUtils;</span><br><span class="line"><span class="keyword">import</span> P104.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span> || root.val==p.val || root.val==q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left=lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right=lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span> (left!=<span class="keyword">null</span> &amp;&amp; right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left!=<span class="keyword">null</span>?left:right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints=&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        TreeNode treeNode=TreeNodeUtils.buildTreeNodeUsingArray(ints);</span><br><span class="line">        <span class="keyword">new</span> Solution().lowestCommonAncestor(treeNode,treeNode.left.left,treeNode.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法参考左序遍历：</p><p><img src="https://arthornye.github.io/images/lowest.jpg" alt="cmd-markdown-logo"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度中等）&quot;&gt;&lt;a href=&quot;#问题描述（难度中等）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度中等）&quot;&gt;&lt;/a&gt;问题描述（难度中等）&lt;/h3&gt;&lt;p&gt;Given a binary tree, find the lowest c
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Palindrome Linked List</title>
    <link href="http://jianghao.wang/2019/leetCode%E7%AE%97%E6%B3%95/P234%20Palindrome%20Linked%20List/"/>
    <id>http://jianghao.wang/2019/leetCode算法/P234 Palindrome Linked List/</id>
    <published>2019-10-27T10:53:24.958Z</published>
    <updated>2019-10-27T11:17:24.129Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述（难度简单）"><a href="#问题描述（难度简单）" class="headerlink" title="问题描述（难度简单）"></a>问题描述（难度简单）</h3><p>Given a singly linked list, determine if it is a palindrome.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong><br>Could you do it in O(n) time and O(1) space?</p><h3 id="方法一：Using-Reverse-LinkedList"><a href="#方法一：Using-Reverse-LinkedList" class="headerlink" title="方法一：Using Reverse LinkedList"></a>方法一：Using Reverse LinkedList</h3><p>倒转链表的变形，首先通过快慢指针定位到链表的中间位置，然后将后半部分的链表倒转。最后遍历一遍进行比较。</p><p><img src="https://arthornye.github.io/images/method.jpg" alt="cmd-markdown-logo"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P234;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> AddTwoNumbers.ListNode;</span><br><span class="line"><span class="keyword">import</span> CommonUtils.ListNodeUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找到链表的中点</span></span><br><span class="line"><span class="comment"> * 可以用快慢指针</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode reverse;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到中间的位置啦</span></span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后将后边的复制出来，改变指针的指向形成堆成</span></span><br><span class="line">        ListNode halfPart=<span class="keyword">new</span> ListNode(slow.val);</span><br><span class="line">        halfPart.next=slow.next;</span><br><span class="line">        slow.next=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两个链表构造完成将后半个链表旋转</span></span><br><span class="line">        reverseListNode(halfPart);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//旋转完了之后遍历进行比较</span></span><br><span class="line">        <span class="keyword">while</span> (reverse!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (reverse.val!=head.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head=head.next;</span><br><span class="line">            reverse=reverse.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseListNode</span><span class="params">(ListNode start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">            reverse=start;</span><br><span class="line">            <span class="keyword">return</span> reverse;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode subList=reverseListNode(start.next);</span><br><span class="line">        subList.next=start;</span><br><span class="line">        start.next=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        ListNode head=ListNodeUtils.buildWithArray(ints);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Solution().isPalindrome(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>链表定位中间位置可以用快慢指针，一个走一步一个走两步。</strong></li><li><strong>链表反转可以用递归实现。</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述（难度简单）&quot;&gt;&lt;a href=&quot;#问题描述（难度简单）&quot; class=&quot;headerlink&quot; title=&quot;问题描述（难度简单）&quot;&gt;&lt;/a&gt;问题描述（难度简单）&lt;/h3&gt;&lt;p&gt;Given a singly linked list, determine 
      
    
    </summary>
    
    
      <category term="leetCode算法" scheme="http://jianghao.wang/tags/leetCode%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
